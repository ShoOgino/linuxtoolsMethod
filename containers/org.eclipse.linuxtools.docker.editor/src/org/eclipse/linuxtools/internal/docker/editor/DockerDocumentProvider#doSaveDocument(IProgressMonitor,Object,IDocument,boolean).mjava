	@Override
	protected void doSaveDocument(IProgressMonitor monitor, Object element, IDocument document, boolean overwrite)
			throws CoreException {
		if (element instanceof FileStoreEditorInput) {

			String encoding = null;

			ElementInfo info = getElementInfo(element);
			Path filePath = Paths.get(((FileStoreEditorInput) element).getURI());

			encoding = getEncoding(element);

			Charset charset;
			try {
				charset = Charset.forName(encoding);
			} catch (UnsupportedCharsetException ex) {
				String message = NLS.bind(Messages.DockerDocumentProvider_encoding_not_supported, encoding);
				IStatus s = new Status(IStatus.ERROR, EditorsUI.PLUGIN_ID, IStatus.OK, message, ex);
				throw new CoreException(s);
			} catch (IllegalCharsetNameException ex) {
				String message = NLS.bind(Messages.DockerDocumentProvider_encoding_not_legal, encoding);
				IStatus s = new Status(IStatus.ERROR, EditorsUI.PLUGIN_ID, IStatus.OK, message, ex);
				throw new CoreException(s);
			}

			CharsetEncoder encoder = charset.newEncoder();
			encoder.onMalformedInput(CodingErrorAction.REPLACE);
			encoder.onUnmappableCharacter(CodingErrorAction.REPORT);

			InputStream stream;

			try {
				byte[] bytes;
				ByteBuffer byteBuffer = encoder.encode(CharBuffer.wrap(document.get()));
				if (byteBuffer.hasArray())
					bytes = byteBuffer.array();
				else {
					bytes = new byte[byteBuffer.limit()];
					byteBuffer.get(bytes);
				}
				stream = new ByteArrayInputStream(bytes, 0, byteBuffer.limit());
			} catch (CharacterCodingException ex) {
				Assert.isTrue(ex instanceof UnmappableCharacterException);
				String message = NLS.bind(Messages.DockerDocumentProvider_cannot_be_mapped
						+ Messages.DockerDocumentProvider_chars_not_supported, encoding);
				IStatus s = new Status(IStatus.ERROR, EditorsUI.PLUGIN_ID, EditorsUI.CHARSET_MAPPING_FAILED, message,
						null);
				throw new CoreException(s);
			}

			if (Files.exists(filePath)) {
				// inform about the upcoming content change
				fireElementStateChanging(element);
				try (FileWriter fw = new FileWriter(filePath.toFile());
						InputStreamReader istream = new InputStreamReader(stream)) {
					char[] bb = new char[1024];
					int nRead = istream.read(bb);
					while (nRead > 0) {
						fw.write(bb, 0, nRead);
						nRead = istream.read(bb);
					}
				} catch (RuntimeException | IOException x) {
					// inform about failure
					fireElementStateChangeFailed(element);
					throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, x.getMessage()));
				}

				// If here, the editor state will be flipped to "not dirty".
				// Thus, the state changing flag will be reset.

				if (info != null) {

					ResourceMarkerAnnotationModel model = (ResourceMarkerAnnotationModel) info.fModel;
					if (model != null)
						model.updateMarkers(info.fDocument);
				}

			} else {
				try {
					Files.createFile(filePath);
					try (FileWriter fw = new FileWriter(filePath.toFile());
							InputStreamReader istream = new InputStreamReader(stream)) {
						char[] bb = new char[1024];
						int nRead = istream.read(bb);
						while (nRead > 0) {
							fw.write(bb, 0, nRead);
							nRead = istream.read(bb);
						}
					} catch (IOException x) {
						throw x;
					}
				} catch (IOException e) {
					throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, e.getMessage()));
				} finally {
					monitor.done();
				}
			}

		} else {
			super.doSaveDocument(monitor, element, document, overwrite);
		}
	}

