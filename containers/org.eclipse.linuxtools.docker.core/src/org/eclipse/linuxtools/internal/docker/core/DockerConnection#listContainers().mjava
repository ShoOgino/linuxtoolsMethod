	private List<IDockerContainer> listContainers() throws DockerException {
		final Map<String, IDockerContainer> updatedContainers = new HashMap<>();
		try {
			final List<Container> nativeContainers = new ArrayList<>();
			synchronized (clientLock) {
				// Check that client is not null as this connection may have
				// been closed but there is an async request to update the
				// containers list left in the queue
				if (client == null) {
					// in that case the list becomes empty, which is fine is
					// there's no client.
					return Collections.emptyList();
				}
				nativeContainers.addAll(client.listContainers(
						DockerClient.ListContainersParam.allContainers()));
				this.active = true;
			}
			// We have a list of containers. Now, we translate them to our own
			// core format in case we decide to change the underlying engine
			// in the future.
			for (Container nativeContainer : nativeContainers) {
				// For containers that have exited, make sure we aren't tracking
				// them with a logging thread.
				if (nativeContainer.status()
						.startsWith(Messages.Exited_specifier)) {
					synchronized (loggingThreads) {
						if (loggingThreads.containsKey(nativeContainer.id())) {
							loggingThreads.get(nativeContainer.id())
									.requestStop();
							loggingThreads.remove(nativeContainer.id());
						}
					}
				}
				// skip containers that are being removed
				if (nativeContainer.status()
						.equals(Messages.Removal_In_Progress_specifier)) {
					continue;
				}
				// re-use info from existing container with same id
				if (this.containers != null && this.containersById
						.containsKey(nativeContainer.id())) {
					final IDockerContainer container = this.containersById
							.get(nativeContainer.id());
					updatedContainers.put(nativeContainer.id(),
							new DockerContainer(this, nativeContainer,
									container.info()));
				} else {
					updatedContainers.put(nativeContainer.id(),
							new DockerContainer(this, nativeContainer));
				}
			}
		} catch (com.spotify.docker.client.DockerException
				| InterruptedException e) {
			if (active) {
				active = false;
				throw new DockerException(
						NLS.bind(Messages.List_Docker_Containers_Failure,
								this.getName()),
						e);
			}
		} finally {
			// assign the new list of containers in a locked block of code to
			// prevent concurrent access, even if an exception was raised.
			synchronized (containerLock) {
				this.containersById = updatedContainers;
				this.containers = sort(this.containersById.values(),
						new Comparator<IDockerContainer>() {

							@Override
							public int compare(final IDockerContainer container,
									final IDockerContainer otherContainer) {
								return container.name()
										.compareTo(otherContainer.name());
							}

						});

				this.containersLoaded = true;
			}
		}

		// perform notification outside of containerLock so we don't have a View
		// causing a deadlock
		// TODO: we should probably notify the listeners only if the containers
		// list changed.
		notifyContainerListeners(this.containers);
		return this.containers;
	}

