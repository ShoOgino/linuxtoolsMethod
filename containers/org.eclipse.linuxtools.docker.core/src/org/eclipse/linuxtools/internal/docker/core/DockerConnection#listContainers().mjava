	private List<IDockerContainer> listContainers() throws DockerException {
		final List<IDockerContainer> dclist = new ArrayList<>();
		synchronized (containerLock) {
			List<Container> list = null;
			try {
				synchronized (clientLock) {
					// Check that client is not null as this connection may have
					// been closed but there is an async request to update the
					// containers list left in the queue
					if (client == null)
						return dclist;
					list = client.listContainers(
							DockerClient.ListContainersParam.allContainers());
				}
			} catch (com.spotify.docker.client.DockerException
					| InterruptedException e) {
				throw new DockerException(
						NLS.bind(
						Messages.List_Docker_Containers_Failure,
						this.getName()), e);
			}

			// We have a list of containers. Now, we translate them to our own
			// core format in case we decide to change the underlying engine
			// in the future.
			for (Container c : list) {
				// For containers that have exited, make sure we aren't tracking
				// them with a logging thread.
				if (c.status().startsWith(Messages.Exited_specifier)) {
					if (loggingThreads.containsKey(c.id())) {
						loggingThreads.get(c.id()).requestStop();
						loggingThreads.remove(c.id());
					}
				}
				if (!c.status().equals(Messages.Removal_In_Progress_specifier)) {
					dclist.add(new DockerContainer(this, c));
				}
			}
			containers = dclist;
		}
		// perform notification outside of containerLock so we don't have a View
		// causing a deadlock
		notifyContainerListeners(dclist);
		return dclist;
	}

