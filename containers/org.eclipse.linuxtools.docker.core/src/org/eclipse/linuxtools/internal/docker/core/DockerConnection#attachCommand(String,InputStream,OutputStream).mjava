	public void attachCommand(final String id,
			final InputStream in, final OutputStream out)
					throws DockerException {

		final byte[] prevCmd = new byte[1024];
		try {
			final LogStream pty_stream = client.attachContainer(id,
					AttachParameter.STDIN, AttachParameter.STDOUT,
					AttachParameter.STDERR, AttachParameter.STREAM,
					AttachParameter.LOGS);
			final IDockerContainerInfo info = getContainerInfo(id);
			final boolean isTtyEnabled = info.config().tty();
			final boolean isOpenStdin = info.config().openStdin();

			if (isTtyEnabled) {
				OutputStream tout = noBlockingOutputStream(HttpHijackWorkaround.getOutputStream(pty_stream, getUri()));
				InputStream tin = HttpHijackWorkaround.getInputStream(pty_stream);
				// org.eclipse.tm.terminal.connector.ssh.controls.SshWizardConfigurationPanel
				Map<String, Object> properties = new HashMap<>();
				properties.put(ITerminalsConnectorConstants.PROP_DELEGATE_ID, "org.eclipse.tm.terminal.connector.streams.launcher.streams");
				properties.put(ITerminalsConnectorConstants.PROP_TERMINAL_CONNECTOR_ID, "org.eclipse.tm.terminal.connector.streams.StreamsConnector");
				properties.put(ITerminalsConnectorConstants.PROP_TITLE, info.name());
				properties.put(ITerminalsConnectorConstants.PROP_LOCAL_ECHO, false);
				properties.put(ITerminalsConnectorConstants.PROP_FORCE_NEW, true);
				properties.put(ITerminalsConnectorConstants.PROP_STREAMS_STDIN, tout);
				properties.put(ITerminalsConnectorConstants.PROP_STREAMS_STDOUT, tin);
				/*
				 * The JVM will call finalize() on 'pty_stream' (LogStream)
				 * since we hold no references to it (although we do hold
				 * references to one of its heavily nested fields. The
				 * LogStream overrides finalize() to close the stream being
				 * used so we must preserve a reference to it.
				 */
				properties.put("PREVENT_JVM_GC_FINALIZE", pty_stream);
				ITerminalService service = TerminalServiceFactory.getService();
				service.openConsole(properties, null);
			}

			// Data from the given input stream
			// Written to container's STDIN
			Thread t_in = new Thread(new Runnable() {
				@Override
				public void run() {
					byte[] buff = new byte[1024];
					int n;
					try {
						WritableByteChannel pty_out = HttpHijackWorkaround
								.getOutputStream(pty_stream, getUri());
						while ((n = in.read(buff)) != -1
								&& getContainerInfo(id).state().running()) {
							synchronized (prevCmd) {
								pty_out.write(ByteBuffer.wrap(buff, 0, n));
								for (int i = 0; i < prevCmd.length; i++) {
									prevCmd[i] = buff[i];
								}
							}
							buff = new byte[1024];
						}
					} catch (Exception e) {
					}
				}
			});

			if (!isTtyEnabled && isOpenStdin) {
				t_in.start();
			}
		} catch (Exception e) {
			throw new DockerException(e.getMessage(), e.getCause());
		}
	}

