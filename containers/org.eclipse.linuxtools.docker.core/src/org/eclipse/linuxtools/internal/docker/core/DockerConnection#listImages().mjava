	@Override
	public List<IDockerImage> listImages() throws DockerException {
		final List<IDockerImage> tempImages = new ArrayList<>();
		synchronized (imageLock) {
			List<Image> rawImages = new ArrayList<>();
			try {
				synchronized (clientLock) {
					// Check that client is not null as this connection may have
					// been closed but there is an async request to update the
					// images list left in the queue
					if (client == null)
						return tempImages;
					rawImages = client.listImages(
							DockerClient.ListImagesParam.allImages());
				}
			} catch (DockerTimeoutException e) {
				if (isOpen()) {
					Activator.log(
							new Status(IStatus.WARNING, Activator.PLUGIN_ID,
									Messages.Docker_Connection_Timeout, e));
					close();
				}
			} catch (com.spotify.docker.client.DockerRequestException e) {
				throw new DockerException(e.message());
			} catch (com.spotify.docker.client.DockerException
					| InterruptedException e) {
				if (isOpen() && e.getCause() != null
						&& e.getCause().getCause() != null
						&& e.getCause().getCause() instanceof ProcessingException) {
					close();
				} else {
					throw new DockerException(e.getMessage());
				}
			}
			// We have a list of images. Now, we translate them to our own
			// core format in case we decide to change the underlying engine
			// in the future. We also look for intermediate and dangling images.
			final Set<String> imageParentIds = new HashSet<>();
			for (Image rawImage : rawImages) {
				imageParentIds.add(rawImage.parentId());
			}
			for (Image rawImage : rawImages) {
				final boolean taggedImage = !(rawImage.repoTags() != null
						&& rawImage.repoTags().size() == 1
						&& rawImage
						.repoTags().contains("<none>:<none>")); //$NON-NLS-1$
				final boolean intermediateImage = !taggedImage
						&& imageParentIds.contains(rawImage.id());
				final boolean danglingImage = !taggedImage
						&& !intermediateImage;
				// return one IDockerImage per raw image
				final List<String> repoTags = rawImage.repoTags() != null
						? new ArrayList<>(rawImage.repoTags())
						: Arrays.asList("<none>:<none>"); //$NON-NLS-1$
				Collections.sort(repoTags);
				final String repo = DockerImage.extractRepo(repoTags.get(0));
				final List<String> tags = Arrays
						.asList(DockerImage.extractTag(repoTags.get(0)));
				tempImages.add(new DockerImage(this, repoTags, repo,
						tags, rawImage.id(), rawImage.parentId(),
						rawImage.created(), rawImage.size(),
						rawImage.virtualSize(), intermediateImage,
						danglingImage));
			}
			images = tempImages;
		}
		// Perform notification outside of lock so that listener doesn't cause a
		// deadlock to occur
		notifyImageListeners(tempImages);
		return tempImages;
	}

