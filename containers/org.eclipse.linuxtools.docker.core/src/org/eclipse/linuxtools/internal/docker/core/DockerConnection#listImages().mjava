	@Override
	public List<IDockerImage> listImages() throws DockerException {
		final List<IDockerImage> dilist = new ArrayList<>();
		synchronized (imageLock) {
			List<Image> rawImages = null;
			try {
				synchronized (clientLock) {
					// Check that client is not null as this connection may have
					// been closed but there is an async request to update the
					// images list left in the queue
					if (client == null)
						return dilist;
					rawImages = client.listImages(
							DockerClient.ListImagesParam.allImages());
				}
			} catch (com.spotify.docker.client.DockerRequestException e) {
				throw new DockerException(e.message());
			} catch (com.spotify.docker.client.DockerException
					| InterruptedException e) {
				DockerException f = new DockerException(e);
				throw f;
			}
			// We have a list of images. Now, we translate them to our own
			// core format in case we decide to change the underlying engine
			// in the future. We also look for intermediate and dangling images.
			final Set<String> imageParentIds = new HashSet<>();
			for (Image rawImage : rawImages) {
				imageParentIds.add(rawImage.parentId());
			}
			for (Image rawImage : rawImages) {
				final boolean taggedImage = !(rawImage.repoTags().size() == 1 && rawImage
						.repoTags().contains("<none>:<none>")); //$NON-NLS-1$
				final boolean intermediateImage = !taggedImage
						&& imageParentIds.contains(rawImage.id());
				final boolean danglingImage = !taggedImage
						&& !intermediateImage;
				// FIXME: if an image with a unique ID belongs to multiple repos, we should
				// probably have multiple instances of IDockerImage
				final Map<String, List<String>> repoTags = DockerImage.extractTagsByRepo(rawImage.repoTags());
				for(Entry<String, List<String>> entry : repoTags.entrySet()) {
					final String repo = entry.getKey();
					final List<String> tags = entry.getValue();
					dilist.add(new DockerImage(this, rawImage
							.repoTags(), repo, tags, rawImage.id(), rawImage.parentId(),
							rawImage.created(), rawImage.size(), rawImage
									.virtualSize(), intermediateImage,
							danglingImage));
				}
			}
			images = dilist;
		}
		// Perform notification outside of lock so that listener doesn't cause a
		// deadlock to occur
		notifyImageListeners(dilist);
		return dilist;
	}

