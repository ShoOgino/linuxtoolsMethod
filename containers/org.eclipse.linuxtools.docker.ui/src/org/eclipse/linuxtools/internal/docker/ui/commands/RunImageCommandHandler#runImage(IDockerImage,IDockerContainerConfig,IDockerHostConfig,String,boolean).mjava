	public static void runImage(final IDockerImage image,
			final IDockerContainerConfig containerConfig,
			final IDockerHostConfig hostConfig, final String containerName,
			final boolean removeWhenExits) {
		final IDockerConnection connection = image.getConnection();
		if (containerConfig.tty()) {
			// show the console view
			Display.getDefault().asyncExec(() -> {
				try {
					PlatformUI.getWorkbench().getActiveWorkbenchWindow()
							.getActivePage()
							.showView(IConsoleConstants.ID_CONSOLE_VIEW);
				} catch (Exception e) {
					Activator.log(e);
				}
			});
		}

		// Create the container in a non-UI thread.
		final Job runImageJob = new Job(
				DVMessages.getString("RunImageCreateContainer.job")) { //$NON-NLS-1$

			@Override
			protected IStatus run(final IProgressMonitor monitor) {
				monitor.beginTask(
						DVMessages.getString("RunImageRunningTask.msg"), 2); //$NON-NLS-1$
				String containerId = null;
				try {
					final SubMonitor createContainerMonitor = SubMonitor
							.convert(monitor, 1);
					// create the container
					createContainerMonitor.beginTask(
							DVMessages.getString(
									"RunImageCreatingContainerTask.msg"), //$NON-NLS-1$
							1);
					containerId = ((DockerConnection) connection)
							.createContainer(containerConfig, hostConfig, containerName);
					final IDockerContainer container = ((DockerConnection) connection)
							.getContainer(containerId);
					createContainerMonitor.done();
					// abort if operation was cancelled
					if (monitor.isCanceled()) {
						return Status.CANCEL_STATUS;
					}
					// start the container
					final SubMonitor startContainerMonitor = SubMonitor
							.convert(monitor, 1);
					startContainerMonitor.beginTask(DVMessages
							.getString("RunImageStartingContainerTask.msg"), 1); //$NON-NLS-1$
					final RunConsole console = getRunConsole(connection,
							container);
					if (console != null) {
						// if we are auto-logging, show the console
						console.showConsole();
						((DockerConnection) connection).startContainer(
								containerId, console.getOutputStream());
					} else {
						((DockerConnection) connection)
								.startContainer(containerId, null);
					}
					startContainerMonitor.done();
					// create a launch configuration from the container
					LaunchConfigurationUtils.createRunImageLaunchConfiguration(image,
							containerConfig,
							hostConfig, containerName,
							removeWhenExits);
				} catch (final DockerException | InterruptedException e) {
					Display.getDefault().syncExec(() -> MessageDialog.openError(
							PlatformUI.getWorkbench().getActiveWorkbenchWindow()
									.getShell(),
							DVMessages.getFormattedString(
									ERROR_CREATING_CONTAINER,
									containerConfig.image()),
							e.getMessage()));
				} finally {
					if (removeWhenExits) {
						try {
							if (containerId != null) {
								// Wait for the container to finish
								((DockerConnection) connection)
										.waitForContainer(containerId);
								// Drain the logging thread before we remove the
								// container
								((DockerConnection) connection)
										.stopLoggingThread(containerId);
								while (((DockerConnection) connection)
										.loggingStatus(
												containerId) == EnumDockerLoggingStatus.LOGGING_ACTIVE) {
									Thread.sleep(1000);
								}
							}
						} catch (DockerException | InterruptedException e) {
							// ignore any errors in waiting for container or
							// draining log
						}
						try {
							// try and remove the container if it was created
							if (containerId != null)
								((DockerConnection) connection)
										.removeContainer(containerId);
						} catch (DockerException | InterruptedException e) {
							final String id = containerId;
							Display.getDefault()
									.syncExec(() -> MessageDialog.openError(
											PlatformUI.getWorkbench()
													.getActiveWorkbenchWindow()
													.getShell(),
											DVMessages.getFormattedString(
													ERROR_REMOVING_CONTAINER,
													id),
											e.getMessage()));
						}
					}

					monitor.done();
				}
				return Status.OK_STATUS;
			}
		};
		runImageJob.schedule();

	}

