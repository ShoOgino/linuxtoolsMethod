	private void runImage(final IDockerConnection connection,
			final IDockerContainerConfig containerConfig,
			final IDockerHostConfig hostConfig, final String containerName,
			final boolean removeWhenExits) {
		if (containerConfig.tty()) {
			// show the console view
			try {
				PlatformUI.getWorkbench().getActiveWorkbenchWindow()
						.getActivePage()
						.showView(IConsoleConstants.ID_CONSOLE_VIEW);
			} catch (PartInitException e) {
				Activator.log(e);
			}
		}

		// Create the container in a non-UI thread.
		final Job runImageJob = new Job(
				DVMessages.getString("RunImageCreateContainer.job")) { //$NON-NLS-1$

			@Override
			protected IStatus run(final IProgressMonitor monitor) {
				monitor.beginTask(
						DVMessages.getString("RunImageRunningTask.msg"), 2); //$NON-NLS-1$
				String id = null;
				try {
					final SubProgressMonitor createContainerMonitor = new SubProgressMonitor(
							monitor, 1);
					// create the container
					createContainerMonitor.beginTask(
							DVMessages.getString(
									"RunImageCreatingContainerTask.msg"), //$NON-NLS-1$
							1);
					final String containerId = ((DockerConnection) connection)
							.createContainer(containerConfig, hostConfig, containerName);
					id = containerId;
					final IDockerContainer container = ((DockerConnection) connection)
							.getContainer(containerId);

					createContainerMonitor.done();
					// abort if operation was cancelled
					if (monitor.isCanceled()) {
						return Status.CANCEL_STATUS;
					}
					// start the container
					final SubProgressMonitor startContainerMonitor = new SubProgressMonitor(
							monitor, 1);
					startContainerMonitor.beginTask(DVMessages
							.getString("RunImageStartingContainerTask.msg"), 1); //$NON-NLS-1$
					final RunConsole console = getRunConsole(connection,
							container);
					if (console != null) {
						// if we are auto-logging, show the console
						console.showConsole();
						((DockerConnection) connection).startContainer(
								containerId, console.getOutputStream());
					} else {
						((DockerConnection) connection)
								.startContainer(containerId, null);
					}
					startContainerMonitor.done();
				} catch (final DockerException | InterruptedException e) {
					Display.getDefault().syncExec(new Runnable() {

						@Override
						public void run() {
							MessageDialog.openError(
									Display.getCurrent().getActiveShell(),
									DVMessages.getFormattedString(
											ERROR_CREATING_CONTAINER,
											containerConfig.image()),
									e.getMessage());

						}

					});
				} finally {
					if (removeWhenExits) {
						try {
							if (id != null) {
								// Wait for the container to finish
								((DockerConnection) connection)
										.waitForContainer(id);
								// Drain the logging thread before we remove the
								// container
								((DockerConnection) connection)
										.stopLoggingThread(id);
								while (((DockerConnection) connection)
										.loggingStatus(
												id) == EnumDockerLoggingStatus.LOGGING_ACTIVE) {
									Thread.sleep(1000);
								}
							}
						} catch (DockerException | InterruptedException e) {
							// ignore any errors in waiting for container or
							// draining log
						}
						try {
							// try and remove the container if it was created
							if (id != null)
								((DockerConnection) connection)
										.removeContainer(id);
						} catch (DockerException | InterruptedException e) {
							final String containerId = id;
							Display.getDefault().syncExec(new Runnable() {

								@Override
								public void run() {
									MessageDialog.openError(
											Display.getCurrent()
													.getActiveShell(),
											DVMessages.getFormattedString(
													ERROR_REMOVING_CONTAINER,
													containerId),
											e.getMessage());

								}

							});
						}
					}

					monitor.done();
				}
				return Status.OK_STATUS;
			}
		};
		runImageJob.schedule();

	}

