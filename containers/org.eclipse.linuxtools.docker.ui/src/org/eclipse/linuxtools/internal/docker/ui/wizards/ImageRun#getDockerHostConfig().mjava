	public IDockerHostConfig getDockerHostConfig() {
		final ImageRunSelectionModel selectionModel = this.imageRunSelectionPage
				.getModel();
		final ImageRunResourceVolumesVariablesModel resourcesModel = this.imageRunResourceVolumesPage
				.getModel();
		final ImageRunNetworkModel networkModel = this.imageRunNetworkPage
				.getModel();

		final DockerHostConfig.Builder hostConfigBuilder = new DockerHostConfig.Builder();
		if (selectionModel.isPublishAllPorts()) {
			hostConfigBuilder.publishAllPorts(true);
		} else {
			final Map<String, List<IDockerPortBinding>> portBindings = new HashMap<>();
			for (Iterator<ExposedPortModel> iterator = selectionModel
					.getExposedPorts().iterator(); iterator.hasNext();) {
				final ExposedPortModel exposedPort = iterator.next();
				// only selected Ports in the CheckboxTableViewer are exposed.
				if (!selectionModel.getSelectedPorts().contains(exposedPort)) {
					continue;
				}
				final DockerPortBinding portBinding = new DockerPortBinding(
						exposedPort.getHostAddress(),
						exposedPort.getHostPort());
				portBindings.put(
						exposedPort.getContainerPort()
								+ exposedPort.getPortType(),
						Arrays.<IDockerPortBinding> asList(portBinding));
			}
			hostConfigBuilder.portBindings(portBindings);
		}
		// container links
		final List<String> links = new ArrayList<>();
		for (Iterator<ContainerLinkModel> iterator = selectionModel.getLinks()
				.iterator(); iterator.hasNext();) {
			final ContainerLinkModel link = iterator.next();
			links.add(link.getContainerName() + ':' + link.getContainerAlias());
		}
		hostConfigBuilder.links(links);

		// data volumes
		final List<String> volumesFrom = new ArrayList<>();
		final List<String> binds = new ArrayList<>();
		for (Iterator<DataVolumeModel> iterator = resourcesModel
				.getDataVolumes().iterator(); iterator.hasNext();) {
			final DataVolumeModel dataVolume = iterator.next();
			// only data volumes selected in the CheckBoxTableViewer are
			// included.
			if (!resourcesModel.getSelectedDataVolumes().contains(dataVolume)) {
				continue;
			}

			switch (dataVolume.getMountType()) {
			case HOST_FILE_SYSTEM:
				String bind = LaunchConfigurationUtils
						.convertToUnixPath(dataVolume.getHostPathMount())
						+ ':' + dataVolume.getContainerPath() + ":Z"; //$NON-NLS-1$ //$NON-NLS-2$
				if (dataVolume.isReadOnly()) {
					bind += ",ro"; //$NON-NLS-1$
				}
				binds.add(bind);
				break;
			case CONTAINER:
				volumesFrom.add(dataVolume.getContainerMount());
				break;
			default:
				break;

			}
		}
		hostConfigBuilder.binds(binds);
		hostConfigBuilder.volumesFrom(volumesFrom);
		hostConfigBuilder.privileged(selectionModel.isPrivileged());
		String networkMode = networkModel.getNetworkModeString();
		// if network mode is not default, set it in host config
		if (networkMode != null
				&& !networkMode.equals(ImageRunNetworkModel.DEFAULT_MODE))
			hostConfigBuilder.networkMode(networkMode);
		// memory constraints (in bytes)
		if (resourcesModel.isEnableResourceLimitations()) {
			hostConfigBuilder.memory(resourcesModel.getMemoryLimit() * MB);
			hostConfigBuilder.cpuShares(resourcesModel.getCpuShareWeight());
		}
		return hostConfigBuilder.build();
	}

