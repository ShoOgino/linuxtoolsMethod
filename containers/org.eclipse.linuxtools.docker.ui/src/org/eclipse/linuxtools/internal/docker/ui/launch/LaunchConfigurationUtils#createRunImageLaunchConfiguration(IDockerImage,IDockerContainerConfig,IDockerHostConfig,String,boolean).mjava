	/**
	 * Creates a new {@link ILaunchConfiguration} for the given
	 * {@link IDockerContainer}.
	 * 
	 * @param baseConfigurationName
	 *            the base configuration name to use when creating the
	 *            {@link ILaunchConfiguration}.
	 * @param image
	 *            the {@link IDockerImage} used to create the container
	 * @param containerName
	 *            the actual container name (given by the user or generated by
	 *            the Docker daemon)
	 * @param containerConfig
	 * @param hostConfig
	 *            the user-provided {@link IDockerHostConfig} (created
	 *            container's one)
	 * @param removeWhenExits
	 *            flag to indicate if container should be removed when exited
	 * @return the generated {@link ILaunchConfiguration}
	 * 
	 */
	public static ILaunchConfiguration createRunImageLaunchConfiguration(
			final IDockerImage image,
			final IDockerContainerConfig containerConfig,
			final IDockerHostConfig hostConfig, final String containerName,
			final boolean removeWhenExits) {
		try {
			final ILaunchManager manager = DebugPlugin.getDefault()
					.getLaunchManager();
			final ILaunchConfigurationType type = manager
					.getLaunchConfigurationType(
							IRunDockerImageLaunchConfigurationConstants.CONFIG_TYPE_ID);
			final String imageName = createRunImageLaunchConfigurationName(
					image);
			// using the image repo + first tag
			final ILaunchConfigurationWorkingCopy workingCopy = getLaunchConfigurationWorkingCopy(
					type, imageName);
			workingCopy.setAttribute(CREATION_DATE,
					DATE_FORMAT.format(new Date()));
			workingCopy.setAttribute(CONNECTION_NAME,
					image.getConnection().getName());
			workingCopy.setAttribute(IMAGE_ID, image.id());
			workingCopy.setAttribute(IMAGE_NAME,
					createRunImageLaunchConfigurationName(image));
			if (containerName != null && !containerName.isEmpty()) {
				workingCopy.setAttribute(CONTAINER_NAME, containerName);
			}
			// if we know the raw command string, use it since the container
			// config will remove quotes to split up command properly
			DockerContainerConfig config = (DockerContainerConfig) containerConfig;
			if (config.rawcmd() != null) {
				workingCopy.setAttribute(COMMAND, config.rawcmd());
			} else {
				workingCopy.setAttribute(COMMAND,
						toString(containerConfig.cmd()));
			}
			workingCopy.setAttribute(ENTRYPOINT,
					toString(containerConfig.entrypoint()));
			// selected ports
			workingCopy.setAttribute(PUBLISH_ALL_PORTS,
					hostConfig.publishAllPorts());
			// format: <containerPort><type>:<hostIP>:<hostPort>
			if (hostConfig.publishAllPorts()) {
				final IDockerImageInfo imageInfo = image.getConnection()
						.getImageInfo(image.id());
				if (imageInfo != null) {
					workingCopy.setAttribute(PUBLISHED_PORTS,
							serializePortBindings(imageInfo.containerConfig()
									.exposedPorts()));
				}
			} else {
				workingCopy.setAttribute(PUBLISHED_PORTS,
						serializePortBindings(hostConfig.portBindings()));
			}
			// links (with format being: "<containerName>:<containerAlias>")
			workingCopy.setAttribute(LINKS, hostConfig.links());
			// env variables
			workingCopy.setAttribute(ENV_VARIABLES, containerConfig.env());
			// labels
			workingCopy.setAttribute(LABELS, containerConfig.labels());
			// volumes
			final List<String> volumes = new ArrayList<>();
			// volumes from other containers
			for (String volumeFrom : hostConfig.volumesFrom()) {
				final DataVolumeModel volume = DataVolumeModel
						.parseVolumeFrom(volumeFrom);
				if (volume != null) {
					volumes.add(volume.toString());
				}
			}
			// bindings to host directory or file
			for (String bind : hostConfig.binds()) {
				final DataVolumeModel volume = DataVolumeModel
						.parseHostBinding(bind);
				if (volume != null) {
					volumes.add(volume.toString());
				}
			}
			// TODO: container path declaration

			workingCopy.setAttribute(DATA_VOLUMES, volumes);
			// options
			workingCopy.setAttribute(AUTO_REMOVE, removeWhenExits);
			workingCopy.setAttribute(ALLOCATE_PSEUDO_CONSOLE,
					containerConfig.tty());
			workingCopy.setAttribute(INTERACTIVE, containerConfig.openStdin());
			workingCopy.setAttribute(PRIVILEGED, hostConfig.privileged());
			workingCopy.setAttribute(READONLY,
					((DockerHostConfig) hostConfig).readonlyRootfs());
			if (hostConfig.networkMode() != null)
				workingCopy.setAttribute(NETWORK_MODE,
						hostConfig.networkMode());
				
			// resources limitations
			if (containerConfig.memory() != null) {
				workingCopy.setAttribute(ENABLE_LIMITS, true);
				// memory in containerConfig is expressed in bytes
				workingCopy.setAttribute(MEMORY_LIMIT, Long
						.toString(containerConfig.memory().longValue() / MB));
			}
			if (containerConfig.cpuShares() != null) {
				workingCopy.setAttribute(ENABLE_LIMITS, true);
				workingCopy.setAttribute(CPU_PRIORITY,
						containerConfig.cpuShares().toString());
			}
			return workingCopy.doSave();
		} catch (CoreException e) {
			Activator.log(new Status(IStatus.ERROR, Activator.PLUGIN_ID,
					LaunchMessages.getString(
							"RunDockerImageLaunchConfiguration.creation.failure"), //$NON-NLS-1$
					e));
		}
		return null;
	}

