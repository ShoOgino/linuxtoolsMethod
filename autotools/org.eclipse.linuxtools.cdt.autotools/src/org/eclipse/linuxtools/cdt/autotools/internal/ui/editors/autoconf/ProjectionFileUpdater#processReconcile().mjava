	public void processReconcile() {
		if (!isInstalled())
			return;
		
		ProjectionAnnotationModel model= (ProjectionAnnotationModel) fEditor.getAdapter(ProjectionAnnotationModel.class);
		if (model == null)
			return;
		
		try {
			IDocumentProvider provider= fEditor.getDocumentProvider();
			fCachedDocument= provider.getDocument(fEditor.getEditorInput());
			fAllowCollapsing= false;
			
			Map<AutoconfProjectionAnnotation, Position> additions= new HashMap<AutoconfProjectionAnnotation, Position>();
			List<AutoconfProjectionAnnotation> deletions= new ArrayList<AutoconfProjectionAnnotation>();
			List<AutoconfProjectionAnnotation> updates = new ArrayList<AutoconfProjectionAnnotation>();
			
			Map<AutoconfProjectionAnnotation, Position> updated= computeAdditions(fEditor.getRootElement());
			
			Map<AutoconfElement, List<AutoconfProjectionAnnotation>> previous= createAnnotationMap(model);
			
			
			Iterator<AutoconfProjectionAnnotation> e= updated.keySet().iterator();
			while (e.hasNext()) {
				AutoconfProjectionAnnotation annotation= (AutoconfProjectionAnnotation) e.next();
				AutoconfElement element= annotation.getElement();
				Position position= (Position) updated.get(annotation);
				
				List<AutoconfProjectionAnnotation> annotations= previous.get(element);
				if (annotations == null) {
					additions.put(annotation, position);
				} else {
					Iterator<AutoconfProjectionAnnotation> x= annotations.iterator();
					while (x.hasNext()) {
						AutoconfProjectionAnnotation a= (AutoconfProjectionAnnotation) x.next();
						if (annotation.isComment() == a.isComment()) {
							Position p= model.getPosition(a);
							if (p != null && !position.equals(p)) {
								p.setOffset(position.getOffset());
								p.setLength(position.getLength());
								updates.add(a);
							}
							x.remove();
							break;
						}
					}
										
					if (annotations.isEmpty())
						previous.remove(element);
				}
			}
			
			Iterator<List<AutoconfProjectionAnnotation>> e2 = previous.values().iterator();
			while (e2.hasNext()) {
				List<AutoconfProjectionAnnotation> list= e2.next();
				int size= list.size();
				for (int i= 0; i < size; i++)
					deletions.add(list.get(i));
			}

			match(model, deletions, additions, updates);

			Annotation[] removals= new Annotation[deletions.size()];
			deletions.toArray(removals);
			Annotation[] changes= new Annotation[updates.size()];
			updates.toArray(changes);
			model.modifyAnnotations(removals, additions, changes);
			
		} finally {
			fCachedDocument= null;
			fAllowCollapsing= true;
		}
	}

