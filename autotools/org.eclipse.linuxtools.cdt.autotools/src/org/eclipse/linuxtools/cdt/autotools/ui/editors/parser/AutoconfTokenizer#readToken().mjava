	/** Read the next token. Returns an EOF token at EOF. */
	public Token readToken() {
		if (offset >= chars.length)
			return eofToken;
		
		char ch = chars[offset];
		
		// skip whitespace (but not EOL)
		while (isWhitespace(ch)) {
			offset++;
			if (offset >= chars.length)
				return eofToken;
			ch = chars[offset];
		}

		// in shell mode, strip comments up to eol 
		if (!isM4Context && ch == '#') {
			while (offset < chars.length) {
				ch = chars[offset];
				if (ch == '\n')
					break;
				offset++;
			}
			
			// keep inside doc if we didn't find that EOL
			if (offset >= chars.length)
				offset--;
		}

		startOffset = offset;
		StringBuffer buffer = new StringBuffer();
		
		// check EOL
		if (ch == '\r' || ch == '\n') {
			buffer.append(ch);
			offset++;
			if (ch == '\r' && offset < chars.length && chars[offset] == '\n') {
				buffer.append(chars[offset++]);
			}
			return makeToken(ITokenConstants.EOL, buffer.toString());
		}
		
		// TODO: this parser always uses fixed logic for identifier reading, ignoring m4's "changeword"
		if (isLeadIdentifierChar(ch)) {
			return parseWord(ch);
		}
		
		// check comments and quotes
		if (isM4Context) {
			if (lookAhead(m4OpenComment)) {
				boolean found = false;
				// keep reading until the close comment (these are NOT nested)
				while (offset < chars.length) {
					if (lookAhead(m4CloseComment)) {
						found = true;
						break;
					}
					offset++;
				}
				if (!found) {
					handleError(startOffset, offset, AutoconfEditorMessages.getFormattedString(UNMATCHED_CLOSE_COMMENT, 
							m4CloseComment.equals("\n") ? "newline" : m4CloseComment)); //$NON-NLS-1$
				}
				return makeToken(ITokenConstants.M4_COMMENT);
			}
			
			if (lookAhead(m4OpenQuote)) {
				return parseQuote();
			}
		}
		
		// check shell punctuation
		if (!isM4Context) {
			if (ch == ';' && offset + 1 < chars.length && chars[offset + 1] == ';') {
				offset += 2;
				return makeToken(ITokenConstants.SH_CASE_CONDITION_END);
			}
			if (ch == '<' && offset + 1 < chars.length && chars[offset + 1] == '<') {
				offset += 2;
				if (offset < chars.length && chars[offset] == '-') {
					offset++;
					return makeToken(ITokenConstants.SH_HERE_DASH);
				} else {
					return makeToken(ITokenConstants.SH_HERE);
				}
			}
			switch (ch) {
			case '$':
				offset++;
				return makeToken(ITokenConstants.SH_DOLLAR);
			case '[':
				offset++;
				return makeToken(ITokenConstants.SH_LBRACKET);
			case ']':
				offset++;
				return makeToken(ITokenConstants.SH_RBRACKET);
			case '{':
				offset++;
				return makeToken(ITokenConstants.SH_LBRACE);
			case '}':
				offset++;
				return makeToken(ITokenConstants.SH_RBRACE);
			case '\'':
				return parseString(ITokenConstants.SH_STRING_SINGLE, ch);
			case '\"':
				return parseString(ITokenConstants.SH_STRING_DOUBLE, ch);
			case '`':
				return parseString(ITokenConstants.SH_STRING_BACKTICK, ch);
			}
		}
		
		// check common punctuation
		if (ch == ';') {
			offset++;
			return makeToken(ITokenConstants.SEMI);
		}
		if (ch == ',') {
			offset++;
			return makeToken(ITokenConstants.COMMA);
		}
		if (ch == '(') {
			offset++;
			return makeToken(ITokenConstants.LPAREN);
		}
		if (ch == ')') {
			offset++;
			return makeToken(ITokenConstants.RPAREN);
		}
		
		// unknown text
		offset++;
		return makeToken(ITokenConstants.TEXT);
	}

