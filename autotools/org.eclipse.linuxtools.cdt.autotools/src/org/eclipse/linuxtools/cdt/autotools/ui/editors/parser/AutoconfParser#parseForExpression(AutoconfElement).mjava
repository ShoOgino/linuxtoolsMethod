	/**
	 * Parse through a single expression up to 'do'.
	 * Add a macro call to the element or just return upon finding the desired token.
	 * Whenever a token terminates the expression, we check its validity and then throw ExprEndCondition.
	 * Throw {@link BlockEndCondition} if an unexpected token was found.
	 * @param parent the parent into which to add statements.  The type of this element is used
	 * to validate the legality of block closing tokens.
	 */
	protected Token parseForExpression(AutoconfElement parent) throws BlockEndCondition {
		while (true) {
			Token token = tokenizer.readToken();
			
			// 0. Ignore comments (tokenizer skipped them!)
			
			// 1. Check EOF
			if (token.getType() == ITokenConstants.EOF) {
				throw new BlockEndCondition(token);
			}
		
			// 2. Check macro expansions
			else if (token.getType() == ITokenConstants.WORD) {
				token = checkMacro(parent, token);
			}
			
			// 3. Check expression terminators -- not ';' here, but 'do'
			else if (token.getType() == ITokenConstants.SH_DO) {
				tokenizer.unreadToken(token);
				return tokenizer.peekToken();
			}
			
			// 4. Abort on unexpected tokens
			else switch (token.getType()) {
			case ITokenConstants.SH_THEN:
				handleError(parent, token, AutoconfEditorMessages.getFormattedString(INVALID_SPECIFIER, token.getText()));
				tokenizer.unreadToken(token);
				// close enough...
				//throw new ExprEndCondition(token);
				return token;
				
			case ITokenConstants.SH_ESAC:
			case ITokenConstants.SH_CASE:
			case ITokenConstants.SH_CASE_CONDITION_END:
			case ITokenConstants.SH_FOR:
			case ITokenConstants.SH_IF:
			case ITokenConstants.SH_ELIF:
			case ITokenConstants.SH_ELSE:
			case ITokenConstants.SH_FI:
			case ITokenConstants.SH_DONE:
				handleError(parent, token, AutoconfEditorMessages.getFormattedString(UNTERMINATED_CONSTRUCT, parent.getName()));
				tokenizer.unreadToken(token);
				throw new BlockEndCondition(token);
			}
		}
	}

