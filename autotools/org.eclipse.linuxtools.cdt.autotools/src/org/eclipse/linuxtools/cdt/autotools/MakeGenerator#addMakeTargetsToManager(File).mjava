	/**
	 * This method parses the given Makefile and produces MakeTargets for all targets so the
	 * end-user can access them from the MakeTargets popup-menu.
	 * 
	 * @param makefileFile the Makefile to parse
	 * @throws CoreException
	 */
	private void addMakeTargetsToManager(File makefileFile) throws CoreException {
		// Ask the makefile generator to generate any makefiles needed to build delta
		checkCancel();
		if (monitor == null)
			monitor = new NullProgressMonitor();
		String statusMsg = AutotoolsPlugin.getResourceString("MakeGenerator.refresh.MakeTargets");	//$NON-NLS-1$
		monitor.subTask(statusMsg);
		
		IMakeTargetManager makeTargetManager = 
			MakeCorePlugin.getDefault().getTargetManager();
		
		IMakefile makefile = MakeCorePlugin.createMakefile(makefileFile.toURI(), false, null);
		ITargetRule[] targets = makefile.getTargetRules();
		ITarget target = null;
		Map makeTargets = new HashMap(); // use a HashMap so duplicate names are handled
		for (int i = 0; i < targets.length; i++) {
			target = targets[i].getTarget();
			String targetName = target.toString();
			if (!isValidTarget(targetName, makeTargetManager))
				continue;
			try {
				IMakeTarget makeTarget = makeTargetManager.createTarget(
						project, targetName, "org.eclipse.linuxtools.cdt.autotools.builder1"); //$NON-NLS-1$
				makeTarget.setContainer(project);
				makeTarget.setStopOnError(true);
				makeTarget.setRunAllBuilders(false);
				makeTarget.setUseDefaultBuildCmd(true);

				makeTarget.setBuildAttribute(GENERATED_TARGET, "true");
				makeTarget.setBuildAttribute(IMakeTarget.BUILD_TARGET,
						targetName);

				makeTarget.setBuildAttribute(IMakeTarget.BUILD_LOCATION,
						buildDir);
				makeTargets.put(makeTarget.getName(), makeTarget);
			} catch (CoreException e) {
				// Duplicate target.  Ignore.
			}
		}
		
		IMakeTarget[] makeTargetArray = new IMakeTarget[makeTargets.size()];
		Collection values = makeTargets.values();
		ArrayList valueList = new ArrayList(values);
		valueList.toArray(makeTargetArray);
		MakeTargetComparator compareMakeTargets = new MakeTargetComparator();
		Arrays.sort(makeTargetArray, compareMakeTargets);
		
		// At this point, we could use IMakeTargetManager to add new targets and
		// remove old ones that no longer exist.  Unfortunately, the Makefile
		// MakeTarget class is rather inefficient at this and rewrites the .cproject
		// file for every change made to the set of MakeTargets.  In our case,
		// we are better off performing the rewrite of the .cproject file ourselves
		// and then restarting the MakeTargetManager manually.  This will cause it
		// to read the .cproject file to get the MakeTargets again but there is
		// only 1 read and 1 write vs thousands of potential operations.
		// each 
		Document doc;
		try {
			doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
		} catch (ParserConfigurationException ex) {
			//This should never happen.
			throw new CoreException(new Status(IStatus.ERROR, MakeCorePlugin.getUniqueIdentifier(), -1,
					"Error creating new XML storage document", ex)); //$NON-NLS-1$
		}
		Element targetsRootElement = doc.createElement(BUILD_TARGET_ELEMENT);
		doc.appendChild(targetsRootElement);
		for (int i = 0; i < makeTargetArray.length; i++) {
			IMakeTarget t = (IMakeTarget)makeTargetArray[i];
			targetsRootElement.appendChild(createTargetElement(doc, t));
		}
		
		try {
			translateDocumentToCDTProject(doc);
		} catch (CoreException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		// To perform the shutdown and restart, we know that MakeCorePlugin's
		// MakeTargetManager has two special methods that are not exposed as
		// part of IMakeTargetManager.  We use reflection to access them and
		// avoid referencing an internal CDT class: MakeTargetManager.
		Method shutdown;
		Method startup;
		try {
			shutdown = makeTargetManager.getClass().getMethod("shutdown", null);
			startup = makeTargetManager.getClass().getMethod("startup", null);
			if (shutdown != null && startup != null) {
				shutdown.invoke(makeTargetManager, null);
				startup.invoke(makeTargetManager, null);
			}
		} catch (SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NoSuchMethodException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalArgumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvocationTargetException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

