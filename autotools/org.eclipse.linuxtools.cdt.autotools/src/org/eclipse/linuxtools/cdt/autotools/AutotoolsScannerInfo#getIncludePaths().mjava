	public String[] getIncludePaths() {
		String[] pathArray = new String[0];
		if (project == null || filePath == null)
			return pathArray;
		if (includePaths != null && !isDirty && compilationString != null) {
			return includePaths;
		}
		ArrayList<String> pathList = new ArrayList<String>();
		String cs = getCompilationString();
		if (cs != null) {
			// Grab include paths specified via -I
			Pattern p4 = Pattern.compile(" -I");
			String[] tokens = p4.split(cs);
			for (int j = 1; j < tokens.length; ++j) {
				String x = tokens[j].trim();
				int firstSpace = x.indexOf(' ');
				if (firstSpace != -1) {
					x = x.substring(0, firstSpace);
				}
				if (x.charAt(0) == '/') {
					pathList.add(x);
				} else {
					IPath relPath = new Path(dirName);
					relPath = relPath.append(x);
					pathList.add(relPath.toOSString());
				}
			}
			// Grab include paths that are specified via -isystem
			Pattern p5 = Pattern.compile(" -isystem");
			tokens = p5.split(cs);
			for (int j = 1; j < tokens.length; ++j) {
				String x = tokens[j].trim();
				int firstSpace = x.indexOf(' ');
				if (firstSpace != -1) {
					x = x.substring(0, firstSpace);
				}
				if (x.charAt(0) == '/') {
					pathList.add(x);
				} else {
					IPath relPath = new Path(dirName);
					relPath = relPath.append(x);
					pathList.add(relPath.toOSString());
				}
			}
		}
		
		// The ManagedBuildManager is the normal default IScannerInfoProvider
		// for Managed Projects.  It has the ability to check gcc for the
		// default include paths and we don't want to lose that.  Append
		// the include paths from it to the end of our list which is dynamically
		// picking up the -I options.
		
		// TODO: Should we even allow the user-defined includePaths in settings?
		//       These will be picked up by the ManagedBuildManager.
		IScannerInfo info = (IScannerInfo)ManagedBuildManager.getBuildInfo(project);
		if (info != null) {
			String[] extraIncludePaths = info.getIncludePaths();
			for (int i = 0; i < extraIncludePaths.length; ++i) {
				pathList.add(extraIncludePaths[i]);
			}
		}

		includePaths = (String[])pathList.toArray(pathArray);
		
		// FIXME: Info has been updated.  Is this the best place to notify listeners?
		Iterator<IScannerInfoChangeListener> i = listeners.iterator();
		while (i.hasNext()) {
			IScannerInfoChangeListener listener = (IScannerInfoChangeListener)i.next();
			listener.changeNotification(project, this);
		}
		return includePaths;
	}

