	/**
	 * Parse the arguments for the given macro.  These are not interpreted as shell
	 * constructs but just as text with possibly more macro expansions inside.
	 * @param macro
	 * @return final token (')')
	 */
	protected Token parseMacroArguments(AutoconfMacroElement macro, Token lparen) {
		Token argStart = null;
		Token argEnd = null;
		Token token;
		
		// When parsing, we want to ignore the whitespace around the arguments.
		// So, instead of taking the source range "between" a parenthesis and a comma,
		// track the exact tokens forming the start and end of an argument, defaulting
		// to the borders of the parentheses and commas if no text is included.
		
		StringBuffer argBuffer = new StringBuffer();
		AutoconfMacroArgumentElement arg = new AutoconfMacroArgumentElement();

		while (true) {
			token = tokenizer.readToken();
			
			if (token.getType() == ITokenConstants.EOL) {
				if (argBuffer.length() > 0)
					argBuffer.append(token.getText());
				continue;
			}
			
			if (token.getType() == ITokenConstants.COMMA 
					|| token.getType() == ITokenConstants.RPAREN
					|| token.getType() == ITokenConstants.EOF) {

				arg.setName(argBuffer.toString());
				argBuffer.setLength(0);
				
				if (argStart != null && argEnd != null) {
					setSourceStart(arg, argStart);
					setSourceEnd(arg, argEnd);
				} else if (argEnd != null) {
					setSourceStart(arg, argStart);
					setSourceEndBefore(arg, token);
				} else {
					// empty argument
					setSourceStart(arg, token);
					setSourceEndBefore(arg, token);
				}
				
				macro.addChild(arg);
				
				if (token.getType() != ITokenConstants.COMMA)
					break;
				
				argStart = null;
				argEnd = null;
				
				arg = new AutoconfMacroArgumentElement();

			} else {
				if (argStart == null) {
					argStart = token;
				}
				argEnd = token;
				
				if (argBuffer.length() > 0 && token.followsSpace())
					argBuffer.append(' ');
				argBuffer.append(token.getText());
				
				// handle nested macro calls in arguments
				if (token.getType() == ITokenConstants.WORD) {
					argEnd = checkMacro(arg, token);
				}
			}
		}
		
		if (token.getType() != ITokenConstants.RPAREN) {
			handleError(macro, token, AutoconfEditorMessages.getString(UNMATCHED_LEFT_PARENTHESIS)); 
		}
		
		// note: moved 15-char truncation to AutoconfLabelProvider
		AutoconfElement[] children = macro.getChildren();
		if (children.length > 0)
			macro.setVar(children[0].getVar());
		
		return token;
	}

