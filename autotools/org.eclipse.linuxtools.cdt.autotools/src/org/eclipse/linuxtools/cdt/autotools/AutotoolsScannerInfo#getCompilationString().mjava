	private String getCompilationString() {
		if (compilationString != null && !isDirty)
			return compilationString;
		String makeWEnabled = null;
		try {
			makeWEnabled = project.getPersistentProperty(AutotoolsPropertyConstants.SCANNER_USE_MAKE_W);
		} catch (CoreException e) {
			// do nothing
		}
		if (!(res instanceof IFile) ||
				makeWEnabled == null ||
				makeWEnabled.equals("false")) // $NON-NLS-1$
			return null;
		isDirty = false;
		IWorkspaceRoot root = CCorePlugin.getWorkspace().getRoot();
		IFile file = root.getFile(filePath);
		IFile makefile = null;
		IManagedBuildInfo info = ManagedBuildManager.getBuildInfo(project);
		// If the given file exists and we have a ManagedBuild, we may have
		// an Autotools project source file.
		if (file != null && file.exists() && info != null) {
			makefile = getMakefile(info, filePath);
		}
		// We now have the closest directory to the given path
		// that contains a Makefile.in or Makefile.  This Makefile
		// should contain a relative reference to the file in
		// question.  We now want to try and extract the include
		// path from the top-level make run with the assumption
		// that the file in question has been altered.
		if (makefile != null) {
			IPath dir = makefile.getFullPath().removeLastSegments(1);
			// Get relative name of file as we assume the Makefile will
			// refer to it this way.
			String out = buildFile(filePath, makefile, info);
			try {
				boolean topLevel = dir.equals(project.getFullPath());
				Pattern p = null;
				Matcher m = null;
				if (!topLevel) {
					String regex1 = "^Making.*in.*" + dir.lastSegment(); // $NON-NLS-1$
					p = Pattern.compile(regex1, Pattern.MULTILINE);
					m = p.matcher(out);
				}
				if (topLevel || m.find()) {
					Pattern p2 = null;
					Matcher m2 = null;
					String substr2 = out;
					if (!topLevel) {
						substr2 = out.substring(m.end());
						String regex2 = "^make.*Entering directory.*`(.*)'"; // $NON-NLS-1$
						p2 = Pattern.compile(regex2, Pattern.MULTILINE);
						m2 = p2.matcher(substr2);
					}
					if (topLevel || m2.find()) {
						String substr3 = null;
						if (!topLevel) {
							dirName = m2.group(1);
							substr3 = substr2.substring(m2.start());
						} else {
							dirName = "";
							substr3 = out;
						}
						// We need to test for both gcc and g++ compilers.
						String regex3 = "^.*gcc.*?-I.*?" + filePath.lastSegment(); // $NON-NLS-1$
						String regex4 = "^.*g[+][+].*?-I.*?" + filePath.lastSegment(); // $NON-NLS-1$
						// Replace all continuation markers so we don't have to worry about newlines in
						// the middle of a compilation string.
						substr3 = substr3.replaceAll("\\\\\\n", "");
						Pattern p3 = Pattern.compile(regex3, Pattern.MULTILINE);
						Matcher m3 = p3.matcher(substr3);
						if (m3.find())
							compilationString = substr3.substring(m3.start(),m3.end());
						else {
							String substr4 = substr3;
							Pattern p4 = Pattern.compile(regex4, Pattern.MULTILINE);
							Matcher m4 = p4.matcher(substr4);
							if (m4.find())
								compilationString = substr3.substring(m4.start(),m4.end());
						}
					}
				} else if (!out.equals("")) {
					compilationString = "";
				}
			} catch (IllegalStateException t) {
				// Mark as dirty for next time.
				isDirty = true;
			}
		}
		return compilationString;
	}

