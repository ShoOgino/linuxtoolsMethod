	private String getCompilationString() {
		if (compilationString != null && !isDirty)
			return compilationString;
		String makeWEnabled = null;
		try {
			makeWEnabled = project.getPersistentProperty(AutotoolsPropertyConstants.SCANNER_USE_MAKE_W);
		} catch (CoreException e) {
			// do nothing
		}
		if (!(res instanceof IFile) ||
				makeWEnabled == null ||
				makeWEnabled.equals("false")) // $NON-NLS-1$
			return null;
		isDirty = false;
		IWorkspaceRoot root = CCorePlugin.getWorkspace().getRoot();
		IFile file = root.getFile(filePath);
		IFile makefile = null;
		IManagedBuildInfo info = ManagedBuildManager.getBuildInfo(project);
		// If the given file exists and we have a ManagedBuild, we may have
		// an Autotools project source file.
		if (file != null && file.exists() && info != null) {
			makefile = getMakefile(info, filePath);
		}
		// We now have the closest directory to the given path
		// that contains a Makefile.in or Makefile.  This Makefile
		// should contain a relative reference to the file in
		// question.  We now want to try and extract the include
		// path from the top-level make run with the assumption
		// that the file in question has been altered.
		if (makefile != null) {
			IPath dir = makefile.getFullPath().removeLastSegments(1);
			// Get relative name of file as we assume the Makefile will
			// refer to it this way.
			String out = buildFile(filePath, makefile, info);
			try {
				String regex1 = "^Making.*in.*" + dir.lastSegment(); // $NON-NLS-1$
				Pattern p = Pattern.compile(regex1, Pattern.MULTILINE);
				Matcher m = p.matcher(out);
				if (m.find()) {
					String substr2 = out.substring(m.end());
					String regex2 = "^make.*Entering directory.*`(.*)'"; // $NON-NLS-1$
					Pattern p2 = Pattern.compile(regex2, Pattern.MULTILINE);
					Matcher m2 = p2.matcher(substr2);
					if (m2.find()) {
						dirName = m2.group(1);
						String substr3 = substr2.substring(m2.start());
						String regex3 = "^.*gcc.*-I.*" + filePath.lastSegment(); // $NON-NLS-1$
						Pattern p3 = Pattern.compile(regex3, Pattern.MULTILINE);
						Matcher m3 = p3.matcher(substr3);
						if (m3.find())
							compilationString = substr3.substring(m3.start(),m3.end());
					}
				} else if (!out.equals("")) {
					compilationString = "";
				}
			} catch (IllegalStateException t) {
				// Mark as dirty for next time.
				isDirty = true;
			}
		}
		return compilationString;
	}

