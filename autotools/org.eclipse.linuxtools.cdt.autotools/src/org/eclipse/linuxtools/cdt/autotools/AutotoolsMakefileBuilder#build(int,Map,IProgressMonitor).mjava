	/* (non-Javadoc)
	 * @see org.eclipse.core.internal.events.InternalBuilder#build(int, java.util.Map, org.eclipse.core.runtime.IProgressMonitor)
	 */
	protected IProject[] build(int kind, Map args, IProgressMonitor monitor) throws CoreException {
		IProject[] results = null;
		IProject project = getProject();
		IManagedBuildInfo info = ManagedBuildManager.getBuildInfo(project);
		IManagedBuilderMakefileGenerator generator = null;
		try {
			// Figure out the working directory for the build and make sure there is a makefile there
			// If not, mark a rebuild is required so that configuration will get
			// invoked.
			IWorkspace workspace = project.getWorkspace();
			if (workspace != null) {
				IWorkspaceRoot root = workspace.getRoot();
				if (root != null) {
					if (info.getDefaultConfiguration() == null)
						return null;
					generator = ManagedBuildManager.getBuildfileGenerator(info.getDefaultConfiguration());
					generator.initialize(getProject(), info, monitor);
					IPath buildDir = project.getLocation().append(generator.getBuildWorkingDir());
					IPath makefilePath = buildDir.append(generator.getMakefileName());
					IFile makefile = root.getFileForLocation(makefilePath);
					if (makefile == null || !makefile.exists()) {
						info.setRebuildState(true);
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			makeTargetName = (String)args.get("org.eclipse.cdt.make.core.build.target.inc"); //$NON-NLS-1$
			
			buildCalled = true;
			/**
			 * @see IncrementalProjectBuilder#build
			 */
//			fBuildSet.start(this);

			// Hijack the build.  This is because the CommonBuilder code will
			// try and create builders for a MakeTarget build.  We don't want
			// that because this will default to using the GnuMakefileGenerator
			// which fails.  We want to use our Autotools MakeGenerator and
			// perform a make from the top-level.
			if(VERBOSE)
				outputTrace(project.getName(), ">>build requested, type = " + kind); //$NON-NLS-1$
			IConfiguration cfg = info.getDefaultConfiguration();

			// Assemble the information needed to generate the targets
			String errMsg;
			String prebuildStep = cfg.getPrebuildStep();
			try{
				//try to resolve the build macros in the prebuild step
				prebuildStep = ManagedBuildManager.getBuildMacroProvider().resolveValueToMakefileFormat(
						prebuildStep,
						EMPTY_STRING,
						WHITESPACE,
						IBuildMacroProvider.CONTEXT_CONFIGURATION,
						cfg);
			} catch (BuildMacroException e){
			}
			prebuildStep = prebuildStep.trim(); // Remove leading and trailing whitespace (and control characters)

			String postbuildStep = cfg.getPostbuildStep();
			try{
				//try to resolve the build macros in the postbuild step
				postbuildStep = ManagedBuildManager.getBuildMacroProvider().resolveValueToMakefileFormat(
						postbuildStep,
						EMPTY_STRING,
						WHITESPACE,
						IBuildMacroProvider.CONTEXT_CONFIGURATION,
						cfg);
					
			} catch (BuildMacroException e){
			}
			postbuildStep = postbuildStep.trim(); // Remove leading and trailing whitespace (and control characters)
			String preannouncebuildStep = cfg.getPreannouncebuildStep();
			String postannouncebuildStep = cfg.getPostannouncebuildStep();

			IConsole console = null;
			ConsoleOutputStream consoleOutStream = null;
			CommandLauncher launcher = null;
			String[] env = null;
			Process proc = null;
			OutputStream stdout = null;
			OutputStream stderr = null;
			
			// If we have a prebuild or postbuild step, set up a command launcher to use.
			if (!prebuildStep.equals("") || !postbuildStep.equals("")) {
				console = CCorePlugin.getDefault().getConsole("org.eclipse.linuxtools.cdt.autotools.buildStepsConsole"); // $NON-NLS-1$
				console.start(project);
				consoleOutStream = console.getOutputStream();
				stdout = consoleOutStream;
				stderr = consoleOutStream;
				launcher = new CommandLauncher();
				// Set the environment
				IEnvironmentVariable variables[] = ManagedBuildManager
						.getEnvironmentVariableProvider().getVariables(cfg, true);
				ArrayList envList = new ArrayList();
				if (variables != null) {
					for (int i = 0; i < variables.length; i++) {
						envList.add(variables[i].getName()
								+ "=" + variables[i].getValue()); //$NON-NLS-1$
					}
					env = (String[]) envList.toArray(new String[envList.size()]);
				}
			}
			
			// Check for a prebuild step and execute it if it exists.
			if (!prebuildStep.equals("")) {
				monitor.subTask(preannouncebuildStep);

				StringBuffer buffer = new StringBuffer();
				buffer.append(preannouncebuildStep);
				buffer.append(System.getProperty("line.separator", "\n")); // $NON-NLS-1$ // $NON-NLS-2$

				try {
					consoleOutStream.write(buffer.toString().getBytes());
					consoleOutStream.flush();
				} catch (IOException e) {
					// do nothing
				}

				launcher.showCommand(true);
				String[] tmp = prebuildStep.split("\\s");
				String[] cmdargs = new String[tmp.length - 1];
				if (tmp.length > 1)
					System.arraycopy(tmp, 1, cmdargs, 0, tmp.length - 1);
				proc = launcher.execute(new Path(tmp[0]), cmdargs, env,
						project.getLocation().append(generator.getBuildWorkingDir()));
				if (proc != null) {
					try {
						// Close the input of the process since we will never write to
						// it
						proc.getOutputStream().close();
					} catch (IOException e) {
					}

					if (launcher.waitAndRead(stdout, stderr, new SubProgressMonitor(
							monitor, IProgressMonitor.UNKNOWN)) != CommandLauncher.OK) {
						errMsg = launcher.getErrorMessage();
					}
				}
			}

			// Perform build
			
			IBuilder builders[] = new IBuilder[1];
			// Hijack the builder itself so that instead of ManagedMake
			// policy of defaulting the build path to the configuration name,
			// we get the build occurring in the builddir configure tool setting.
			builders[0] = new AutotoolsBuilder(cfg.getEditableBuilder(), project);
			String buildLocation = null;
			String buildCommand = null;
			if (makeTargetName != null) {
				buildLocation = (String)args.get("org.eclipse.cdt.make.core.build.location"); // $NON-NLS-1$
				buildCommand = (String)args.get("org.eclipse.cdt.make.core.build.command"); // $NON-NLS-1$
			}
			if (buildLocation == null)
				builders[0].setBuildPath(project.getLocation().append(generator.getBuildWorkingDir()).toOSString());
			else {
				IWorkspace workspace = project.getWorkspace();
				builders[0].setBuildPath(workspace.getRoot().getLocation().append(buildLocation).toOSString());
			}
			if (buildCommand != null)
				builders[0].setBuildCommand(new Path(buildCommand));
			builders[0].setAutoBuildEnable(true);
			builders[0].setCleanBuildEnable(true);
			IProject[] projects = build(kind, project, builders, true, monitor);

			if(VERBOSE)
				outputTrace(project.getName(), "<<done build requested, type = " + kind); //$NON-NLS-1$

			results = projects;
			buildCalled = false;
			
			// Check for a postbuild step and execute it if it exists.
			if (!postbuildStep.equals("")) {
				monitor.subTask(postannouncebuildStep);
				StringBuffer buffer = new StringBuffer();
				buffer.append(postannouncebuildStep);
				buffer.append(System.getProperty("line.separator", "\n")); // $NON-NLS-1$ // $NON-NLS-2$

				try {
					consoleOutStream.write(buffer.toString().getBytes());
					consoleOutStream.flush();
				} catch (IOException e) {
					// do nothing
				}
				String[] tmp = postbuildStep.split("\\s");
				String[] cmdargs = new String[tmp.length - 1];
				if (tmp.length > 1)
					System.arraycopy(tmp, 1, cmdargs, 0, tmp.length - 1);
				proc = launcher.execute(new Path(tmp[0]), cmdargs, env,
						project.getLocation().append(generator.getBuildWorkingDir()));
				if (proc != null) {
					try {
						// Close the input of the process since we will never write to
						// it
						proc.getOutputStream().close();
					} catch (IOException e) {
					}

					if (launcher.waitAndRead(stdout, stderr, new SubProgressMonitor(
							monitor, IProgressMonitor.UNKNOWN)) != CommandLauncher.OK) {
						errMsg = launcher.getErrorMessage();
					}
				}
			}

		}
		return results;
	}

