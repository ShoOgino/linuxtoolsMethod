	public IToken evaluate(ICharacterScanner scanner, boolean resume) {
		int column = scanner.getColumn();
		// Check if we are at EOF, in which case rules don't hold
		if (column < 0)
			return Token.UNDEFINED;
		if (!resume) {
			evalIndex = 0;
			// Check if we are within outer rule boundaries.
			if (column >= endIndex || column < startIndex) {
				// If not, then we should evaluate to see if the
				// outer rule is true starting at the current position.
				startIndex = scanner.getColumn();
				if (super.evaluate(scanner, false) != Token.UNDEFINED) {
					// Outer rule is true for a section.  Now we can
					// set the boundaries for the internal rules.
					// End boundary for internal rules is the start of
					// the end sequence.
					endIndex = scanner.getColumn();
					endBoundary = endIndex - endSequence.length();
					// Back up scanner to just after start sequence.
					backupScanner(scanner, startIndex + startSequence.length());
					return super.getSuccessToken();
				}
				else
					// Outer rule doesn't hold.
					return Token.UNDEFINED;
			}
		}

		// At this point, we want to subdivide up the area covered by the
		// outer rule into success tokens for internal areas separated by
		// areas of the outer rule.
		
		int start = scanner.getColumn();
		column = start;
		while (column < endBoundary) {
			while (evalIndex < rules.size()) {
				SingleLineRule x = (SingleLineRule)rules.get(evalIndex);
				IToken token = x.evaluate(scanner, false);
				if (!token.isUndefined()) {
					// Found internal token.  If we had to read to get
					// to the start of the internal token, then back up
					// the scanner to the start of the internal token and
					// return the initial read area as part of an outer token.
					// Otherwise, return the internal token.
					if (column == start) {
						evalIndex = 0;
						return token;
					} else {
						backupScanner(scanner, column);
						return super.getSuccessToken();
					}
				}
				++evalIndex;
			}
			evalIndex = 0;
			scanner.read();
			++column;
		}
		
		// Outside internal area.  Read until end of outer area and return
		// outer token.
		while (column++ < endIndex)
			scanner.read();
		startIndex = 0;
		endIndex = 0;
		return super.getSuccessToken();
	}

