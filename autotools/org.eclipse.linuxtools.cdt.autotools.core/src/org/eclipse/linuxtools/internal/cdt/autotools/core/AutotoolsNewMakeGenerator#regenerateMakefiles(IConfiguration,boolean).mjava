	private Status regenerateMakefiles(IConfiguration icfg, boolean reconfigure) throws CoreException {
		Status status;
		int rc = IStatus.OK;
		String errMsg = new String();
		boolean needFullConfigure = false;

		// See if the user has cancelled the build
		checkCancel();

		// Synchronize the Autotools configurations with the Project Description
		AutotoolsConfigurationManager.getInstance().syncConfigurations(getProject());	
		toolsCfg = AutotoolsConfigurationManager.getInstance().getConfiguration(getProject(), icfg.getName());
			
		initializeBuildConfigDirs(icfg, toolsCfg);
		// Create the top-level directory for the build output
		if (!createDirectory(buildDir)) {
			rc = IStatus.ERROR;
			errMsg = AutotoolsPlugin.getFormattedString("MakeGenerator.createdir.error", //$NON-NLS-1$
					new String[] {buildDir});
			status = new MultiStatus(AutotoolsPlugin
						.getUniqueIdentifier(), rc, errMsg, null);
		}
		checkCancel();

		// // How did we do
		// if (!getInvalidDirList().isEmpty()) {
		// status = new MultiStatus (
		// ManagedBuilderCorePlugin.getUniqueIdentifier(),
		// IStatus.WARNING,
		// new String(),
		// null);
		// // Add a new status for each of the bad folders
		// iter = getInvalidDirList().iterator();
		// while (iter.hasNext()) {
		// status.add(new Status (
		// IStatus.WARNING,
		// ManagedBuilderCorePlugin.getUniqueIdentifier(),
		// SPACES_IN_PATH,
		// ((IContainer)iter.next()).getFullPath().toString(),
		// null));
		// }
		// } else {
		// status = new MultiStatus(
		// ManagedBuilderCorePlugin.getUniqueIdentifier(),
		// IStatus.OK,
		// new String(),
		// null);
		// }

		// Get a build console for the project
		IConsole console = CCorePlugin.getDefault().getConsole("org.eclipse.linuxtools.cdt.autotools.ui.configureConsole"); //$NON-NLS-1$
		boolean consoleStart = true;
		
		// Make sure there's a monitor to cancel the build
		if (monitor == null) {
			monitor = new NullProgressMonitor();
		}

		try {
			// If a config.status file exists in the build directory, we call it
			// to
			// regenerate the makefile
			IPath configfile = buildLocation.append(CONFIG_STATUS);
			IPath topConfigFile = project.getLocation().append(CONFIG_STATUS);
			IPath makefilePath = buildLocation.append(MAKEFILE);
			IPath topMakefilePath = project.getLocation().append(MAKEFILE);
			File configStatus = configfile.toFile();
			File topConfigStatus = topConfigFile.toFile();
			File makefile = makefilePath.toFile();
			File topMakefile = topMakefilePath.toFile();

			// Check if a configure has been done in the top-level source directory
			if (!(configfile.equals(topConfigFile)) && topConfigStatus.exists()) {
				// Must perform distclean on source directory because 2nd configuration
				// cannot occur otherwise
				// There is a make target for cleaning.
				if (topMakefile != null && topMakefile.exists()) {
					String[] makeargs = new String[1];
					IPath makeCmd = new Path("make"); //$NON-NLS-1$
					String target = null;
					try {
						target = getProject().getPersistentProperty(AutotoolsPropertyConstants.CLEAN_MAKE_TARGET);
					} catch (CoreException ce) {
						// do nothing
					}
					if (target == null)
						target = AutotoolsPropertyConstants.CLEAN_MAKE_TARGET_DEFAULT;
					String args = builder.getBuildArguments();
					if (args != null && !(args = args.trim()).equals("")) { //$NON-NLS-1$
						String[] newArgs = makeArray(args);
						makeargs = new String[newArgs.length + 1];
						System.arraycopy(newArgs, 0, makeargs, 0, newArgs.length);
					}
					makeargs[makeargs.length - 1] = target;
					rc = runCommand(makeCmd,
							project.getLocation(),
							makeargs,
							AutotoolsPlugin.getResourceString("MakeGenerator.clean.topdir"), //$NON-NLS-1$
							errMsg, console, consoleStart);
					consoleStart = false;
				}
			}
			// If the active configuration is dirty, then we need to do a full
			// reconfigure.
			if (toolsCfg.isDirty() || reconfigure) {
				needFullConfigure = true;
				// If we are going to do a full reconfigure, then if the current
				// build directory exists, we should clean it out first.  This is
				// because the reconfiguration could change compile flags, etc..
				// and the Makefile might not detect a rebuild is required.  In
				// addition, the build directory itself could have been changed and
				// we should remove the previous build.
				if (buildLocation != null && buildLocation.toFile().exists()) {
					// See what type of cleaning the user has set up in the
					// build properties dialog.
					String cleanDelete = null;
					try {
						cleanDelete = getProject().getPersistentProperty(AutotoolsPropertyConstants.CLEAN_DELETE);
					} catch (CoreException ce) {
						// do nothing
					}
					
					if (cleanDelete != null && cleanDelete.equals(AutotoolsPropertyConstants.TRUE))
						buildLocation.toFile().delete();
					else {
						// There is a make target for cleaning.
						if (makefile != null && makefile.exists()) {
							String[] makeargs = new String[1];
							IPath makeCmd = new Path("make"); //$NON-NLS-1$
							String target = null;
							try {
								target = getProject().getPersistentProperty(AutotoolsPropertyConstants.CLEAN_MAKE_TARGET);
							} catch (CoreException ce) {
								// do nothing
							}
							if (target == null)
								target = AutotoolsPropertyConstants.CLEAN_MAKE_TARGET_DEFAULT;
							String args = builder.getBuildArguments();
							if (args != null && !(args = args.trim()).equals("")) { //$NON-NLS-1$
								String[] newArgs = makeArray(args);
								makeargs = new String[newArgs.length + 1];
								System.arraycopy(newArgs, 0, makeargs, 0, newArgs.length);
							}
							makeargs[makeargs.length - 1] = target;
							rc = runCommand(makeCmd,
									buildLocation,
									makeargs,
									AutotoolsPlugin.getFormattedString("MakeGenerator.clean.builddir", new String[]{buildDir}), //$NON-NLS-1$
									errMsg, console, consoleStart);
							consoleStart = false;
						}
					}
				}
				// Mark the scanner info as dirty.
				try {
					project.setSessionProperty(AutotoolsPropertyConstants.SCANNER_INFO_DIRTY, Boolean.TRUE);
				} catch (CoreException ce) {
					// do nothing
				}
			}
			
			ArrayList<String> configureEnvs = new ArrayList<String>();
			ArrayList<String> configureCmdParms = new ArrayList<String>();
			IPath configurePath = getConfigurePath(configureEnvs, configureCmdParms);
			String[] configArgs = getConfigArgs(configureCmdParms);
			ArrayList<String> autogenEnvs = new ArrayList<String>();
			ArrayList<String> autogenCmdParms = new ArrayList<String>();
			IPath autogenPath = getAutogenPath(autogenEnvs, autogenCmdParms);
			
			// Check if we have a config.status (meaning configure has already run).
    		if (!needFullConfigure && configStatus != null && configStatus.exists()) {
			    // If no corresponding Makefile in the same build location, then we
	            // can simply run config.status again to ensure the top level Makefile has been
				// created.
				if (makefile == null || !makefile.exists()) {
					rc = runScript(configfile, buildLocation, null, 
							AutotoolsPlugin.getFormattedString("MakeGenerator.run.config.status", new String[]{buildDir}), //$NON-NLS-1$
							errMsg, console, null, consoleStart);
					consoleStart = false;
				}
			}
			// Look for configure and configure from scratch
			else if (configurePath.toFile().exists()) {
				rc = runScript(configurePath, 
						buildLocation,
						configArgs, 
						AutotoolsPlugin.getFormattedString("MakeGenerator.gen.makefile", new String[]{buildDir}), //$NON-NLS-1$
						errMsg, console, configureEnvs, consoleStart);
				consoleStart = false;
				if (rc != IStatus.ERROR) {
					File makefileFile = buildLocation.append(MAKEFILE).toFile();
					addMakeTargetsToManager(makefileFile);
					// TODO: should we do something special if configure doesn't
					// return ok?
					toolsCfg.setDirty(false);
				}
			}
			// If no configure, look for autogen.sh which may create configure and
    		// possibly even run it.
			else if (autogenPath.toFile().exists()) {
				// Remove the existing config.status file since we use it
				// to figure out if configure was run.
				if (configStatus.exists())
					configStatus.delete();
				// Get any user-specified arguments for autogen.
				String[] autogenArgs = getAutogenArgs(autogenCmdParms);
				rc = runScript(autogenPath,
						autogenPath.removeLastSegments(1), autogenArgs,
						AutotoolsPlugin.getFormattedString("MakeGenerator.autogen.sh", new String[]{buildDir}), //$NON-NLS-1$
						errMsg, console, autogenEnvs, consoleStart);
				consoleStart = false;
				if (rc != IStatus.ERROR) {
					configStatus = configfile.toFile();
					// Check for config.status.  If it is created, then
					// autogen.sh ran configure and we should not run it
					// ourselves.
					if (configStatus == null || !configStatus.exists()) {
						rc = runScript(configurePath, 
								buildLocation,
								configArgs, 
								AutotoolsPlugin.getFormattedString("MakeGenerator.gen.makefile", new String[]{buildDir}), //$NON-NLS-1$
								errMsg, console, configureEnvs, false);
						if (rc != IStatus.ERROR) {
							File makefileFile = buildLocation.append(MAKEFILE).toFile();
							addMakeTargetsToManager(makefileFile);
							toolsCfg.setDirty(false);
						}
					} else {
						File makefileFile = buildLocation.append(MAKEFILE).toFile();
						addMakeTargetsToManager(makefileFile);
						toolsCfg.setDirty(false);
					}
				}
			}
			// If nothing this far, look for a Makefile.cvs file which needs to be run. 
			else if (makefileCvsExists()) {
				String[] makeargs = new String[1];
				IPath makeCmd = new Path("make"); //$NON-NLS-1$
				makeargs[0] = "-f" + getMakefileCVSPath().toOSString(); //$NON-NLS-1$
				rc = runCommand(makeCmd,
						project.getLocation().append(buildDir),
						makeargs,
						AutotoolsPlugin.getFormattedString("MakeGenerator.makefile.cvs", new String[]{buildDir}), //$NON-NLS-1$
						errMsg, console, consoleStart);
				consoleStart = false;
				if (rc != IStatus.ERROR) {
					File makefileFile = project.getLocation().append(buildDir)
					.append(MAKEFILE).toFile();
					addMakeTargetsToManager(makefileFile);
					toolsCfg.setDirty(false);
				}
			}
			// If nothing this far, try running autoreconf -i
			else {
				String[] reconfArgs = new String[1];
				String reconfCmd = project.getPersistentProperty(AutotoolsPropertyConstants.AUTORECONF_TOOL);
				if (reconfCmd == null)
					reconfCmd = DEFAULT_AUTORECONF;
				IPath reconfCmdPath = new Path(reconfCmd);
				reconfArgs[0] = "-i"; //$NON-NLS-1$
				rc = runCommand(reconfCmdPath,
						project.getLocation().append(srcDir),
						reconfArgs,
						AutotoolsPlugin.getFormattedString("MakeGenerator.autoreconf", new String[]{buildDir}), //$NON-NLS-1$
						errMsg, console, consoleStart);
				consoleStart = false;
				// Check if configure generated and if yes, run it.
				if (rc != IStatus.ERROR) {
					if (configurePath.toFile().exists()) {
						rc = runScript(configurePath, 
								buildLocation,
								configArgs, 
								AutotoolsPlugin.getFormattedString("MakeGenerator.gen.makefile", new String[]{buildDir}), //$NON-NLS-1$
								errMsg, console, configureEnvs, false);
						if (rc != IStatus.ERROR) {
							File makefileFile = buildLocation.append(MAKEFILE).toFile();
							addMakeTargetsToManager(makefileFile);
							// TODO: should we do something special if configure doesn't
							// return ok?
							toolsCfg.setDirty(false);
						}
					}
				}
			}
    		// If we didn't create a Makefile, consider that an error.
			if (makefile == null || !makefile.exists()) {
				rc = IStatus.ERROR;
				errMsg = AutotoolsPlugin.getResourceString("MakeGenerator.didnt.generate"); //$NON-NLS-1$
			}
		} catch (Exception e) {
			e.printStackTrace();
			// forgetLastBuiltState();
			rc = IStatus.ERROR;
		} finally {
			// getGenerationProblems().clear();
			status = new MultiStatus(AutotoolsPlugin
						.getUniqueIdentifier(), rc, errMsg, null);
		}
		return status;
	}

