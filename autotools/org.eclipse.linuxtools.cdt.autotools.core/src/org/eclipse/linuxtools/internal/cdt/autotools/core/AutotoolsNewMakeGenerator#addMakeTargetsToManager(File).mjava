	/**
	 * This method parses the given Makefile and produces MakeTargets for all targets so the
	 * end-user can access them from the MakeTargets popup-menu.
	 * 
	 * @param makefileFile the Makefile to parse
	 * @throws CoreException
	 */
	private void addMakeTargetsToManager(File makefileFile) throws CoreException {
		// We don't bother if the Makefile wasn't created.
		if (makefileFile == null || !makefileFile.exists())
			return;
		
		checkCancel();
		if (monitor == null)
			monitor = new NullProgressMonitor();
		String statusMsg = AutotoolsPlugin.getResourceString("MakeGenerator.refresh.MakeTargets");	//$NON-NLS-1$
		monitor.subTask(statusMsg);
		
		IMakeTargetManager makeTargetManager = 
			MakeCorePlugin.getDefault().getTargetManager();
		
		IMakefile makefile = MakeCorePlugin.createMakefile(makefileFile.toURI(), false, null);
		ITargetRule[] targets = makefile.getTargetRules();
		ITarget target = null;
		Map<String, IMakeTarget> makeTargets = new HashMap<String, IMakeTarget>(); // use a HashMap so duplicate names are handled
		String[] id = makeTargetManager.getTargetBuilders(getProject());
		if (id.length == 0) {
			return;
		}
		String targetBuildID = id[0];
		IMakeBuilderInfo buildInfo = MakeCorePlugin.createBuildInfo(getProject(),
				makeTargetManager.getBuilderID(targetBuildID));
		boolean isStopOnError = buildInfo.isStopOnError();
		IPath buildCommand = buildInfo.getBuildCommand();
		String defaultBuildCommand = buildCommand.toString();
		String buildArguments = buildInfo.getBuildArguments();
		
		// Bug #351660 - reset targets to a single dummy target so that
		// we will never be able to find any of the new targets we are about to
		// create and thus avoid an extraneous event notification on a change to
		// the MakeTarget.  The dummy target should have an invalid name for
		// a normal make target.
		IMakeTarget dummyTarget = makeTargetManager.createTarget(
				project, "\ndummyTarget\n", targetBuildID); //$NON-NLS-1$
		makeTargetManager.setTargets(project, new IMakeTarget[]{dummyTarget});
		
		for (int i = 0; i < targets.length; i++) {
			target = targets[i].getTarget();
			String targetName = target.toString();
			if (!isValidTarget(targetName, makeTargetManager))
				continue;
			try {
				// Bug #351660 - always create a new MakeTarget because an
				// existing MakeTarget will cause events to occur on every
				// modification whereas a new MakeTarget not yet added will
				// not cause this delay.
				IMakeTarget makeTarget = makeTargetManager.createTarget(
								project, targetName, targetBuildID);
				makeTarget.setContainer(project);
				makeTarget.setStopOnError(isStopOnError);
				makeTarget.setRunAllBuilders(false);
				makeTarget.setUseDefaultBuildCmd(true);
				makeTarget.setBuildAttribute(IMakeTarget.BUILD_ARGUMENTS, buildArguments);
				makeTarget.setBuildAttribute(IMakeTarget.BUILD_COMMAND, defaultBuildCommand);

				makeTarget.setBuildAttribute(GENERATED_TARGET, "true"); //$NON-NLS-1$
				makeTarget.setBuildAttribute(IMakeTarget.BUILD_TARGET,
						targetName);

				//TODO: should this be raw build directory in macro form?
				makeTarget.setBuildAttribute(IMakeTarget.BUILD_LOCATION,
						buildDir);
				makeTargets.put(makeTarget.getName(), makeTarget);
			} catch (CoreException e) {
				// Duplicate target.  Ignore.
			}
		}
		
		IMakeTarget[] makeTargetArray = new IMakeTarget[makeTargets.size()];
		Collection<IMakeTarget> values = makeTargets.values();
		ArrayList<IMakeTarget> valueList = new ArrayList<IMakeTarget>(values);
		valueList.toArray(makeTargetArray);
		MakeTargetComparator compareMakeTargets = new MakeTargetComparator();
		Arrays.sort(makeTargetArray, compareMakeTargets);

		// Check if we have MakeTargetManager patch which adds the ability
		// to save multiple targets at once.  If yes, use it as it updates
		// the MakeTargets now.  Otherwise, fall back to old method which
		// saves the targets externally..requiring closing the project and
		// reopening to see them.
		Class<? extends IMakeTargetManager> c = makeTargetManager.getClass();
		boolean targetsAdded = false;
		try {
			Method m = c.getMethod("setTargets", IContainer.class, IMakeTarget[].class);
			m.invoke(makeTargetManager, project, makeTargetArray);
			targetsAdded = true;
		} catch (NoSuchMethodException e) {
			// ignore and use fail-safe saveTargets method
		} catch (IllegalArgumentException e) {
			// ignore and use fail-safe saveTargets method
		} catch (IllegalAccessException e) {
			// ignore and use fail-safe saveTargets method
		} catch (InvocationTargetException e) {
			// ignore and use fail-safe saveTargets method
		}
		if (!targetsAdded)
			saveTargets(makeTargetArray);
	}

