	/**
	 * Get a mapping between a file name, and the data relevant to locating
	 * the corresponding function name for a given project.
	 * 
	 * @param project : C Project Type
	 * @param functionName : Name of a function 
	 * @param fileHint : The name of the file where we expect to find functionName.
	 * It is null if we do not want to use this option.
	 * @return a HashMap<String, int []> of String absolute paths of files and the
	 * function's corresponding node-offset and length.
	 */
	private static HashMap<String,int[]> findFunctionsInProject(ICProject project, String functionName, String fileHint)  {
		  HashMap<String,int[]> files = new HashMap<String,int[]>() ;
		  int numOfArgs = 0;
		  
		  // detect function with arguments and narrow search accordingly
		  if (functionName.matches(".*\\(.*\\)")){
			  int start = functionName.indexOf('(');
			  if (functionName.contains(",")){
				  int end = functionName.indexOf(')');
				  numOfArgs = functionName.substring(start, end).split(",").length;
			  }else{
				  numOfArgs = 1;
			  }
			  functionName = functionName.substring(0, start);
		  }

		  IIndexManager manager = CCorePlugin.getIndexManager();
		  IIndex index = null;
		    try {
				index = manager.getIndex(project);
				index.acquireReadLock();
				IBinding[] bindings = index.findBindings(functionName.toCharArray(), IndexFilter.ALL, null);
				for (IBinding bind : bindings) {
					if (bind instanceof IFunction && (((IFunction)bind).getParameters().length == numOfArgs)) {
						IFunction ifunction = (IFunction) bind;
						IIndexName[] names = index.findNames(ifunction, IIndex.FIND_DEFINITIONS);
						for (IIndexName iname : names) {
							IIndexFile file = iname.getFile();
							if (file != null) {
								String loc = file.getLocation().getURI().getPath();
								if (fileHint != null){
									if (loc.endsWith(fileHint)){
										files.put(loc, new int [] {iname.getNodeOffset(), iname.getNodeLength()});
									}
								}else{
									files.put(loc, new int [] {iname.getNodeOffset(), iname.getNodeLength()});
								}
							}
						}
					}
				}
				
			} catch (CoreException e) {
				e.printStackTrace();
			} catch (InterruptedException e) {
				e.printStackTrace();
			} catch (DOMException e) {
				e.printStackTrace();
			}finally{
				index.releaseReadLock();
			}
		   return files;
	}

