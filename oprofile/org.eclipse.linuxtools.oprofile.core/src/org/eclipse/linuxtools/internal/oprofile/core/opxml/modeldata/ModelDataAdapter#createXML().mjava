	private void createXML() {

		// get the binary name and the image count
		Element oldImage = (Element) oldRoot.getElementsByTagName(BINARY).item(0);
		Element newImage = newDoc.createElement(IMAGE);

		String binName = oldImage.getAttribute(NAME);
		newImage.setAttribute(NAME, binName);

		Element countTag = (Element) oldImage.getElementsByTagName(COUNT).item(0);
		String imageCount = countTag.getTextContent().trim();
		newImage.setAttribute(COUNT, imageCount);

		// There is no setup count in timer mode
		if (!InfoAdapter.hasTimerSupport()) {
			// get the count that was used to profile
			Element setupTag = (Element) oldRoot.getElementsByTagName(SETUP).item(0);
			Element eventSetupTag = (Element) setupTag.getElementsByTagName(EVENT_SETUP).item(0);
			String setupcount = eventSetupTag.getAttribute(SETUP_COUNT);
			newImage.setAttribute(SETUP_COUNT, setupcount);
		}

		// these elements contain the data needed to populate the new symbol table
		Element oldSymbolTableTag = (Element) oldRoot.getElementsByTagName(SYMBOL_TABLE).item(0);
		NodeList oldSymbolDataList = oldSymbolTableTag.getElementsByTagName(SYMBOL_DATA);

		Element oldDetailTableTag = (Element) oldRoot.getElementsByTagName(DETAIL_TABLE).item(0);
		NodeList oldDetailTableList = oldDetailTableTag.getElementsByTagName(SYMBOL_DETAILS);

		// parse the data into HashMaps for O(1) lookup time, as opposed to O(n).
		HashMap<String, HashMap<String, String>> oldSymbolDataListMap = parseDataList(oldSymbolDataList);
		HashMap<String, NodeList> oldDetailTableListMap = parseDetailTable(oldDetailTableList);

		// An ArrayList to hold the binary and other modules
		ArrayList<Element> oldImageList = new ArrayList<>();
		// The first element is the original binary!
		oldImageList.add(oldImage);

		NodeList oldModuleList = oldImage.getElementsByTagName(MODULE);
		// Set up the dependent tag for any modules run by this binary
		Element dependentTag = newDoc.createElement(DEPENDENT);
		if (oldModuleList.getLength() > 0) {
			dependentTag.setAttribute(COUNT, "0"); //$NON-NLS-1$

			for (int t = 0; t < oldModuleList.getLength(); t++) {
				oldImageList.add((Element) oldModuleList.item(t));
			}
		}

		// iterate through all (binary/modules)
		for (Element oldImg : oldImageList) {
			Element newImg;
			if (oldImg.getTagName().equals(BINARY)) {
				newImg = newImage;
			} else {
				newImg = newDoc.createElement(IMAGE);

				String imgName = oldImg.getAttribute(NAME);
				newImg.setAttribute(NAME, imgName);

				Element modCountTag = (Element) oldImg.getElementsByTagName(COUNT).item(0);
				String imgCount = modCountTag.getTextContent().trim();
				newImg.setAttribute(COUNT, imgCount);
			}

			Element newSymbolsTag = newDoc.createElement(SYMBOLS);

			// these elements contain the data needed to populate the new symbol table
			NodeList oldSymbolList = oldImg.getElementsByTagName(SYMBOL);

			// iterate through all symbols
			for (int i = 0; i < oldSymbolList.getLength(); i++) {
				Element oldSymbol = (Element) oldSymbolList.item(i);

				/**
				 * The original binary is a parent for all symbols We only want library function
				 * calls under their respective modules, and not under the original binary as
				 * well.
				 */
				if (!oldSymbol.getParentNode().isSameNode(oldImg)) {
					continue;
				}

				Element newSymbol = newDoc.createElement(SYMBOL);
				String idref = oldSymbol.getAttribute(IDREF);
				String symbolCount = ((Element) oldSymbol.getElementsByTagName(COUNT).item(0)).getTextContent().trim();
				newSymbol.setAttribute(COUNT, symbolCount);

				// get the symboltable entry corresponding to the id of this symbol
				HashMap<String, String> symbolData = oldSymbolDataListMap.get(idref);
				newSymbol.setAttribute(NAME, symbolData.get(NAME));
				newSymbol.setAttribute(FILE, symbolData.get(FILE));
				newSymbol.setAttribute(LINE, symbolData.get(LINE));

				// get the symboldetails entry corresponding to the id of this symbol
				NodeList detailDataList = oldDetailTableListMap.get(idref);

				// go through the detail data of each symbol's details
				HashMap<String, Element> tmp = new HashMap<>();
				// temporary place to store the elements for sorting
				TreeSet<Element> sorted = new TreeSet<>(SAMPLE_COUNT_ORDER);
				for (int l = 0; l < detailDataList.getLength(); l++) {

					Element detailData = (Element) detailDataList.item(l);
					String sampleFile = detailData.getAttribute(FILE);
					String sampleLine = detailData.getAttribute(LINE);

					// The sample has a line number but no file
					// This means that the file is the same as the symbol (parent)
					if (sampleFile.equals("") && !sampleLine.isEmpty()) { //$NON-NLS-1$ $NON-NLS-2$
						sampleFile = symbolData.get(FILE);
					} else {
						if (sampleFile.equals("")) { //$NON-NLS-1$
							sampleFile = "??"; //$NON-NLS-1$
						}
						if (sampleLine.equals("")) { //$NON-NLS-1$
							sampleLine = "0"; //$NON-NLS-1$
						}
					}
					Element detailDataCount = (Element) detailData.getElementsByTagName(COUNT).item(0);
					String count = detailDataCount.getTextContent().trim();

					// if a sample at this line already exists then increase count for that line.
					if (tmp.containsKey(sampleLine)) {
						Element elem = (Element) tmp.get(sampleLine).getElementsByTagName(COUNT).item(0);
						int val = Integer.parseInt(elem.getTextContent().trim()) + Integer.parseInt(count);
						elem.setTextContent(String.valueOf(val));
					} else {
						Element sampleTag = newDoc.createElement(SAMPLE);

						Element fileTag = newDoc.createElement(FILE);
						fileTag.setTextContent(sampleFile);

						Element lineTag = newDoc.createElement(LINE);
						lineTag.setTextContent(sampleLine);

						Element sampleCountTag = newDoc.createElement(COUNT);
						sampleCountTag.setTextContent(count);

						sampleTag.appendChild(fileTag);
						sampleTag.appendChild(lineTag);
						sampleTag.appendChild(sampleCountTag);

						tmp.put(sampleLine, sampleTag);
					}
				}

				// add the elements to the sorter
				for (Element elem : tmp.values()) {
					sorted.add(elem);
				}

				// append the elements in sorted order
				for (Element e : sorted) {
					newSymbol.appendChild(e);
				}

				newSymbolsTag.appendChild(newSymbol);
			}

			newImg.appendChild(newSymbolsTag);
			// If this is a module, attach it to the dependent tag
			if (oldImg.getTagName().equals(MODULE)) {
				dependentTag.appendChild(newImg);
				int currVal = Integer.parseInt(dependentTag.getAttribute(COUNT));
				int val = Integer.parseInt(newImg.getAttribute(COUNT));
				dependentTag.setAttribute(COUNT, String.valueOf(currVal + val));
			} else {
				newRoot.appendChild(newImg);
			}
		}

		if (oldModuleList.getLength() > 0) {
			newImage.appendChild(dependentTag);
		}

	}

