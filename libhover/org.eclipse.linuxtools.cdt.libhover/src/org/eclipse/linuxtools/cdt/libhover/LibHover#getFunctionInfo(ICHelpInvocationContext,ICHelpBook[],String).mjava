	public IFunctionSummary getFunctionInfo(ICHelpInvocationContext context, ICHelpBook[] helpBooks, String name) {
        IFunctionSummary f;

        f = null;
        boolean isPTR = false;
        boolean isREF = false;
        int offset = -1;
        int length = 0;
        
        ITranslationUnit t = context.getTranslationUnit();
        
        String className = null;
        ICPPFunctionType methodType = null;
        
        if (t.isCXXLanguage()) {
        	try {
        		if (context instanceof IHoverHelpInvocationContext) {
        			// We know the file offset of the member reference.
        			IRegion region = (IRegion)((IHoverHelpInvocationContext)context).getHoverRegion();
        			char[] contents = t.getCodeReader().buffer;
        			int i = region.getOffset();
        			// Let's figure out if it is a pointer reference or a direct reference in which case we can
        			// find the variable and hence it's class.
        			if (i > 2 && contents[i-1] == '>' && contents[i-2] == '-') {
        				// Pointer reference
        				int j = i - 3;
        				int pointer = 0;
        				while (j > 0 && isCPPCharacter(contents[j])) {
        					pointer = j;
        					--j;
        				}
        				if (pointer != 0) {
        					offset = pointer;
        					length = region.getOffset() - pointer - 2;
        					isPTR = true;
        					//						String pointerName = new String(contents, pointer, region.getOffset() - pointer - 2);
        					//						System.out.println("pointer reference to " + pointerName);
        				}
        			} else if (i > 1 && contents[i-1] == '.') {
        				int j = i - 2;
        				int ref = 0;
        				while (j > 0 && isCPPCharacter(contents[j])) {
        					ref = j;
        					--j;
        				}
        				if (ref != 0) {
        					offset = ref;
        					length = region.getOffset() - ref - 1;
        					isREF = true;
        					//						String refName = new String(contents, ref, region.getOffset() - ref - 1);
        					//						System.out.println("regular reference to " + refName);
        				}
        			}
        			final IASTName[] result= {null};
        			final int toffset = offset;
        			final int tlength = length;

        			// If we have a pointer or reference variable, get its ASTName.
        			if (isPTR || isREF) {
        				EnclosingASTNameJob job = new EnclosingASTNameJob(t, toffset, tlength);
        				job.schedule();
        				try {
        					job.join();
        				} catch (InterruptedException e) {
        					// TODO Auto-generated catch block
        					e.printStackTrace();
        				}
        				if (job.getResult() == Status.OK_STATUS)
        					result[0] = job.getASTName();
        			}

        			// If we get the ASTName for the variable, let's find its declaration which will give us its class.
        			final IASTName[][] decl = {null};
        			if (result[0] != null) {
        				final IBinding binding = result[0].resolveBinding();
        				ASTDeclarationFinderJob job = new ASTDeclarationFinderJob(t, binding);
        				job.schedule();
        				try {
        					job.join();
        				} catch (InterruptedException e) {
        					// TODO Auto-generated catch block
        					e.printStackTrace();
        				}
        				if (job.getResult() == Status.OK_STATUS) {
        					decl[0] = job.getDeclarations();
        				}
        			}

        			// Look for a simple declaration.
        			IASTNode n = null;
        			if (decl[0] != null && decl[0].length > 0) {
         				n = decl[0][0];
        				while (n != null && !(n instanceof IASTSimpleDeclaration)) {
        					n = n.getParent();
        				}
        			}

        			// If we have the simple declaration, get its declaration specifier which hopefully will
        			// be a named type.
        			if (n != null) {
        				IASTSimpleDeclaration d = (IASTSimpleDeclaration)n;
        				IASTDeclSpecifier s = d.getDeclSpecifier();
        				if (s instanceof IASTNamedTypeSpecifier) {
        					// From the named type, we can get the binding of the type name and from that,
        					// its qualified name.  We need a qualified name (i.e. with namespace) because our
        					// repository of classes and typedefs are hashed by fully qualified names.
        					IASTName astName = ((IASTNamedTypeSpecifier)s).getName();
        					if (astName != null) {
        						IBinding nameBinding = astName.resolveBinding();
        						if (nameBinding instanceof ICPPBinding) {
        							String[] qualified = ((ICPPBinding)nameBinding).getQualifiedName();
        							className = qualified[0];
        							for (int k = 1; k < qualified.length; ++k)
        								className += "::" + qualified[k];
        						} else {
        							className = nameBinding.getName();
        						}
        					}
        				}
        			}
//        							System.out.println("classname is " + className);
        			
        			// Now, let's find the declaration of the method.  We need to do this because we want the specific
        			// member prototype to go searching for.  There could be many members called "x" which have different
        			// documentation.
        			if (className != null) {
        				EnclosingASTNameJob job = new EnclosingASTNameJob(t, region.getOffset(), region.getLength());
        				job.schedule();
        				try {
        					job.join();
        				} catch (InterruptedException e) {
        					// TODO Auto-generated catch block
        					e.printStackTrace();
        				}
        				if (job.getResult() == Status.OK_STATUS)
        					result[0] = job.getASTName();
        			}
        			if (result[0] != null) {
        				final IBinding binding = result[0].getBinding();
        				if (binding instanceof ICPPFunction) {
        					methodType = ((ICPPFunction)binding).getType();
        				}
        			}
        		}
        	} catch (IllegalArgumentException e) {
        		// TODO Auto-generated catch block
        		e.printStackTrace();
        	} catch (DOMException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
        }
        	
        // Loop through all the documents we have and report first match.
        for (int i = 0; i < helpBooks.length; ++i) {
        	LibHoverLibrary l = libraries.get(helpBooks[i]);
        	if (name != null) {
        		if (className != null) {
        			if (l.isCPP())
        				f = getMemberSummary(l, className, name, methodType);
        		} else {
        			f = getFunctionSummary(l, name);
        		}
        		if (f != null)
        			return f;
        	}
        }
        
        return null;
	}

