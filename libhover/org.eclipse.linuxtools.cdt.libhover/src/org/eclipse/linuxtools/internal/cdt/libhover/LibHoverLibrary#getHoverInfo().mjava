	/**
	 * Get the library hover info for this library
	 * 
	 * @return the library hover info for this library
	 */
	public synchronized LibHoverInfo getHoverInfo() {
		// We lazily get the hover info for this library since it is possible
		// the user will never access or ultimately need it if another library
		// supplies the information first.
		if (!haveReadHoverInfo) {
			URI acDoc;
			try {
				acDoc = new URI(location);
				IPath p = URIUtil.toPath(acDoc);
				InputStream docStream = null;
				if (p == null) {
					URL url = acDoc.toURL();
					URLConnection c = url.openConnection();
					c.setReadTimeout(5000); // pick a timeout value less than 15s (default)
					docStream = c.getInputStream();
				} else {
					try {
						// Try to open the file local to the plug-in declaring the
						// extension...or fall back to the libhover plug-in itself
						// if no name space for the plug-in is stored.
						Bundle bundle = LibhoverPlugin.getDefault().getBundle();
						String nameSpace = getNameSpace();
						if (nameSpace != null)
							bundle = Platform.getBundle(nameSpace);
						docStream = FileLocator.openStream(bundle, p, false);
					} catch (IOException e) {
						// File is not local to plug-in, try file system.
						docStream = new FileInputStream(p.toFile());
					}
				}
				ObjectInputStream input = new ObjectInputStream(docStream);
				hoverInfo = (LibHoverInfo)input.readObject();
				haveReadHoverInfo = true;
				input.close();
				docStream.close();
			} catch (URISyntaxException e) {
				e.printStackTrace();
			} catch (MalformedURLException e) {
				e.printStackTrace();
			} catch (ConnectException e) {
				// Do nothing..time-out exception
			} catch (SocketTimeoutException e) {
				// Do nothing..time-out exception
			} catch (IOException e) {
				// Do nothing as empty devhelp causes this
			} catch (ClassNotFoundException e) {
				e.printStackTrace();
			}
		}
		return hoverInfo;
	}

