	@Override
	public void launch(ILaunchConfiguration config, String mode,
			ILaunch launch, IProgressMonitor monitor) throws CoreException {
		// check if Perf exists in $PATH
		if (! PerfCore.checkPerfInPath()) {
			IStatus status = new Status(IStatus.ERROR, PerfPlugin.PLUGIN_ID,
					Messages.PerfLaunchConfigDelegate_perf_not_found);
			throw new CoreException(status);
		}

		// Get working directory
		File wd = getWorkingDirectory(config);
		if (wd == null) {
			wd = new File(System.getProperty("user.home", ".")); //$NON-NLS-1$ //$NON-NLS-2$
		}
		IPath workingDir = Path.fromOSString(wd.toURI().getPath());
		PerfPlugin.getDefault().setWorkingDir(workingDir);

		if (config.getAttribute(PerfPlugin.ATTR_ShowStat,
				PerfPlugin.ATTR_ShowStat_default)) {
			showStat(config, launch);
		} else {

			//Find the binary path
			IPath exePath = CDebugUtils.verifyProgramPath( config );

			// Build the commandline string to run perf recording the given project
			// Program args from launch config.
			String arguments[] = getProgramArgumentsArray(config);

			ArrayList<String> command = new ArrayList<String>();
			// Get the base commandline string (with flags/options based on config)
			Version perfVersion = PerfCore.getPerfVersion(config, null, workingDir);
			command.addAll(Arrays.asList(PerfCore.getRecordString(config, perfVersion)));
			// Add the path to the executable
			command.add(exePath.toOSString());
			command.addAll(Arrays.asList( arguments));
			String[] commandArray = command.toArray(new String[] {});
			boolean usePty = config.getAttribute(ICDTLaunchConfigurationConstants.ATTR_USE_TERMINAL,
					ICDTLaunchConfigurationConstants.USE_TERMINAL_DEFAULT);

			Process process;
			try {
				//Spawn the process
				process = execute( commandArray, getEnvironment( config ), wd, usePty );
				createNewProcess( launch, process, commandArray[0] ); //Spawn IProcess using Debug plugin (CDT)

				//Wait for recording to complete.
				process.waitFor();
				PrintStream print = null;
				if (config.getAttribute(IDebugUIConstants.ATTR_CAPTURE_IN_CONSOLE, true)) {
					//Get the console to output to.
					//This may not be the best way to accomplish this but it shall do for now.
					ConsolePlugin plugin = ConsolePlugin.getDefault();
					IConsoleManager conMan = plugin.getConsoleManager();
					IConsole[] existing = conMan.getConsoles();
					IOConsole binaryOutCons = null;

					// Find the console
					for(IConsole x : existing) {
						if (x.getName().contains(renderProcessLabel(commandArray[0]))
								&& x instanceof IOConsole) {
							binaryOutCons = (IOConsole)x;
						}
					}
					// If can't be found get the most recent opened, this should probably never happen.
					if ((binaryOutCons == null) && (existing.length != 0)) {
						if (existing[existing.length - 1] instanceof IOConsole)
							binaryOutCons = (IOConsole)existing[existing.length - 1];
					}

					//Get the printstream via the outputstream.
					//Get ouput stream
					OutputStream outputTo;
					if (binaryOutCons != null) {
						outputTo = binaryOutCons.newOutputStream();
						print = new PrintStream(outputTo);

						for (int i = 0; i < commandArray.length; i++) {
							print.print(commandArray[i] + " "); //$NON-NLS-1$
						}

						// Print Message
						print.println();
						print.println(Messages.PerfLaunchConfigDelegate_analyzing);
						// Possibly should pass this (the console reference) on to
						// PerfCore.Report if theres anything we ever want to spit
						// out to user.
					}
				}

				PerfCore.Report(config, getEnvironment(config), workingDir, monitor, null, print);
				PerfPlugin.getDefault().getPerfProfileData().toFile().setReadOnly();
				PerfCore.RefreshView(renderProcessLabel(exePath.toOSString()));

				if (config.getAttribute(PerfPlugin.ATTR_ShowSourceDisassembly,
						PerfPlugin.ATTR_ShowSourceDisassembly_default)) {
					showSourceDisassembly(workingDir);
				}

			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}

