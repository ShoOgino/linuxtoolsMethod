	private void finishLaunch(ILaunch launch, ILaunchConfiguration config, String options,
			IProgressMonitor monitor, boolean retry) {
		String errorMessage = ""; //$NON-NLS-1$

		try {

			// Generate the command
			cmd = SystemTapCommandGenerator.generateCommand(scriptPath, binaryPath,
					options, needsBinary, needsArguments, arguments, binaryArguments, command);
			
			// Check for cancellation
			if (monitor.isCanceled()) {
				return;
			}

			monitor.worked(1);
			
			if (launch == null) {
				return;
			}
			// Not sure if this line is necessary
			// set the default source locator if required
			setDefaultSourceLocator(launch, config);
			
			String parserClass = config.getAttribute(LaunchConfigurationConstants.PARSER_CLASS, 
					LaunchConfigurationConstants.DEFAULT_PARSER_CLASS);
			IExtensionRegistry reg = Platform.getExtensionRegistry();
			IConfigurationElement[] extensions = reg
					.getConfigurationElementsFor(PluginConstants.PARSER_RESOURCE, 
							PluginConstants.PARSER_NAME, 
							parserClass);
			
			if (extensions == null || extensions.length < 1) {
				SystemTapUIErrorMessages mess = new SystemTapUIErrorMessages(Messages.getString("SystemTapLaunchConfigurationDelegate.InvalidParser1"),  //$NON-NLS-1$
						Messages.getString("SystemTapLaunchConfigurationDelegate.InvalidParser2"), //$NON-NLS-1$ //$NON-NLS-2$
						Messages.getString("SystemTapLaunchConfigurationDelegate.InvalidParser3") + //$NON-NLS-1$
						Messages.getString("SystemTapLaunchConfigurationDelegate.InvalidParser4") + parserClass); //$NON-NLS-1$
				mess.schedule();
				return;
			}
			
			IConfigurationElement element = extensions[0];

			SystemTapParser parser = 
				(SystemTapParser) element.createExecutableExtension(PluginConstants.ATTR_CLASS);
			parser.setViewID(config.getAttribute(LaunchConfigurationConstants.VIEW_CLASS,
					LaunchConfigurationConstants.VIEW_CLASS));
			parser.setSourcePath(outputPath);
			parser.setMonitor(SubMonitor.convert(monitor));
			parser.setDone(false);
			parser.setSecondaryID(config.getAttribute(LaunchConfigurationConstants.SECONDARY_VIEW_ID,
					LaunchConfigurationConstants.DEFAULT_SECONDARY_VIEW_ID));

			parser.setKillButtonEnabled(true);
						
			if (element.getAttribute(PluginConstants.ATTR_REALTIME).equals(PluginConstants.VAL_TRUE)) {
				parser.setRealTime(true);
				parser.schedule();
			}

			monitor.worked(1);
			
			IProcess process = createProcess(config, launch);
			
			if (process == null){
				
				parser.setDone(true);
				SystemTapErrorHandler err = new SystemTapErrorHandler();
				err.handle(monitor, "could not find stap");
				err.finishHandling(monitor, scriptPath);
				return;
			}
			
			monitor.worked(1);
			
			StreamListener s = new StreamListener();
			process.getStreamsProxy().getErrorStreamMonitor().addListener(s);

			
			while (!process.isTerminated()) {
				Thread.sleep(100);
				if ((monitor != null && monitor.isCanceled()) || parser.isJobCancelled()) {
					parser.cancelJob();
					process.terminate();
					return;
				}
			}
			Thread.sleep(100);
			s.close();
			parser.setKillButtonEnabled(false);
			

			if (process.getExitValue() != 0) {
				parser.cancelJob();
				//SystemTap terminated with errors, parse console to figure out which error 
				IDocument doc = Helper.getConsoleDocumentByName(config.getName());
				//Sometimes the console has not been printed to yet, wait for a little while longer
				if (doc.get().length() < 1)
					Thread.sleep(300);
				SystemTapErrorHandler errorHandler = new SystemTapErrorHandler();
				
				
				//Prepare stap information
				errorHandler.appendToLog(config.getName() + Messages.getString("SystemTapLaunchConfigurationDelegate.stap_command") + cmd+ PluginConstants.NEW_LINE + PluginConstants.NEW_LINE);//$NON-NLS-1$
				
				//Handle error from TEMP_ERROR_OUTPUT
				errorMessage = errorHandler.handle(monitor, new FileReader(TEMP_ERROR_OUTPUT)); //$NON-NLS-1$
				if ((monitor != null && monitor.isCanceled()))
					return;
				
				
				//If we are meant to retry, and the conditions for retry are met
				//Currently conditions only met if there are mismatched probe points present
				if (errorHandler.hasMismatchedProbePoints() && retry) {
					
					SystemTapUIErrorMessages mess = new SystemTapUIErrorMessages(Messages.getString("SystemTapLaunchConfigurationDelegate.Relaunch1"), //$NON-NLS-1$
							Messages.getString("SystemTapLaunchConfigurationDelegate.Relaunch2"),  //$NON-NLS-1$
							Messages.getString("SystemTapLaunchConfigurationDelegate.Relaunch3")); //$NON-NLS-1$
					mess.schedule();
					
					//If finishHandling determines that errors are not fixable, return
					if (!errorHandler.finishHandling(monitor, scriptPath))
						return;
					
					
					//Abort job
					if ((monitor != null && monitor.isCanceled()) || parser.isJobCancelled()) {
						monitor.setCanceled(true);
						parser.cancelJob();
						return;
					}
					finishLaunch(launch, config, options, monitor, false);
					return;
				}
				
				errorHandler.finishHandling(monitor, scriptPath);
				return;
			}
			
			if (! element.getAttribute(PluginConstants.ATTR_REALTIME).equals(PluginConstants.VAL_TRUE)) { //$NON-NLS-1$ //$NON-NLS-2$
				parser.schedule();
			} else {
				//Parser already scheduled, but double-check
				if (parser != null)
					parser.cancelJob();
			}
						
			
			monitor.worked(1);
			
			errorMessage = generateErrorMessage(config.getName(), binaryArguments) + errorMessage;
			
			DocWriter dw = new DocWriter(Messages.getString("SystemTapLaunchConfigurationDelegate.DocWriterName"),  //$NON-NLS-1$
					((TextConsole)Helper.getConsoleByName(config.getName())), errorMessage);
			dw.schedule();

			
		} catch (IOException e) {
			e.printStackTrace();
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (CoreException e) {
			e.printStackTrace();
		} finally {
			monitor.done();
			
		}
	}

