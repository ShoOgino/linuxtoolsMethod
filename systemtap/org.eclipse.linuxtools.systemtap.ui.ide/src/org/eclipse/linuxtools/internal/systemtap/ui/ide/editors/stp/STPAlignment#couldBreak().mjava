	public boolean couldBreak() {
		int i;
		switch (mode & SPLIT_MASK) {
			/*  # aligned fragment
			 *  foo(
			 *     #AAAAA, #BBBBB,
			 *     #CCCC);
			 */
			case M_COMPACT_FIRST_BREAK_SPLIT:
				if (this.fragmentBreaks[0] == NONE) {
					if ((this.mode & M_INDENT_ON_COLUMN) != 0) {
						if (this.breakIndentationLevel <= this.alternativeBreakIndentationLevel) {
							// Does not make sense to break here unless indentation is reduced.
							break;
						}
						// Change break indentation level and erase previously created breaks.
						this.breakIndentationLevel = this.alternativeBreakIndentationLevel;
						eraseExistingBreaks(0);
					}
					this.fragmentBreaks[0] = BREAK;
					this.fragmentIndentations[0] = this.breakIndentationLevel;
					return wasSplit = true;
				}
				i = this.fragmentIndex;
				do {
					if (this.fragmentBreaks[i] == NONE) {
						this.fragmentBreaks[i] = BREAK;
						this.fragmentIndentations[i] = this.breakIndentationLevel;
						return wasSplit = true;
					}
				} while (--i >= 0);
				break;
			/*  # aligned fragment
			 *  foo(#AAAAA, #BBBBB,
			 *     #CCCC);
			 */
			case M_COMPACT_SPLIT:
				i = this.fragmentIndex;
				do {
					if (this.fragmentBreaks[i] == NONE) {
						if ((this.mode & M_INDENT_ON_COLUMN) != 0 && isFirstBreakableFragment(i)) {
							if (this.breakIndentationLevel <= this.alternativeBreakIndentationLevel) {
								// Does not make sense to break here unless indentation is reduced.
								break;
							}
							// Change break indentation level and erase previously created breaks.
							this.breakIndentationLevel = this.alternativeBreakIndentationLevel;
							eraseExistingBreaks(i);
						}
						this.fragmentBreaks[i] = BREAK;
						this.fragmentIndentations[i] = this.breakIndentationLevel;
						return wasSplit = true;
					}
				} while ((this.fragmentBreaks[i] != BREAK || (this.mode & M_INDENT_ON_COLUMN) != 0) && --i >= 0);
				break;

			/*  # aligned fragment
			 *  foo(
			 *      #AAAAA,
			 *          #BBBBB,
			 *          #CCCC);
			 */
			case M_NEXT_SHIFTED_SPLIT:
				if (this.fragmentBreaks[0] == NONE) {
					this.fragmentBreaks[0] = BREAK;
					this.fragmentIndentations[0] = this.breakIndentationLevel;
					for (i = 1; i < this.fragmentCount; i++) {
						this.fragmentBreaks[i] = BREAK;
						this.fragmentIndentations[i] =
								this.breakIndentationLevel + this.scribe.indentationSize;
					}
					return wasSplit = true;
				}
				break;

			/*  # aligned fragment
			 *  foo(
			 *      #AAAAA,
			 *      #BBBBB,
			 *      #CCCC);
			 */
			case M_ONE_PER_LINE_SPLIT:
				if (this.fragmentBreaks[0] == NONE) {
					for (i = 0; i < this.fragmentCount; i++) {
						this.fragmentBreaks[i] = BREAK;
						this.fragmentIndentations[i] = this.breakIndentationLevel;
					}
					return wasSplit = true;
				}
				break;
			/*  # aligned fragment
			 *  foo(#AAAAA,
			 *      #BBBBB,
			 *      #CCCC);
			 */
			case M_NEXT_PER_LINE_SPLIT:
				if (this.fragmentBreaks[0] != BREAK) {
					if (this.fragmentCount > 1 && this.fragmentBreaks[1] == NONE) {
						if ((this.mode & M_INDENT_ON_COLUMN) != 0) {
							this.fragmentIndentations[0] = this.breakIndentationLevel;
						}
						for (i = 1; i < this.fragmentCount; i++) {
							this.fragmentBreaks[i] = BREAK;
							this.fragmentIndentations[i] = this.breakIndentationLevel;
						}
						return wasSplit = true;
					}
				}
				break;
		}
		return false; // Cannot split better
	}

