	public Token nextToken() {
	    fTokenBuffer.setLength(0);

	    boolean madeMistake = false;
	    int c = getChar();

	    while (c != EOFCHAR) {
	        if (fPreprocessorToken != 0) {
	            Token token= continuePPDirective(c);
	            if (token != null) {
	                return token;
	            }
	        }

	        if ((c == ' ') || (c == '\r') || (c == '\t') || (c == '\n')) {
	            do {
	                c = getChar();
	            } while ((c == ' ') || (c == '\r') || (c == '\t') || (c == '\n'));
	            ungetChar(c);
	            return newToken(Token.tWHITESPACE);
	        } else if (c == '"') {
	            matchStringLiteral();
	            return newToken(Token.tSTRING);
	        } else if (c == 'L' && !madeMistake) {
                int oldChar = c;
                c = getChar();
                if (c != '"') {
                    // we have made a mistake
                    ungetChar(c);
                    c = oldChar;
                    madeMistake = true;
                    continue;
                }

	            matchStringLiteral();
	            return newToken(Token.tLSTRING);
	        } else if (c == 'R' && !madeMistake) {
                int oldChar = c;
                c = getChar();
                if (c != '"') {
                    // we have made a mistake
                    ungetChar(c);
                    c = oldChar;
                    madeMistake = true;
                    continue;
                }

	            matchRawStringLiteral();
	            return newToken(Token.tRSTRING);
	        } else if (((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z')) || (c == '_') || (c > 255 && Character.isUnicodeIdentifierStart(c))) {
	            madeMistake = false;

	            c = getChar();

	            while (((c >= 'a') && (c <= 'z'))
	                || ((c >= 'A') && (c <= 'Z'))
	                || ((c >= '0') && (c <= '9'))
	                || (c == '_')
	                || (c > 255 && Character.isUnicodeIdentifierPart(c))) {
	                c = getChar();
	            }

	            ungetChar(c);

	            String ident = fTokenBuffer.toString();

	            Object tokenTypeObject;

	            tokenTypeObject = fgKeywords.get(ident);

	            int tokenType = Token.tIDENTIFIER;
	            if (tokenTypeObject != null)
	                tokenType = ((Integer)tokenTypeObject).intValue();

	            return newToken(tokenType);
	        } else if ((c >= '0') && (c <= '9') || c == '.') {
	            boolean hex = false;
	            boolean floatingPoint = c == '.';
	            boolean firstCharZero = c == '0';

	            c = getChar();

                if (firstCharZero && c == 'x') {
	                hex = true;
	                c = getChar();
	            }

                int digits= 0;

	            while ((c >= '0' && c <= '9') || (hex && ((c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')))) {
	            	++digits;
	                c = getChar();
	            }

	            if (!hex) {
	            	if (c == '*') {
	            		if (floatingPoint && digits == 0) {
	            			// encountered .*
	            			return newToken(Token.tDOTSTAR);
	            		}
	            	} else if (c == '.') {
	            		if (floatingPoint && digits == 0) {
	            			// encountered ..
	            			if ((c= getChar()) == '.') {
	            				return newToken(Token.tELIPSE);
	            			} else {
	            				ungetChar(c);
	            				ungetChar('.');
	            				return newToken(Token.tDOT);
	            			}
	            		}

	            		floatingPoint = true;
	            		c = getChar();
	            		while ((c >= '0' && c <= '9')) {
	            			++digits;
	            			c = getChar();
	            		}
	            	} else if (digits > 0 && (c == 'e' || c == 'E')) {
	            		floatingPoint = true;

	            		// exponent type for floating point
	            		c = getChar();

	            		// optional + or -
	            		if (c == '+' || c == '-') {
	            			c = getChar();
	            		}

	            		// digit sequence of exponent part
	            		while ((c >= '0' && c <= '9')) {
	            			c = getChar();
	            		}
	            	}
	            }
	            if (floatingPoint) {
	            	if (digits > 0) {
	            		//floating-suffix
	            		if (c == 'l' || c == 'L' || c == 'f' || c == 'F') {
	            			c = getChar();
	            		}
	            	} else {
	            		ungetChar(c);
	            		return newToken(Token.tDOT);
	            	}
	            } else {
	            	//integer suffix
	            	if (c == 'u' || c == 'U') {
	            		c = getChar();
	            		if (c == 'l' || c == 'L')
	            			c = getChar();
	            	} else if (c == 'l' || c == 'L') {
	            		c = getChar();
	            		if (c == 'u' || c == 'U')
	            			c = getChar();
	            	}
	            }

	            ungetChar(c);

	            int tokenType;
	            String result = fTokenBuffer.toString();

	            if (floatingPoint && result.equals(".")) //$NON-NLS-1$
	                tokenType = Token.tDOT;
	            else
	                tokenType = floatingPoint ? Token.tFLOATINGPT : Token.tINTEGER;

	            return newToken(tokenType);
	        } else if (c == '#') {
	            return matchPPDirective();
	        } else {
	            switch (c) {
	            case '\'':
					matchCharLiteral();
	                return newToken(Token.tCHAR);

	            case ':':
	                c = getChar();
	                if (c == ':') {
	                    return newToken(Token.tCOLONCOLON);
	                } else {
	                    ungetChar(c);
	                    return newToken(Token.tCOLON);
	                }
	            case ';':
	                return newToken(Token.tSEMI);
	            case ',':
	                return newToken(Token.tCOMMA);
	            case '?':
	                return newToken(Token.tQUESTION);
	            case '(':
	                return newToken(Token.tLPAREN);
	            case ')':
	                return newToken(Token.tRPAREN);
	            case '[':
	                return newToken(Token.tLBRACKET);
	            case ']':
	                return newToken(Token.tRBRACKET);
	            case '{':
	                return newToken(Token.tLBRACE);
	            case '}':
	                return newToken(Token.tRBRACE);
	            case '+':
	                c = getChar();
	                switch (c) {
	                case '=':
	                    return newToken(Token.tPLUSASSIGN);
	                case '+':
	                    return newToken(Token.tINCR);
	                default:
	                    ungetChar(c);
	                    return newToken(Token.tPLUS);
	                }
	            case '-':
	                c = getChar();
	                switch (c) {
	                case '=':
	                    return newToken(Token.tMINUSASSIGN);
	                case '-':
	                    return newToken(Token.tDECR);
	                case '>':
	                    c = getChar();
	                    switch (c) {
	                    case '*':
	                        return newToken(Token.tARROWSTAR);
	                    default:
	                        ungetChar(c);
	                        return newToken(Token.tARROW);
	                    }
	                default:
	                    ungetChar(c);
	                    return newToken(Token.tMINUS);
	                }
	            case '*':
	                c = getChar();
	                switch (c) {
	                case '=':
	                    return newToken(Token.tSTARASSIGN);
	                default:
	                    ungetChar(c);
	                    return newToken(Token.tSTAR);
	                }
	            case '%':
	                c = getChar();
	                switch (c) {
	                case '=':
	                    return newToken(Token.tMODASSIGN);
	                default:
	                    ungetChar(c);
	                    return newToken(Token.tMOD);
	                }
	            case '^':
	                c = getChar();
	                switch (c) {
	                case '=':
	                    return newToken(Token.tXORASSIGN);
	                default:
	                    ungetChar(c);
	                    return newToken(Token.tXOR);
	                }
	            case '&':
	                c = getChar();
	                switch (c) {
	                case '=':
	                    return newToken(Token.tAMPERASSIGN);
	                case '&':
	                    return newToken(Token.tAND);
	                default:
	                    ungetChar(c);
	                    return newToken(Token.tAMPER);
	                }
	            case '|':
	                c = getChar();
	                switch (c) {
	                case '=':
	                    return newToken(Token.tBITORASSIGN);
	                case '|':
	                    return newToken(Token.tOR);
	                default:
	                    ungetChar(c);
	                    return newToken(Token.tBITOR);
	                }
	            case '~':
	                return newToken(Token.tCOMPL);
	            case '!':
	                c = getChar();
	                switch (c) {
	                case '=':
	                    return newToken(Token.tNOTEQUAL);
	                default:
	                    ungetChar(c);
	                    return newToken(Token.tNOT);
	                }
	            case '=':
	                c = getChar();
	                switch (c) {
	                case '=':
	                    return newToken(Token.tEQUAL);
	                default:
	                    ungetChar(c);
	                    return newToken(Token.tASSIGN);
	                }
	            case '<':
	                c = getChar();
	                switch (c) {
	                case '<':
	                    c = getChar();
	                    switch (c) {
	                    case '=':
	                        return newToken(Token.tSHIFTLASSIGN);
	                    default:
	                        ungetChar(c);
	                        return newToken(Token.tSHIFTL);
	                    }
	                case '=':
	                    return newToken(Token.tLTEQUAL);
	                default:
	                    ungetChar(c);
	                    return newToken(Token.tLT);
	                }
	            case '>':
	                c = getChar();
	                switch (c) {
	                case '>':
	                    c = getChar();
	                    switch (c) {
	                    case '=':
	                        return newToken(Token.tSHIFTRASSIGN);
	                    default:
	                        ungetChar(c);
	                        return newToken(Token.tSHIFTR);
	                    }
	                case '=':
	                    return newToken(Token.tGTEQUAL);
	                default:
	                    ungetChar(c);
	                    return newToken(Token.tGT);
	                }
	            case '.':
	                c = getChar();
	                switch (c) {
	                case '.':
	                    c = getChar();
	                    switch (c) {
	                    case '.':
	                        return newToken(Token.tELIPSE);
	                    default:
	                        break;
	                    }
	                    break;
	                case '*':
	                    return newToken(Token.tDOTSTAR);
	                default:
	                    ungetChar(c);
	                    return newToken(Token.tDOT);
	                }
	                break;
	            case '/':
	                c = getChar();
	                switch (c) {
	                case '/': {
	                    matchSinglelineComment();
	                    return newToken(Token.tLINECOMMENT);
	                }
	                case '*': {
	                    matchMultilineComment();
	                    return newToken(Token.tBLOCKCOMMENT);
	                }
	                case '=':
	                    return newToken(Token.tDIVASSIGN);
	                default:
	                    ungetChar(c);
	                    return newToken(Token.tDIV);
	                }
	            default:
	                // Bad character
	                return newToken(Token.tBADCHAR);
	            }
	            // throw EOF;
	        }
	    }

	    // we're done
	    // throw EOF;
	    return null;
	}

