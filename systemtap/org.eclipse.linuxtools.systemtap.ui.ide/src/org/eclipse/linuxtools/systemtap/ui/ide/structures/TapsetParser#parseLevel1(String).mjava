	/**
	 * Parses the output generated from running stap -vp1. Pulls out all functions
	 * and probe aliases from the provided string. Populates the probe and function
	 * trees.
	 * 
	 * ProbeTree organized as:
	 * 	Root->Files->ProbePoints->Variables
	 * 
	 * FunctionTree organized as:
	 * 	Root->Files->Functions
	 * @param s The entire output from running stap -vp1.
	 */
	private void parseLevel1(String s) {
		String prev = null;
		String prev2 = null;
		StringBuilder token = new StringBuilder("");
		TreeNode parent;
		TreeNode item;
		char currChar;
		boolean isProbe = false;
		
		boolean contains;
		TreeNode child;
		int z;
		
		for(int i=0; i<s.length(); i++) {
			currChar = s.charAt(i);
			if(!Character.isWhitespace(currChar) && '}' != currChar && '{' != currChar) {
				token.append(currChar);
			} else if(token.length() > 0){
				prev2 = prev;
				prev = token.toString();
				token.delete(0, token.length());
			}
			//Only check for new values when starting a fresh token.
			if(1 == token.length()) {
				if("probe".equals(prev2) && "=".equals(token.toString())) {
					//Probe alias found
					do {
						currChar = s.charAt(++i);
						token.append(currChar);
					} while('{' != currChar && i < s.length());
					
					parent = probes.getChildAt(probes.getChildCount()-1);
					parent.add(new TreeDefinitionNode("probe " + token.toString().substring(2, token.length()-1), prev, parent.getData().toString(), true));
					isProbe = true;
				} else if("function".equals(prev2)) {
					//Function found
					do {
						currChar = s.charAt(++i);
						token.append(currChar);
					} while(')' != currChar && i < s.length());

					parent = functions.getChildAt(functions.getChildCount()-1);
					parent.add(new TreeDefinitionNode(prev + token.toString(), prev + token.toString(), parent.getData().toString(), true));
					isProbe = false;
				} else if("file".equals(prev2)) {
					//New file started
					if(prev.lastIndexOf('/') > 0)
						prev2 = prev.substring(prev.lastIndexOf('/')+1);
					functions.add(new TreeNode(prev, prev2, false));
					probes.add(new TreeNode(prev, prev2, false));
					isProbe = false;
				}
			} else if(prev2 != null && prev2.length() > 2 && token.length() > 2 && isProbe &&
					  '(' == prev2.charAt(0) && ')' == prev2.charAt(prev2.length()-1) &&
					  '(' == token.charAt(0) && ')' == token.charAt(token.length()-1) &&
					  "=".equals(prev)) {
				//Put all variables in the probe tree
				item = probes.getChildAt(probes.getChildCount()-1);
				prev2 = prev2.substring(1,prev2.length()-1);

				child = item.getChildAt(item.getChildCount()-1);
				contains = false;
				for(z=0; z<child.getChildCount(); z++) {
					if(child.getChildAt(z).toString().equals(prev2)) {
						contains = true;
						break;
					}
				}
			
				if(!contains)
					child.add(new TreeNode(prev2 + ":unknown", prev2, false));
				
				prev2 = null;
			} else if ("/*".equals(token.toString())){
				// Skip comments
				for(; i<s.length()-1; i++) {
					if (s.regionMatches(i, "*/", 0, 2)){
						i++;
						break;
					}
				}
				// clear token
				token.delete(0, token.length());
			} else if ("//".equals(token.toString())){
				// Skip comments
				for(; i<s.length(); i++) {
					if (s.charAt(i) == '\n'){
						break;
					}
				}
				// clear token
				token.delete(0, token.length());
			}
		}
	}

