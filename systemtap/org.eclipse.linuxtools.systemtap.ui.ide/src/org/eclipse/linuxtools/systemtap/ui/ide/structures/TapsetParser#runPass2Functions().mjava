	/**
	 * This method is used to build up the list of functions that were found
	 * during the first pass of stap.  Stap is invoked by: $stap -v -p1 -e
	 * 'probe begin{}' and parsing the output.
	 */
	private void runPass2Functions() {
		int i = 0;
		TreeNode parent;
		String script = "probe begin{}";
		String result = runStap(new String[] {"-v", "-p1", "-e"}, script);
		StringTokenizer st = new StringTokenizer(result, "\n", false);
		st.nextToken(); //skip that stap command
		String tok = "";
		while(st.hasMoreTokens()) {
			tok = st.nextToken().toString();
			String regex = "^function .*\\)\n$"; //match ^function and ending the line with ')'
			Pattern p = Pattern.compile(regex, Pattern.MULTILINE | Pattern.UNIX_LINES | Pattern.COMMENTS);
			Matcher m = p.matcher(tok);
			while(m.find()) {
				// this gives us function foo (bar, bar)
				// we need to strip the ^function and functions with a leading _
				Pattern secondp = Pattern.compile("[\\W]"); //take our function line and split it up
				Pattern underscorep = Pattern.compile("^function _.*"); //remove any lines that "^function _"
				String[] us = underscorep.split(m.group().toString());
				
				for(String s : us) {
					String[] test = secondp.split(s);
					i = 0;
					for(String t : test) {
						// If i== 1 this is a function name.
						// Ignore ALL_CAPS functions; they are not meant for end
						// user use.
						if(i == 1 && !t.matches("[A-Z_1-9]*")) { //$NON-NLS-1$
							functions.add(new TreeNode(t, t, true));
						}
						else if(i > 1 && t.length() >= 1) {
							parent = functions.getChildAt(functions.getChildCount()-1);
							parent.add(new TreeDefinitionNode("function " + t, t, parent.getData().toString(), false));
						}
						i++;
					}
				}
			}
			functions.sortTree();
		}
	}

