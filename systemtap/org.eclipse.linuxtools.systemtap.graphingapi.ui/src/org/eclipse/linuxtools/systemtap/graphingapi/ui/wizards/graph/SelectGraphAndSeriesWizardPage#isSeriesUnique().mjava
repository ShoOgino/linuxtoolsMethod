	/**
	 * Checks for conflicts in data selection. (An example of a conflict
	 * is two Y-series fields set to the same output value.)
	 * @return <code>true</code> if there is no conflict, <code>false</code> otherwise.
	 * Also visually marks conficting series.
	 */
	private boolean isSeriesUnique() {
		boolean foundDuplicate = false;

		// Undo duplicate marking, as it is to be updated.
		markAsDuplicate(cboXItem, false);
		for (int i = 0; i < cboYItems.length; i++) {
			markAsDuplicate(cboYItems[i], false);
		}

		for(int j,i=0; i<cboYItems.length; i++) {
			if(cboYItems[i].isVisible() && !deleted[i+1]) {
				for(j=i+1; j<cboYItems.length; j++) {
					try {
						if(!deleted[j+1] && cboYItems[j].isVisible() && cboYItems[i].getItem(cboYItems[i].getSelectionIndex())
								.equals(cboYItems[j].getItem(cboYItems[j].getSelectionIndex()))) {
								markAsDuplicate(cboYItems[i], true);
								markAsDuplicate(cboYItems[j], true);
								foundDuplicate = true;
						}
					} catch (Exception e) {
						// If a cboYItem has no item selected, don't mark any duplicates. Ignore.
					}
				}
				try {
					if(!deleted[0] && cboYItems[i].getItem(cboYItems[i].getSelectionIndex()).equals(cboXItem.getItem(cboXItem.getSelectionIndex()))) {
						markAsDuplicate(cboYItems[i], true);
						markAsDuplicate(cboXItem, true);
						foundDuplicate = true;
					}
				} catch (Exception e) {
					// Ignore for same reason as above.
				}
			}
		}
		return !foundDuplicate;
	}

