	public void drawFromBottomToTop(int level, int height,
			int MaxLevelPixelWidth) {
		
		// FINISHED DRAWING THE ROOT IN THE LAST RECURSIVE CALL
		if (level == 0 || level < topLevelToDraw ) {
			return;
		}
		
		// FIND ALL THE CHILDREN AT LEVEL 'level'
		int total = levels.get(level).remove(0);
		int count = 1;
		
		//CREATE THE NODES
		for (int i = 0; i < levels.get(level).size(); i ++) {
			int id = levels.get(level).get(i);
			if (collapse_mode && nodeDataMap.get(id).isPartOfCollapsedNode()) {
				continue;
			}
			if (!collapse_mode && nodeDataMap.get(id).isCollapsed)
				continue;
			
			if (nodeMap.get(id) == null) {
				nodeMap.put(id, getNodeData(id).makeNode(this));
			}
			
			StapNode n = nodeMap.get(id);
			
			n.setVisible(true);
			n.setSize(n.getSize().width/scale, n.getSize().height/scale);
			//HEART OF THE ALGORITHM
			if (getAnimationMode() == CONSTANT_ANIMATION_SLOW){				
				Animation.markBegin();
				n.setLocation(nodeMap.get(getRootVisibleNode()).getLocation().x,nodeMap.get(getRootVisibleNode()).getLocation().y);
				n.setLocation(MaxLevelPixelWidth / (total + 1) * count,height);
				Animation.run(ANIMATION_TIME/nodeMap.size());
			}else{
				n.setLocation(MaxLevelPixelWidth / (total + 1) * count,height);				
			}
			
			
			
			if (getData(n.id).isMarked())
				n.setBackgroundColor(CONSTANT_MARKED);
			
			
			// FIND ALL THE NODES THAT THIS NODE CALLS AND MAKE CONNECTIONS
			List<Integer> setOfCallees = null;
			if (collapse_mode)
				setOfCallees = nodeDataMap.get(id).collapsedCallees;
			else 
				setOfCallees = nodeDataMap.get(id).callees;
			
			for (int val : setOfCallees) {
				if (nodeMap.get(val) != null)
					nodeMap.get(val).makeConnection(SWT.NONE, n, 
						nodeDataMap.get(val).called);
			}
			
			count++;
		}
		// DRAW THE NEXT LEVEL UP
		drawFromBottomToTop(level - 1, height - (3 * (int)(CONSTANT_VERTICAL_INCREMENT/scale)),
				MaxLevelPixelWidth);
	}

