	public IStatus executeParsing(){
		//Clear maps (in case a previous execution left values hanging)
		isValidFile = false;
		outNeighbours.clear();
		timeMap.clear();
		serialMap.clear();
		cumulativeTimeMap.clear();
		countMap.clear();
		
		try {
			BufferedReader buff = new BufferedReader(new FileReader(filePath));
			String tmp;
			while ((tmp = buff.readLine()) != null) {
				if (monitor.isCanceled()) {
					return Status.CANCEL_STATUS;
				}
				
				if (tmp.equals("PROBE_BEGIN")){ //$NON-NLS-1$
					isValidFile = true;
					graphText = buff.readLine();
					serialInfo = buff.readLine();
					timeInfo = buff.readLine();
					cumulativeTimeInfo = buff.readLine();
					markedNodes = buff.readLine();
				}
			}
			buff.close();
					
		} catch (IOException e) {
			launchFileDialogError();
			return Status.CANCEL_STATUS;
		}
		
		if (isValidFile){			
			for (int i = 0; i < graphText.length(); i++){
				if (monitor.isCanceled()) {
					return Status.CANCEL_STATUS;
				}
				//Check for valid nesting
				if (graphText.charAt(i) == '<'){
					validator++;
				}else if(graphText.charAt(i) == '>'){
					validator--;
				}
			}
			
			//If brackets don't match, check for potential exit call
			if (validator != 0){	
				while (validator >= 0){
					if (monitor.isCanceled()) {
						return Status.CANCEL_STATUS;
					}
					graphText+='>';
					validator--;
				}
			}
			
			if (timeInfo == null)
				return Status.CANCEL_STATUS;
			
			//Generate maps
			this.generateMaps();
			
			//Create a UIJob to handle the rest
			GraphUIJob uijob = new GraphUIJob(Messages.getString("StapGraphParser.5"), this); //$NON-NLS-1$
			uijob.schedule(); 
		}else{
			launchFileDialogError();
			return Status.CANCEL_STATUS;
		}

		
		return Status.OK_STATUS;
	}

