	/**
	 * Print with colour codes. Colour codes accepted in the form of ~(R,G,B)~,
	 * and apply for the rest of the line or until another code is encountered
	 * @param text
	 */
	public void prettyPrintln(String text) {
		Vector<StyleRange> styles = new Vector<StyleRange>();
		String[] txt = text.split("\\n"); //$NON-NLS-1$
		int lineOffset = 0;
		int inLineOffset;

		// txt[] contains text, with one entry for each new line
		for (int i = 0; i < txt.length; i++) {

			// Skip blank strings
			if (txt[i].length() == 0) {
				viewer.append(PluginConstants.NEW_LINE);
				continue;
			}

			// Search for colour codes, if none exist then continue
			String[] split_txt = txt[i].split("~\\("); //$NON-NLS-1$
			if (split_txt.length == 1) {
				viewer.append(split_txt[0]);
				viewer.append(PluginConstants.NEW_LINE);
				continue;
			}

			inLineOffset = 0;
			for (int k = 0; k < split_txt.length; k++) {
				// Skip blank substrings
				if (split_txt[k].length() == 0) {
					continue;
				}

				// Split for the number codes
				String[] coloursAndText = split_txt[k].split("\\)~"); //$NON-NLS-1$

				// If the string is properly formatted, colours should be length
				// 2
				// If it is not properly formatted, don't colour (just print)
				if (coloursAndText.length != 2) {
					for (int j = 0; j < coloursAndText.length; j++) {
						viewer.append(coloursAndText[j]);
						inLineOffset += coloursAndText[j].length();
					}
					continue;
				}

				// The first element in the array should contain the colours
				String[] colours = coloursAndText[0].split(","); //$NON-NLS-1$
				if (colours.length < 3) {
					continue;
				}

				// The second element in the array should contain the text
				viewer.append(coloursAndText[1]);

				// Create a colour based on the 3 integers (if there are any
				// more integers, just ignore)
				int R = new Integer(colours[0].replaceAll(" ", "")).intValue(); //$NON-NLS-1$ //$NON-NLS-2$
				int G = new Integer(colours[1].replaceAll(" ", "")).intValue(); //$NON-NLS-1$ //$NON-NLS-2$
				int B = new Integer(colours[2].replaceAll(" ", "")).intValue(); //$NON-NLS-1$ //$NON-NLS-2$

				if (R > 255) R = 255;
				if (G > 255) G = 255;
				if (B > 255) B = 255;

				if (R < 0) R = 0;
				if (G < 0) G = 0;
				if (B < 0) B = 0;

				Color newColor = new Color(display, R, G, B);

				// Find the offset of the current line
				lineOffset = viewer.getOffsetAtLine(viewer.getLineCount() - 1);

				// Create a new style that lasts no further than the length of
				// the line
				StyleRange newStyle = new StyleRange(lineOffset + inLineOffset,
						coloursAndText[1].length(), newColor, null);
				styles.addElement(newStyle);

				inLineOffset += coloursAndText[1].length();
			}

			viewer.append(PluginConstants.NEW_LINE);
		}

		// Create a new style range
		StyleRange[] s = new StyleRange[styles.size()];
		styles.copyInto(s);

		int cnt = viewer.getCharCount();

		// Using replaceStyleRanges with previousEnd, etc, effectively adds
		// the StyleRange to the existing set of Style Ranges (so we don't
		// waste time fudging with old style ranges that haven't changed)
		viewer.replaceStyleRanges(previousEnd, cnt - previousEnd, s);
		previousEnd = cnt;

		// Change focus and update
		viewer.setTopIndex(viewer.getLineCount() - 1);
		viewer.update();
	}

