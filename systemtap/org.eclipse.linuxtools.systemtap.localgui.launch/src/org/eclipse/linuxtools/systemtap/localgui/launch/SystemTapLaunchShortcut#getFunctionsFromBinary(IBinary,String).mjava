	/**
	 * Retrieves the names of all functions referenced by the binary. If searchForResource
	 * is true, this function will return all function names belonging to an element with name
	 * matching the String held by resourceToSearchFor. Otherwise it will create a dialog
	 * prompting the user to select from a list of files to profile, or select the only 
	 * available file if only one file is available.
	 * 
	 * 
	 * @param bin
	 * @return
	 */
	protected String getFunctionsFromBinary(IBinary bin, String targetResource) {
		String funcs = "";
		try {			
			ArrayList<ICContainer> list = new ArrayList<ICContainer>();
			TranslationUnitVisitor v = new TranslationUnitVisitor();
//			ASTTranslationUnitVisitor v  = new ASTTranslationUnitVisitor();
			
			for (ICElement b : bin.getCProject().getChildrenOfType(ICElement.C_CCONTAINER)) {
				ICContainer c = (ICContainer) b;
				
				for (ITranslationUnit tu : c .getTranslationUnits()) {
					if (searchForResource && tu.getElementName().contains(targetResource)) {
						tu.accept(v);
						funcs+=v.getFunctions();
						return funcs;
					} else {
						if (!list.contains(c))
							list.add(c);
//						if (!tu.getElementName().contains(".h")) {
//							list.add(tu);
//						}
					}
				}
				
				//Iterate down to all children, checking for more C_Containers
				while (c.getChildrenOfType(ICElement.C_CCONTAINER).size() > 0) {
					ICContainer e = null;
					for (ICElement d : c.getChildrenOfType(ICElement.C_CCONTAINER)) {
						e = (ICContainer) d;
						for (ITranslationUnit tu : e.getTranslationUnits()) {
							if (searchForResource && tu.getElementName().contains(targetResource)) {
								tu.accept(v);
								funcs+=(v.getFunctions());
								return funcs;
							} else {
								if (!list.contains(c))
									list.add(c);
//								if (!tu.getElementName().contains(".h")) {
//									list.add(tu);
//								}
							}
						}
					}
					c = e;
				}
			}
			
			int numberOfFiles = numberOfValidFiles(list.toArray());
			if (numberOfFiles == 1) {
				for (ICContainer c : list) {
					for (ITranslationUnit e : c.getTranslationUnits()) {
						if (e.getElementName().endsWith(".c") || 
								e.getElementName().endsWith(".cpp")) {
							e.accept(v);
							funcs+=v.getFunctions();
						}
					}
				}
			} else {
//				funcs.clear();
//				funcs.add("*");
				Object[] unitList = chooseUnit(list, numberOfFiles); 
//				if (unitList.length >= list.size()) {
//					//User selected all items, just add * instead of searching
//					funcs.clear();
//					funcs.add("*");
//				} else {
				if (unitList == null || unitList.length == 0) {
					return null;
				}
				for (Object obj : unitList) {
					if (obj instanceof ITranslationUnit) {
						ITranslationUnit tu = (ITranslationUnit) obj;
						tu.accept(v);
						funcs+=(v.getFunctions());
					} else {
						//Non-Translation unit object added to list, just probe *
						funcs = "*";
						return funcs;
					}
				}
					
			}
			
			return funcs;
			
		} catch (CModelException e) {
			e.printStackTrace();
		} catch (CoreException e) {
			e.printStackTrace();
		}
		
		return null;
	}

