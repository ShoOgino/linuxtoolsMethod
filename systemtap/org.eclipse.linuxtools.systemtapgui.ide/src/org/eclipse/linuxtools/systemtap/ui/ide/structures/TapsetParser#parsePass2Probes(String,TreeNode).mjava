	/**
	 * Parses the output generated from running stap -up2 on the list of probes. 
	 * Will update the probe alias tree with additional variables, as well as
	 * placing the type associated with the variable.
	 * @param s The entire output from running stap -up2 on the provided probeSet.
	 * @param probeSet The group of probes that the String s corresponds to
	 */
	private boolean parsePass2Probes(String s, TreeNode probeSet) {
		LogManager.logDebug("Start parseLevel2Probes: probeSet-" + probeSet, this);
		TreeNode tree = new TreeNode("", false);
		TreeNode probe = null;
		String[] probeLines = null;
		boolean variables = false;
		String line;
		
		if(s.contains("# probes"))
			probeLines = s.substring(s.indexOf("# probes")).split("\n");

		if(null == probeLines)
			return false;
		
		//Build Pass 2 tree
		for(int i=0; i<probeLines.length; i++) {
			line = probeLines[i].trim();
			
			if(line.startsWith("kernel.")) {
				probe = new TreeNode(line, false);
				tree.add(probe);
				//probe = lookupProbe(line, probeSet);
				variables = false;
			} else if(line.equals("# locals") && null != probe) {
				variables = true;
			} else if(null != probe && variables) {
				if(line.contains(":"))
					probe.add(new TreeNode(line, line.substring(0, line.lastIndexOf(":")).trim(), false));
			} else {
				probe = null;
			}
		}
		
		//Consolidate pass1 and pass2 trees
		int i, j, k, l;
		boolean matched;
		TreeNode one, two, oneC, twoC;
		for(i=0; i<probeSet.getChildCount(); i++) {
			for(j=0; j<tree.getChildCount(); j++) {
				one = probeSet.getChildAt(i);
				two = tree.getChildAt(j);

				if(probesMatch(one, two)) {
					for(l=0; l<two.getChildCount(); l++) {
						matched = false;
						twoC = two.getChildAt(l);
						for(k=0; k<one.getChildCount(); k++) {
							oneC = one.getChildAt(k);
							if(oneC.getData().toString().substring(0, oneC.getData().toString().indexOf(":")).
								equals(twoC.getData().toString().substring(0, twoC.getData().toString().indexOf(":")))) {
								oneC.setData(twoC.getData());
								matched = true;
							}
						}
						if(!matched)
							one.add(new TreeNode(twoC.getData(), twoC.toString(), false));
					}
				}
			}
		}
		
		tree.dispose();
		tree = null;
		return true;
	}

