	public void launch(ILaunchConfiguration config, String mode,
			ILaunch launch, IProgressMonitor m) throws CoreException {
		if (m == null) {
			m = new NullProgressMonitor();
		}

		SubMonitor monitor = SubMonitor.convert(m, Messages.getString("ValgrindLaunchConfigurationDelegate.Profiling_Local_CCPP_Application"), 10); //$NON-NLS-1$
		// check for cancellation
		if (monitor.isCanceled()) {
			return;
		}

		this.config = config;
		this.launch	= launch;
		try {
			command = getValgrindCommand();

			// find Valgrind binary if not already done
			IPath valgrindLocation = getPlugin().findValgrindLocation();

			monitor.worked(1);
			IPath exePath = verifyProgramPath(config);
			String[] arguments = getProgramArgumentsArray(config);
			File workDir = getWorkingDirectory(config);
			if (workDir == null) {
				workDir = new File(System.getProperty("user.home", ".")); //$NON-NLS-1$ //$NON-NLS-2$
			}

			// set output directory in config
			setOutputPath(config);
			outputPath = verifyOutputPath(config);
			// create/empty output directory
			createDirectory(outputPath);

			// tool that was launched
			toolID = getTool(config);
			// ask tool extension for arguments
			dynamicDelegate = getDynamicDelegate(toolID);
			String[] opts = getValgrindArgumentsArray(config);

			// set the default source locator if required
			setDefaultSourceLocator(launch, config);

			ArrayList<String> cmdLine = new ArrayList<String>(1 + arguments.length);
			cmdLine.add(valgrindLocation.toOSString());
			cmdLine.addAll(Arrays.asList(opts));
			cmdLine.add(exePath.toOSString());
			cmdLine.addAll(Arrays.asList(arguments));
			String[] commandArray = (String[]) cmdLine.toArray(new String[cmdLine.size()]);
			boolean usePty = config.getAttribute(ICDTLaunchConfigurationConstants.ATTR_USE_TERMINAL, ICDTLaunchConfigurationConstants.USE_TERMINAL_DEFAULT);
			monitor.worked(1);

			// Cleanup
			IHandlerService service = (IHandlerService) PlatformUI.getWorkbench().getService(IHandlerService.class);
			if (handlerActivation != null) {
				// remove old handler
				service.deactivateHandler(handlerActivation);
			}
			// remove any output from previous run
			ValgrindUIPlugin.getDefault().resetView();
			
			// check for cancellation
			if (monitor.isCanceled()) {
				return;
			}
			// call Valgrind
			command.execute(commandArray, getEnvironment(config), workDir, usePty);
			monitor.worked(3);
			process = DebugPlugin.newProcess(launch, command.getProcess(), renderProcessLabel(commandArray[0]));
			// set the command line used
			process.setAttribute(IProcess.ATTR_CMDLINE, command.getCommandLine());
			while (!process.isTerminated()) {
				Thread.sleep(100);
			}

			System.out.println("org.eclipse.debug.core.model.IProcess Exit Code: " + process.getExitValue());
			if (process.getExitValue() == 0) {
				// create launch summary string to distinguish this launch
				launchStr = createLaunchStr();

				// create view
				ValgrindUIPlugin.getDefault().createView(launchStr, toolID);
				monitor.worked(1);

				// pass off control to extender
				dynamicDelegate.handleLaunch(config, launch, monitor.newChild(3));

				// refresh view
				ValgrindUIPlugin.getDefault().refreshView();

				// show view
				ValgrindUIPlugin.getDefault().showView();
				monitor.worked(1);

				IHandler handler = new AbstractHandler() {
					public Object execute(ExecutionEvent event) throws ExecutionException {
						Display.getDefault().syncExec(new Runnable() {
							public void run() {
								Shell parent = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
								IWorkbenchWizard wizard = new ValgrindExportWizard();
								wizard.init(PlatformUI.getWorkbench(), null);
								
								WizardDialog dialog = new WizardDialog(parent, wizard);
								dialog.open();
							}							
						});
						
						return null;
					}					
				};
				handlerActivation = service.activateHandler(PluginConstants.EXPORT_CMD_ID, handler);
				
				getPlugin().setLaunchConfiguration(config);
				getPlugin().setLaunch(launch);
				// save results of launch to persistent storage
				//			saveState(monitor.newChild(2));
			}
			else {
				handleValgrindError();
			}
		} catch (IOException e) {
			abort(Messages.getString("ValgrindLaunchConfigurationDelegate.Error_starting_process"), e, ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR); //$NON-NLS-1$
			e.printStackTrace();
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			m.done();
		}
	}

