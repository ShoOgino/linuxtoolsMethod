    /**
     * Initializes the given line number ruler column from the preference store.
     */
    private void initialize() {
        final IPreferenceStore store = getPreferenceStore();
        if (store == null)
            return;

        // initial set up
        updateForegroundColor(store, fDelegate);
        updateBackgroundColor(store, fDelegate);

        updateLineNumbersVisibility(fDelegate);
        updateQuickDiffVisibility(fDelegate);
        updateCharacterMode(store, fDelegate);
        updateRevisionRenderingMode(store, fDelegate);
        updateRevisionAuthorVisibility(store, fDelegate);
        updateRevisionIdVisibility(store, fDelegate);

        Map<Object, AnnotationPreference> annotationPrefs = getAnnotationPreferenceMap();
        final AnnotationPreference changedPref = annotationPrefs
                .get("org.eclipse.ui.workbench.texteditor.quickdiffChange"); //$NON-NLS-1$
        final AnnotationPreference addedPref = annotationPrefs
                .get("org.eclipse.ui.workbench.texteditor.quickdiffAddition"); //$NON-NLS-1$
        final AnnotationPreference deletedPref = annotationPrefs
                .get("org.eclipse.ui.workbench.texteditor.quickdiffDeletion"); //$NON-NLS-1$
        updateChangedColor(changedPref, store, fDelegate);
        updateAddedColor(addedPref, store, fDelegate);
        updateDeletedColor(deletedPref, store, fDelegate);

        if (fDelegate != null)
            fDelegate.redraw();

        // listen to changes
        fDispatcher = new PropertyEventDispatcher(store);

        fDispatcher.addPropertyChangeListener(FG_COLOR_KEY, new IPropertyChangeListener() {
            @Override
            public void propertyChange(PropertyChangeEvent event) {
                updateForegroundColor(store, fDelegate);
                fDelegate.redraw();
            }
        });
        IPropertyChangeListener backgroundHandler = new IPropertyChangeListener() {
            @Override
            public void propertyChange(PropertyChangeEvent event) {
                updateBackgroundColor(store, fDelegate);
                fDelegate.redraw();
            }
        };
        fDispatcher.addPropertyChangeListener(BG_COLOR_KEY, backgroundHandler);
        fDispatcher.addPropertyChangeListener(USE_DEFAULT_BG_KEY, backgroundHandler);

        fDispatcher.addPropertyChangeListener(ST_KEY, new IPropertyChangeListener() {
            @Override
            public void propertyChange(PropertyChangeEvent event) {
                // only handle quick diff on/off information, but not ruler visibility (handled by
                // AbstractDecoratedTextEditor)

                updateLineNumbersVisibility(fDelegate);
            }
        });

        fDispatcher.addPropertyChangeListener(AbstractDecoratedTextEditorPreferenceConstants.QUICK_DIFF_CHARACTER_MODE,
                new IPropertyChangeListener() {
                    @Override
                    public void propertyChange(PropertyChangeEvent event) {
                        updateCharacterMode(store, fDelegate);
                    }
                });

        fDispatcher.addPropertyChangeListener(
                AbstractDecoratedTextEditorPreferenceConstants.REVISION_RULER_RENDERING_MODE,
                new IPropertyChangeListener() {
                    @Override
                    public void propertyChange(PropertyChangeEvent event) {
                        updateRevisionRenderingMode(store, fDelegate);
                    }
                });

        fDispatcher.addPropertyChangeListener(
                AbstractDecoratedTextEditorPreferenceConstants.REVISION_RULER_SHOW_AUTHOR,
                new IPropertyChangeListener() {
                    @Override
                    public void propertyChange(PropertyChangeEvent event) {
                        updateRevisionAuthorVisibility(store, fDelegate);
                    }
                });

        fDispatcher.addPropertyChangeListener(
                AbstractDecoratedTextEditorPreferenceConstants.REVISION_RULER_SHOW_REVISION,
                new IPropertyChangeListener() {
                    @Override
                    public void propertyChange(PropertyChangeEvent event) {
                        updateRevisionIdVisibility(store, fDelegate);
                    }
                });

        fDispatcher.addPropertyChangeListener(AbstractDecoratedTextEditorPreferenceConstants.QUICK_DIFF_ALWAYS_ON,
                new IPropertyChangeListener() {
                    @Override
                    public void propertyChange(PropertyChangeEvent event) {
                        updateQuickDiffVisibility(fDelegate);
                    }
                });

        if (changedPref != null) {
            fDispatcher.addPropertyChangeListener(changedPref.getColorPreferenceKey(), new IPropertyChangeListener() {
                @Override
                public void propertyChange(PropertyChangeEvent event) {
                    updateChangedColor(changedPref, store, fDelegate);
                    fDelegate.redraw();
                }
            });
        }
        if (addedPref != null) {
            fDispatcher.addPropertyChangeListener(addedPref.getColorPreferenceKey(), new IPropertyChangeListener() {
                @Override
                public void propertyChange(PropertyChangeEvent event) {
                    updateAddedColor(addedPref, store, fDelegate);
                    fDelegate.redraw();
                }
            });
        }
        if (deletedPref != null) {
            fDispatcher.addPropertyChangeListener(deletedPref.getColorPreferenceKey(), new IPropertyChangeListener() {
                @Override
                public void propertyChange(PropertyChangeEvent event) {
                    updateDeletedColor(deletedPref, store, fDelegate);
                    fDelegate.redraw();
                }
            });
        }
    }

