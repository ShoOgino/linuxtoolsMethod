	@Override
	public String mergeChangelog(String dateLine, String functionGuess,String defaultContent,
			IEditorPart changelog, String changeLogLocation, String fileLocation) {

		String fileDetail = formatFileDetail(changeLogLocation, fileLocation);
		IDocument changelog_doc = getDocument(changelog);
		String function = formatFunction(functionGuess);
		boolean multipleEntrySuccess = false;
		boolean forceNewEntry = false;
		String functionSpacer = " "; // $NON-NLS-1$
		if (function.equals(": ")) // $NON-NLS-1$
			functionSpacer = ""; // $NON-NLS-1$

		/* Fix Bz #366854.  Make sure that forceNewEntry is used only
		 * once and then cleared even when the ChangeLog is empty to start with.
		 */
		if(changelog instanceof ChangeLogEditor) {
			ChangeLogEditor editor = (ChangeLogEditor)changelog;
			forceNewEntry = editor.isForceNewLogEntry();
			editor.setForceNewLogEntry(false);
		}

		if (changelog_doc.getLength() > 0) {

			int offset_start = findChangeLogEntry(changelog_doc, dateLine);
			int offset_end = dateLine.length();
			boolean foundFunction = false;
			//if the prepare change action determines it requires a new entry, we force
			//a new entry by changing the offset_start and change the corresponding field
			//of the editor back to false to prevent subsequent function change log being
			//written to a new entry again.
			if (forceNewEntry)
				offset_start = -1;

			if (offset_start != -1) {
				int nextChangeEntry = findChangeLogPattern(changelog_doc,
						offset_start + dateLine.length());
				int functLogEntry = offset_start + dateLine.length();

				while (functLogEntry < nextChangeEntry) {
					int line_length = 0;
					String entry = ""; // $NON-NLS-1$
					try {
						line_length = changelog_doc
						.getLineOfOffset(functLogEntry);
						entry = changelog_doc.get(functLogEntry, changelog_doc
								.getLineLength(line_length));
					} catch (BadLocationException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					// Look to see if entry already exists for file (will be preceded by "*")
					if (entry.lastIndexOf("* " + fileDetail) > 0) {
						foundFunction = true;
						// Check for the case where the default content (e.g. new or removed file)
						// is being caught again because user has prepared the ChangeLog more than once.
						// In such a case, just return.  We don't need to repeat ourselves.
						if (defaultContent.length() > 0 && entry.lastIndexOf(defaultContent) > 0) {
								return ""; // $NON-NLS-1$
						}
						int nextFunctLoc = functLogEntry + fileDetail.length() + 2;
						String nextFunc = ""; // $NON-NLS-1$
						try {
							nextFunc = changelog_doc.get(nextFunctLoc,
									nextChangeEntry - nextFunctLoc);
						} catch (BadLocationException e1) {
							// TODO Auto-generated catch block
							e1.printStackTrace();
						}
						int foundFunc = nextFunc.indexOf("* "); // $NON-NLS-1$
						if (foundFunc > 0) {
							foundFunc--;
							try {
								while (changelog_doc.get(
										nextFunctLoc + foundFunc, 1).equals(
										"\t") // $NON-NLS-1$
										|| changelog_doc.get(
												nextFunctLoc + foundFunc, 1)
												.equals("\n")) { // $NON-NLS-1$
									foundFunc--;
								}
							} catch (BadLocationException e2) {
								// TODO Auto-generated catch block
								e2.printStackTrace();
							}
							functLogEntry = nextFunctLoc + foundFunc + 1;
							break;
						}

					}
					try {
						functLogEntry += changelog_doc
						.getLineLength(line_length);
					} catch (BadLocationException e1) {
						// TODO Auto-generated catch block
						e1.printStackTrace();
					}
				}
				if (functLogEntry >= nextChangeEntry) {
					functLogEntry = nextChangeEntry - 1;
					try {
						// Get rid of some potential lines containing whitespace only.
						functLogEntry = removeWhitespaceOnlyLines(changelog_doc, functLogEntry);
						while (changelog_doc.get(functLogEntry, 1).equals("\n")) // $NON-NLS-1$
							functLogEntry--;
					} catch (BadLocationException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					functLogEntry++;
				}

				if (offset_start != -1) {
					if (foundFunction) {
						try {
							if (!function.equals(": ")) // $NON-NLS-1$
								changelog_doc.replace(functLogEntry, 0, "\n" + TAB // $NON-NLS-1$
										+ function + " "); // $NON-NLS-1$
							else
								changelog_doc.replace(functLogEntry, 0, "\n" + TAB // $NON-NLS-1$
										);
						} catch (BadLocationException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						ITextEditor edit = (ITextEditor) changelog;
						if (!function.equals(": ")) // $NON-NLS-1$
							edit.selectAndReveal(functLogEntry + function.length()
									+ 3, 0);
						else
							edit.selectAndReveal(functLogEntry + function.length()
									, 0);
						multipleEntrySuccess = true;
					} else {
						try {
							changelog_doc.replace(offset_end, 0, TAB
									+ "* " + fileDetail + functionSpacer // $NON-NLS-1$
									+ function + functionSpacer + defaultContent + "\n"); //$NON-NLS-1$
						} catch (BadLocationException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}

						ITextEditor edit = (ITextEditor) changelog;
						edit.selectAndReveal(offset_end + fileDetail.length()
								+ function.length() +functionSpacer.length()*2 + 3 + defaultContent.length(), 0);
						multipleEntrySuccess = true;
					}

				}
			}
		}

		if (!multipleEntrySuccess) {
			try {
				if (changelog_doc.getLength() > 0)
					changelog_doc.replace(0, 0, "\n\n"); //$NON-NLS-1$
				changelog_doc.replace(0, 0, dateLine + TAB + "* " + fileDetail // $NON-NLS-1$
						+ functionSpacer+function+functionSpacer+defaultContent);

				ITextEditor edit = (ITextEditor) changelog;
				edit.selectAndReveal(dateLine.length() + fileDetail.length()
						+ function.length() + functionSpacer.length()*2 + 3 + defaultContent.length(), 0);
			} catch (BadLocationException e) {
				e.printStackTrace();

			}

		}

		return ""; // $NON-NLS-1$

	}

