    @Override
    public ICommandResult executeCommand(final String command, final IProgressMonitor monitor, final boolean checkReturnValue) throws ExecutionException {
        if (fIsConnected) {
            FutureTask<CommandResult> future = new FutureTask<>(new Callable<CommandResult>() {
                @Override
                public CommandResult call() throws IOException, CancellationException {
                    final ArrayList<String> result = new ArrayList<>();

                    synchronized (fHostShell) {
                        // Initialize return value which will be updated in isAliasEchoResult()
                        fReturnValue = 0;

                        int startAlias = fRandom.nextInt();
                        int endAlias = fRandom.nextInt();
                        fHostShell.writeToShell(formatShellCommand(command, startAlias, endAlias));

                        String nextLine;
                        boolean isStartFound = false;
                        while ((nextLine = fInputBufferReader.readLine()) != null) {

                            if (monitor.isCanceled()) {
                                flushInput();
                                throw new CancellationException();
                            }

                            // check if line contains echoed start alias
                            if (isAliasEchoResult(nextLine, startAlias, true)) {
                                isStartFound = true;
                                continue;
                            }

                            // check if line contains is the end mark-up. This will retrieve also
                            // the return value of the actual command.
                            if (isAliasEchoResult(nextLine, endAlias, false)) {
                                break;
                            }

                            // Ignore line if
                            // 1) start hasn't been found or
                            // 2) line is an echo of the command or
                            // 3) line is  an echo of the end mark-up
                            if (!isStartFound ||
                                    isCommandEcho(nextLine, command) ||
                                    nextLine.contains(getEchoResult(endAlias)))
                            {
                                continue;
                            }

                            // Now it's time add to the result
                            result.add(nextLine);
                        }

                        // Read any left over output
                        flushInput();

                        // Read error stream output when command failed.
                        if (fReturnValue != 0) {
                            while(fErrorBufferReader.ready()) {
                                if ((nextLine = fErrorBufferReader.readLine()) != null)  {
                                    result.add(nextLine);
                                }
                            }
                        }
                    }
                    return new CommandResult(fReturnValue, result.toArray(new String[result.size()]));
                }
            });

            fExecutor.execute(future);

            try {
                return future.get(ControlPreferences.getInstance().getCommandTimeout(), TimeUnit.SECONDS);
            } catch (java.util.concurrent.ExecutionException ex) {
                throw new ExecutionException(Messages.TraceControl_ExecutionFailure, ex);
            } catch (InterruptedException ex) {
                throw new ExecutionException(Messages.TraceControl_ExecutionCancelled, ex);
            } catch (TimeoutException ex) {
                throw new ExecutionException(Messages.TraceControl_ExecutionTimeout, ex);
            }
        }
        throw new ExecutionException(Messages.TraceControl_ShellNotConnected, null);
    }

