    /**
     * @param xmlBaseEvents
     *            a Node list of xml event element linked to a session
     * @param events
     *            list of event generated by the parsing of the xml event
     *            element
     * @throws ExecutionException
     *             when a raw event is not a complete/valid xml event
     */
    static void getEventInfo(NodeList xmlEvents, List<IEventInfo> events) throws ExecutionException {
        IEventInfo eventInfo = null;
        for (int i = 0; i < xmlEvents.getLength(); i++) {
            NodeList rawInfos = xmlEvents.item(i).getChildNodes();
            // Search for name
            if (xmlEvents.item(i).getNodeName().equalsIgnoreCase(MIStrings.EVENT)) {
                Node rawName = getFirstOf(rawInfos, MIStrings.NAME);
                if (rawName == null) {
                    throw new ExecutionException(Messages.TraceControl_MiMissingRequiredError);
                }

                eventInfo = new EventInfo(rawName.getTextContent());

                // Basic information
                for (int j = 0; j < rawInfos.getLength(); j++) {
                    Node infoNode = rawInfos.item(j);
                    switch (infoNode.getNodeName()) {
                    case MIStrings.TYPE:
                        eventInfo.setEventType(infoNode.getTextContent());
                        break;
                    case MIStrings.LOGLEVEL_TYPE:
                        eventInfo.setLogLevelType(LogLevelType.valueOfString(infoNode.getTextContent()));
                        break;
                    case MIStrings.LOGLEVEL:
                        eventInfo.setLogLevel(TraceLogLevel.valueOfString(infoNode.getTextContent()));
                        break;
                    case MIStrings.ENABLED:
                        eventInfo.setState(TraceEnablement.valueOfString(infoNode.getTextContent()));
                        break;
                    case MIStrings.FILTER:
                        // TODO
                        // See bug 334 http://bugs.lttng.org/issues/334 from
                        // LTTng
                        // For now we emulate the non-mi behavior and simply put
                        // "with filter"
                        eventInfo.setFilterExpression("with filter"); //$NON-NLS-1$
                        break;
                    case MIStrings.EXCLUSION:
                        // TODO: Currently not supported by tmf
                        // ExclusionS element is ignored
                        break;
                    default:
                        break;
                    }
                }

                boolean isProbeFunction = (eventInfo.getEventType().equals(TraceEventType.PROBE)) || (eventInfo.getEventType().equals(TraceEventType.FUNCTION));
                if (isProbeFunction) {
                    IProbeEventInfo probeEvent = new ProbeEventInfo(eventInfo);
                    eventInfo = probeEvent;
                    // get attributes
                    Node rawAttributes = getFirstOf(rawInfos, MIStrings.ATTRIBUTES);
                    if (rawAttributes == null) {
                        throw new ExecutionException(Messages.TraceControl_MiMissingRequiredError);
                    }

                    Node rawDataNode = null;
                    switch (probeEvent.getEventType()) {
                    case PROBE:
                        rawDataNode = getFirstOf(rawAttributes.getChildNodes(), MIStrings.PROBE_ATTRIBUTES);
                        break;
                    case FUNCTION:
                        rawDataNode = getFirstOf(rawAttributes.getChildNodes(), MIStrings.FUNCTION_ATTRIBUTES);
                        break;
                    case SYSCALL:
                    case TRACEPOINT:
                    case UNKNOWN:
                    default:
                        throw new ExecutionException(Messages.TraceControl_MiInvalidElementError);
                    }

                    if (rawDataNode == null) {
                        throw new ExecutionException(Messages.TraceControl_MiInvalidElementError);
                    }

                    // Extract info
                    NodeList rawDatas = rawDataNode.getChildNodes();
                    for (int j = 0; j < rawDatas.getLength(); j++) {
                        Node rawData = rawDatas.item(j);
                        switch (rawData.getNodeName()) {
                        case MIStrings.SYMBOL_NAME:
                            probeEvent.setSymbol(rawData.getTextContent());
                            break;
                        case MIStrings.ADDRESS:
                            probeEvent.setAddress(rawData.getTextContent());
                            break;
                        case MIStrings.OFFSET:
                            probeEvent.setOffset(rawData.getTextContent());
                            break;
                        default:
                            break;
                        }
                    }
                }

                // Syscalls does not have name.
                // Let put one to make sure this is user friendly via UI
                if (eventInfo.getEventType().equals(TraceEventType.SYSCALL)) {
                    eventInfo.setName(TraceEventType.SYSCALL.getInName());
                }

                // Add the event
                events.add(eventInfo);
            }
        }
    }

