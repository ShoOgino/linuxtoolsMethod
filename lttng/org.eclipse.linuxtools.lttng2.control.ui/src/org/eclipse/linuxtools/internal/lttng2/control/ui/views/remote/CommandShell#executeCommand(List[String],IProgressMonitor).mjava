    @Override
    public ICommandResult executeCommand(final List<String> command, final IProgressMonitor monitor) throws ExecutionException {
        if (fConnection.isOpen()) {
            FutureTask<CommandResult> future = new FutureTask<>(new Callable<CommandResult>() {
                @Override
                public CommandResult call() throws IOException, InterruptedException {
                    if (monitor == null || !monitor.isCanceled()) {
                        final boolean wrapCommand =
                                RSE_ADAPTER_ID.equals(fConnection.getRemoteServices().getId())
                                && isBackedByShell();
                        IRemoteProcess process = startRemoteProcess(wrapCommand, command);
                        InputReader stdout = new InputReader(process.getInputStream());
                        InputReader stderr = new InputReader(process.getErrorStream());

                        try {
                            stdout.waitFor(monitor);
                            stderr.waitFor(monitor);
                            if (monitor == null || !monitor.isCanceled()) {
                                return createResult(wrapCommand, process.waitFor(), stdout.toString(), stderr.toString());
                            }
                        } catch (OperationCanceledException e) {
                        } catch (InterruptedException e) {
                            return new CommandResult(1, new String[0], new String[] {e.getMessage()});
                        } finally {
                            stdout.stop();
                            stderr.stop();
                            process.destroy();
                        }
                    }
                    return new CommandResult(1, new String[0], new String[] {"cancelled"}); //$NON-NLS-1$
                }
            });

            fExecutor.execute(future);

            try {
                return future.get(ControlPreferences.getInstance().getCommandTimeout(), TimeUnit.SECONDS);
            } catch (java.util.concurrent.ExecutionException ex) {
                throw new ExecutionException(Messages.TraceControl_ExecutionFailure, ex);
            } catch (InterruptedException ex) {
                throw new ExecutionException(Messages.TraceControl_ExecutionCancelled, ex);
            } catch (TimeoutException ex) {
                throw new ExecutionException(Messages.TraceControl_ExecutionTimeout, ex);
            } finally {
                future.cancel(true);
            }
        }
        throw new ExecutionException(Messages.TraceControl_ShellNotConnected, null);
    }

