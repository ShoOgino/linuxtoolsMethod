    private void buildEntry(Element entryElement, XmlEntry parentEntry, int baseQuark) {
        /* Get the attribute string to display */
        String path = entryElement.getAttribute(TmfXmlUiStrings.PATH);
        if (path.isEmpty()) {
            path = TmfXmlStrings.WILDCARD;
        }

        /*
         * Make sure the XML element has either a display attribute or entries,
         * otherwise issue a warning
         */

        List<Element> displayElements = XmlUtils.getChildElements(entryElement, TmfXmlUiStrings.DISPLAY_ELEMENT);
        List<Element> entryElements = XmlUtils.getChildElements(entryElement, TmfXmlUiStrings.ENTRY_ELEMENT);

        if (displayElements.isEmpty() && entryElements.isEmpty()) {
            Activator.logWarning(String.format("XML view: entry for %s should have either a display element or entry elements", path)); //$NON-NLS-1$
            return;
        }

        ITmfStateSystem ss = parentEntry.getStateSystem();

        /* Get the list of quarks to process with this path */
        String[] paths = path.split(SPLIT_STRING);
        int i = 0;
        List<Integer> quarks = Collections.singletonList(baseQuark);

        try {
            while (i < paths.length) {
                List<Integer> subQuarks = new LinkedList<>();
                /* Replace * by .* to have a regex string */
                String name = paths[i].replaceAll("\\*", ".*"); //$NON-NLS-1$ //$NON-NLS-2$
                for (int relativeQuark : quarks) {
                    for (int quark : ss.getSubAttributes(relativeQuark, false, name)) {
                        subQuarks.add(quark);
                    }
                }
                quarks = subQuarks;
                i++;
            }

            /* Process each quark */
            XmlEntry currentEntry = parentEntry;
            Element displayElement = null;
            Map<String, XmlEntry> entryMap = new HashMap<>();
            if (!displayElements.isEmpty()) {
                displayElement = displayElements.get(0);
            }
            for (int quark : quarks) {
                currentEntry = parentEntry;
                /* Process the current entry, if specified */
                if (displayElement != null) {
                    currentEntry = processEntry(entryElement, displayElement, parentEntry, quark, ss);
                    entryMap.put(currentEntry.getId(), currentEntry);
                }
                /* Process the children entry of this entry */
                for (Element subEntryEl : entryElements) {
                    buildEntry(subEntryEl, currentEntry, quark);
                }
            }
            if (!entryMap.isEmpty()) {
                buildTree(entryMap, parentEntry);
            }
        } catch (AttributeNotFoundException e) {
        }
    }

