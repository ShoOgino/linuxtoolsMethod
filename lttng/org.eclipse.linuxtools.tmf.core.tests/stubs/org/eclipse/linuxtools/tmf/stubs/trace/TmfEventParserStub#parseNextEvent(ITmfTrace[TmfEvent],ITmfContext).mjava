    @Override
	@SuppressWarnings("unchecked")
	public ITmfEvent parseNextEvent(ITmfTrace<TmfEvent> eventStream, ITmfContext context) throws IOException {

        if (! (eventStream instanceof TmfTraceStub)) {
            return null;
        }

       	// Highly inefficient...
       	RandomAccessFile stream = ((TmfTraceStub) eventStream).getStream();
//       	String name = eventStream.getName();
//       	name = name.substring(name.lastIndexOf('/') + 1);

       	// no need to use synchronized since it's already cover by the calling method
       	
       	long location = 0;
       	if (context != null)
       	    location = ((TmfLocation<Long>) (context.getLocation())).getLocation();
       	stream.seek(location);

       	try {
       	    long ts        = stream.readLong();
       	    String source  = stream.readUTF();
       	    String type    = stream.readUTF();
       	    Integer reference  = stream.readInt();
       	    int typeIndex  = Integer.parseInt(type.substring(typePrefix.length()));
       	    String[] fields = new String[typeIndex];
       	    for (int i = 0; i < typeIndex; i++) {
       	        fields[i] = stream.readUTF();
       	    }

       	    StringBuffer content = new StringBuffer("[");
       	    if (typeIndex > 0) {
       	        content.append(fields[0]);
       	    }
       	    for (int i = 1; i < typeIndex; i++) {
       	        content.append(", ").append(fields[i]);
       	    }
       	    content.append("]");

            TmfEventField root = new TmfEventField(ITmfEventField.ROOT_FIELD_ID, content.toString());
       	    ITmfEvent event = new TmfEvent(eventStream,
       	            new TmfTimestamp(ts, -3, 0),     // millisecs
       	            source, fTypes[typeIndex], root, reference.toString());
       	    return event;
       	} catch (EOFException e) {
       	}
        return null;
    }

