    public static void main(final String[] args) {

        try {
            // OUr experiment will contains ONE trace
            @SuppressWarnings("unchecked")
            final
            ITmfTrace<CtfTmfEvent>[] traces = new ITmfTrace[1];
            traces[0] = new CtfTmfTrace();
            traces[0].initTrace(null, TRACE_PATH, CtfTmfEvent.class);
            // Create our new experiment
            fExperiment = new TmfExperiment<CtfTmfEvent>(CtfTmfEvent.class, "Headless", traces);

            // Create a new time range from -infinity to +infinity
            // That way, we will get "everything" in the trace
            final CtfTmfTimestamp ts1 = new CtfTmfTimestamp(Long.MIN_VALUE);
            final CtfTmfTimestamp ts2 = new CtfTmfTimestamp(Long.MAX_VALUE);
            final TmfTimeRange tmpRange = new TmfTimeRange(ts1, ts2);

            // We will issue a request for each "pass".
            // TMF will then process them synchonously
            RequestBenchmark request = null;
            for (int x = 0; x < NB_OF_PASS; x++) {
                request = new RequestBenchmark(CtfTmfEvent.class, tmpRange,
                        Integer.MAX_VALUE);
                fExperiment.sendRequest(request);
                nbPassDone++;
            }
            prev = System.nanoTime();
        } catch (final NullPointerException e) {
            // Silently dismiss Null pointer exception
            // The only way to "finish" the threads in TMF is by crashing them
            // with null
        } catch (final Exception e) {
            e.printStackTrace();
        }

    }

