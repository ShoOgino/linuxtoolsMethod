    /**
     * Test concurrent signals. Verify that they are handled one after each
     * other.
     */
    @Test
    public void testConcurrentSignals() {

        TestSignalHandlerNested signalResender = new TestSignalHandlerNested();
        TestSignalHandler signalReceiver = new TestSignalHandler(false, null);

        /*
         * Test of synchronization of signal manager.
         *
         * The order of received signals is either set of signals triggered by
         * thread1 before set of signals triggered by thread2 or the other way
         * around.
         *
         * If both received sets were interleaved then the synchronization of
         * the signal manager would be not working.
         */

        final Class<?>[] expectedOrder1 = new Class[] {
                TestSignal2.class, TestSignal4.class, TestSignal3.class, TestSignal1.class, // signals triggered by thread 1
                TestSignal4.class // signal triggered by thread2
        };

        final Class<?>[] expectedOrder2 = new Class[] {
                TestSignal4.class, // signal triggered by thread2
                TestSignal2.class, TestSignal4.class, TestSignal3.class, TestSignal1.class // signals triggered by thread 1
        };

        /*
         *  Run it multiple times so that both expected order are triggered
         */
        try {
            for (int k = 0; k < 10; k++) {
                // Latch to ensure that both threads are started
                final CountDownLatch startLatch = new CountDownLatch(2);
                // Latch to ensure that signals are send roughly at the same time
                final CountDownLatch sendLatch = new CountDownLatch(1);
                // Latch to ensure that both treads are finished
                final CountDownLatch endLatch = new CountDownLatch(2);

                signalReceiver.receivedSignals.clear();

                Thread senderThread1 = new Thread() {
                    @Override
                    public void run() {
                        startLatch.countDown();
                        try {
                            sendLatch.await();
                        } catch (InterruptedException e) {
                        }
                        signalSender.sendSignal(new TestSignal1(signalSender));
                        endLatch.countDown();
                    }
                };

                Thread senderThread2 = new Thread() {
                    @Override
                    public void run() {
                        startLatch.countDown();
                        try {
                            sendLatch.await();
                        } catch (InterruptedException e) {
                        }
                        signalSender.sendSignal(new TestSignal4(signalSender));
                        endLatch.countDown();
                    }
                };

                senderThread1.start();
                senderThread2.start();
                try {
                    startLatch.await();
                } catch (InterruptedException e) {
                }
                sendLatch.countDown();

                try {
                    endLatch.await();
                } catch (InterruptedException e) {
                }

                assertEquals(expectedOrder1.length, signalReceiver.receivedSignals.size());
                boolean pass = true;
                for (int i = 0; i < expectedOrder1.length; i++) {
                    if (!signalReceiver.receivedSignals.get(i).getClass().equals(expectedOrder1[i])) {
                        pass = false;
                        break;
                    }
                }

                if (!pass) {
                    for (int i = 0; i < expectedOrder2.length; i++) {
                        if (!signalReceiver.receivedSignals.get(i).getClass().equals(expectedOrder2[i])) {
                            fail("Concurrent signal test failure!");
                        }
                    }
                }
            }
        } finally {
            // Make sure that handlers are disposed in any case (success or not success)
            signalResender.dispose();
            signalReceiver.dispose();
        }
    }

