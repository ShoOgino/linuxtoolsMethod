    @SuppressWarnings("nls")
    private void processEvent(CtfTmfEvent event) {
        currentEvent = event;
        ITmfEventField content = event.getContent();
        String eventName = event.getType().getName();

        long ts = event.getTimestamp().getValue();
        int quark;
        ITmfStateValue value;
        Integer eventCpu = event.getCPU();
        Integer currentCPUNode, currentThreadNode, tidNode;

        /* Adjust the current nodes Vectors if we see a new CPU in an event */
        if (eventCpu >= currentCPUNodes.size()) {
            /* We need to add this node to the vector */
            for (Integer i = currentCPUNodes.size(); i < eventCpu + 1; i++) {
                quark = ss.getQuarkAbsoluteAndAdd("CPUs", i.toString());
                currentCPUNodes.add(quark);

                quark = ss.getQuarkAbsoluteAndAdd("Threads", "unknown");
                currentThreadNodes.add(quark);
            }
        }

        currentCPUNode = currentCPUNodes.get(eventCpu);
        currentThreadNode = currentThreadNodes.get(eventCpu);
        assert (currentCPUNode != null);
        assert (currentThreadNode != null);

        try {
            /*
             * Feed event to the history system if it's known to cause a state
             * transition See:
             * https://projectwiki.dorsal.polymtl.ca/index.php/State_transitions
             */
            switch (getEventIndex(eventName)) {

            case 1: // "exit_syscall":
                /* Fields: int64 ret */
                /* Pop "syscall" from the Exec_mode_stack */
                quark = ss.getQuarkRelativeAndAdd(currentThreadNode,
                        "Exec_mode_stack");
                try {
                    ss.popAttribute(ts, quark);
                } catch (AttributeNotFoundException e1) {
                    /*
                     * meh, can happen if we're missing events, we'll just
                     * silently ignore it.
                     */
                    System.err.println(event.getTimestamp()
                            + " Popping empty attribute: " + e1.getMessage()); //$NON-NLS-1$
                }
                break;

            case 2: // "irq_handler_entry":
                /* Fields: int32 irq, string name */
                Integer irqId = ((Long) content.getField("irq").getValue()).intValue();

                /* Push the IRQ to the CPU's IRQ_stack */
                quark = ss.getQuarkRelativeAndAdd(currentCPUNode, "IRQ_stack");
                value = TmfStateValue.newValueInt(irqId);
                ss.pushAttribute(ts, value, quark);

                /* Change the status of the running process to interrupted */
                quark = ss.getQuarkRelativeAndAdd(currentThreadNode, "Status");
                value = TmfStateValue.newValueInt(STATE_PROCESS_STATUS_WAIT_CPU);
                ss.modifyAttribute(ts, value, quark);
                break;

            case 3: // "irq_handler_exit":
                /* Fields: int32 irq, int32 ret */
                int stackDepth = 0;

                /* Pop the IRQ from the CPU's IRQ_stack */
                quark = ss.getQuarkRelativeAndAdd(currentCPUNode, "IRQ_stack");
                try {
                    ss.popAttribute(ts, quark);
                } catch (AttributeNotFoundException e1) {
                    System.err.print(event.getTimestamp()
                            + " Popping empty attribute: " + e1.getMessage());
                }

                /*
                 * If this was the last IRQ on the stack, set the process back
                 * to running
                 */
                /* 'quark' should still be valid */
                try {
                    stackDepth = ss.queryOngoingState(quark).unboxInt();
                } catch (StateValueTypeException e) {
                    /* IRQ_stack SHOULD be of int type, this shouldn't happen */
                    e.printStackTrace();
                }
                if (stackDepth == 0) {
                    quark = ss.getQuarkRelativeAndAdd(currentThreadNode,
                            "Status");
                    value = TmfStateValue.newValueInt(STATE_PROCESS_STATUS_RUN);
                    ss.modifyAttribute(ts, value, quark);
                }
                break;

            case 4: // "softirq_entry":
                /* Fields: int32 vec */
                break;

            case 5: // "softirq_exit":
                /* Fields: int32 vec */
                break;

            case 6: // "softirq_raise":
                /* Fields: int32 vec */
                break;

            case 7: // "sched_switch":
                /*
                 * Fields: string prev_comm, int32 prev_tid, int32 prev_prio,
                 * int64 prev_state, string next_comm, int32 next_tid, int32
                 * next_prio
                 */

                // prev_comm doesn't seem to get populated...
                String prevProcessName = (String) content.getField("prev_comm").getValue();
                Integer prevTid = ((Long) content.getField("prev_tid").getValue()).intValue();
                Long prevState = (Long) content.getField("prev_state").getValue();

                String nextProcessName = (String) content.getField("next_comm").getValue();
                Integer nextTid = ((Long) content.getField("next_tid").getValue()).intValue();

                /* Update the name of the process going out (if needed) */
                quark = ss.getQuarkRelativeAndAdd(currentThreadNode,
                        "Exec_name");
                value = TmfStateValue.newValueString(prevProcessName);
                ss.updateOngoingState(value, quark);

                /* Update the currentThreadNodes pointer */
                Integer newCurrentThreadNode = ss.getQuarkAbsoluteAndAdd(
                        "Threads", nextTid.toString());
                currentThreadNodes.set(eventCpu, newCurrentThreadNode);

                /* Set the status of the new scheduled process */
                quark = ss.getQuarkRelativeAndAdd(newCurrentThreadNode,
                        "Status");
                value = TmfStateValue.newValueInt(STATE_PROCESS_STATUS_RUN);
                ss.modifyAttribute(ts, value, quark);

                /* Set the exec name of the new process */
                quark = ss.getQuarkRelativeAndAdd(newCurrentThreadNode,
                        "Exec_name");
                value = TmfStateValue.newValueString(nextProcessName);
                ss.modifyAttribute(ts, value, quark);

                /* Set the status of the process that got scheduled out */
                quark = ss.getQuarkAbsoluteAndAdd("Threads",
                        prevTid.toString(), "Status");
                value = TmfStateValue.newValueInt(prevState.intValue());
                ss.modifyAttribute(ts, value, quark);

                /* Set the current scheduled process on the relevant CPU */
                quark = ss.getQuarkRelativeAndAdd(currentCPUNode,
                        "Current_thread");
                value = TmfStateValue.newValueInt(nextTid);
                ss.modifyAttribute(ts, value, quark);
                break;

            case 8: // "sched_process_fork":
                /*
                 * Fields: string parent_comm, int32 parent_tid, string
                 * child_comm, int32 child_tid
                 */

                // String parentProcessName = (String)
                // event.getFieldValue("parent_comm");
                String childProcessName = (String) content.getField("child_comm").getValue();
                // assert ( parentProcessName.equals(childProcessName) );

                Integer parentTid = ((Long) content.getField("parent_tid").getValue()).intValue();
                Integer childTid = ((Long) content.getField("child_tid").getValue()).intValue();

                tidNode = ss.getQuarkAbsoluteAndAdd("Threads",
                        childTid.toString());

                /*
                 * Add the new process with its known TID, PPID, and initial
                 * Exec_name
                 */
                quark = ss.getQuarkRelativeAndAdd(tidNode, "PPID");
                value = TmfStateValue.newValueInt(parentTid);
                ss.modifyAttribute(ts, value, quark);

                /* Set the new process' exec_name */
                quark = ss.getQuarkRelativeAndAdd(tidNode, "Exec_name");
                value = TmfStateValue.newValueString(childProcessName);
                ss.modifyAttribute(ts, value, quark);
                break;

            case 9: // "sched_process_exit":
                /* Fields: string comm, int32 tid, int32 prio */
                String processName = (String) content.getField("comm").getValue();
                Integer tid = ((Long) content.getField("tid").getValue()).intValue();

                /* Update the process' name, if we don't have it */
                quark = ss.getQuarkAbsoluteAndAdd("Threads", tid.toString(),
                        "Exec_name");
                value = TmfStateValue.newValueString(processName);
                ss.updateOngoingState(value, quark);

                /*
                 * Remove the process and all its sub-attributes from the
                 * current state
                 */
                quark = ss.getQuarkAbsoluteAndAdd("Threads", tid.toString());
                ss.removeAttribute(ts, quark);
                break;

            case 10: // "sched_process_free":
                /* Fields: string comm, int32 tid, int32 prio */
                break;

            // FIXME Not available with CTF. Use event context?
            // case LTT_EVENT_EXEC:
            // filename = new String((byte[]) event.getField(0));
            //
            // /* Change the Exec_name of the process */
            // quark = ss.getQuarkRelativePath(true, currentThreadNode,
            // "Exec_name");
            // ss.modifyAttribute(ts, filename, quark);
            // break;

            default:
                /* Other event types not covered by the main switch */

                if (eventName.startsWith("sys_")
                        || eventName.startsWith("compat_sys_")) {
                    /*
                     * This is a replacement for the old sys_enter event. Now
                     * syscall names are listed into the event type
                     */

                    /*
                     * Push the syscall name on the Exec_mode_stack of the
                     * relevant PID
                     */
                    quark = ss.getQuarkRelativeAndAdd(currentThreadNode,
                            "Exec_mode_stack");
                    value = TmfStateValue.newValueString(eventName);
                    ss.pushAttribute(ts, value, quark);
                }

                break;
            } // End of switch

            /*
             * Statistics
             */

            /* Nb of events total */
            try {
                quark = ss.getQuarkAbsoluteAndAdd("Stats", "Event_types",
                        eventName);
                ss.incrementAttribute(ts, quark);

                // /* Nb of events per CPU */
                // ss.incrementAttribute(ts,
                // ss.getAttributeQuarkAndAdd(currentCPUNode, "Stats",
                // "Event_types", eventType.toString()));
                //
                // /* Nb of events per process */
                // ss.incrementAttribute(ts,
                // ss.getAttributeQuarkAndAdd(currentThreadNode, "Stats",
                // "Event_types", eventType.toString()));

            } catch (StateValueTypeException sve) {
                /*
                 * Here's hoping we don't have string values in statistics
                 * attributes...
                 */
                sve.printStackTrace();
            }

            // end of big non-indented try
        } catch (AttributeNotFoundException ae) {
            /*
             * This would indicate a problem with the logic of the manager here,
             * so it shouldn't happen.
             */
            ae.printStackTrace();

        } catch (TimeRangeException tre) {
            /*
             * This would happen if the events in the trace aren't ordered
             * chronologically, which should never be the case ...
             */
            System.err.println("TimeRangeExcpetion caught in the state system's event manager.");
            System.err.println("Are the events in the trace correctly ordered?");
            tre.printStackTrace();

        } catch (StateValueTypeException sve) {
            /*
             * This would happen if we were trying to push/pop attributes not of
             * type integer. Which, once again, should never happen.
             */
            sve.printStackTrace();
        }

    }

