	/*
	 * (non-Javadoc)
	 * 
	 * @see org.eclipse.linuxtools.lttng.state.trace.IStateTraceManager#
	 * restoreCheckPointByTimestamp
	 * (org.eclipse.linuxtools.tmf.event.TmfTimestamp)
	 */
	@Override
	@SuppressWarnings("unchecked")
	public TmfCheckpoint restoreCheckPointByTimestamp(ITmfTimestamp eventTime) {
		TmfTimeRange experimentRange = fExperiment.getTimeRange();
		TmfCheckpoint checkpoint = new TmfCheckpoint(fTrace.getStartTime(), new TmfLocation<Long>(0L));

		// The GUI can have time limits higher than this log, since GUI can
		// handle multiple logs. Ignore special null value of experiment time range.
        if ((eventTime.getValue() < 0) || 
                (!experimentRange.equals(TmfTimeRange.NULL_RANGE) && (eventTime.getValue() > experimentRange.getEndTime().getValue()))) {
			return null;
		}

		// The GUI can have time limits lower than this trace, since experiment
		// can handle multiple traces
		if ((eventTime.getValue() < fTrace.getStartTime().getValue())) {
			eventTime = fTrace.getStartTime();
		}

	    LttngTraceState traceState;
		synchronized (fCheckPointsLock) {
		    Collections.sort(timestampCheckpointsList);
		    // Initiate the compare with a checkpoint containing the target time
		    // stamp to find
		    int index = Collections.binarySearch(timestampCheckpointsList, new TmfCheckpoint(eventTime,
		            new TmfLocation<Long>(0L)));
		    // adjust index to round down to earlier checkpoint when exact match
		    // not
		    // found
		    index = getPrevIndex(index);

		    if (index == 0) {
		        // No checkpoint restore is needed, start with a brand new
		        // TraceState
		        traceState = StateModelFactory.getStateEntryInstance(this);
		    } else {

		        // Useful CheckPoint found
		        checkpoint = timestampCheckpointsList.get(index);
		        // get the location associated with the checkpoint
		        TmfLocation<Long> location = (TmfLocation<Long>) checkpoint.getLocation();
		        // reference a new copy of the checkpoint template
		        traceState = stateCheckpointsList.get(location.getLocation()).clone();
		    }

		}

		// Restore the stored traceState
		synchronized (fStateModelLock) {
			fStateModel = traceState;
		}

		return checkpoint;
	}

