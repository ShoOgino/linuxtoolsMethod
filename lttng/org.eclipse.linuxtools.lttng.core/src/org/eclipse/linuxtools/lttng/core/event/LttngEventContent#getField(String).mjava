    /**
     * Parse a single field from its given name.<p>
     * 
     * @return  The parsed field or null.
     * 
     * @see @see org.eclipse.linuxtools.lttng.event.LttngEventField
     */
    @Override
    public synchronized LttngEventField getField(String name) {

        // Check for generic table header fields
        if (name.equals(LttngEventType.CONTENT_LABEL) || name.equals(FIELD_ID_CONTENT)) {
            return new LttngEventField(this, toString());
        } else if (name.equals(LttngEventType.MARKER_LABEL) || name.equals(FIELD_ID_TYPE)) {
            return new LttngEventField(this, fParentEvent.getType().getId());
        } else if (name.equals(LttngEventType.TRACE_LABEL) || name.equals(FIELD_ID_REFERENCE)) {
            return new LttngEventField(this, fParentEvent.getReference());
        } else if (name.equals(LttngEventType.TIMESTAMP_LABEL) || name.equals(FIELD_ID_TIMESTAMP)) {
            return new LttngEventField(this, fParentEvent.getTimestamp().toString());
        } else if (name.equals(FIELD_ID_SOURCE)) {
            return new LttngEventField(this, fParentEvent.getSource());
        }

    	// *** VERIFY ***
        // Should we check if the field exists in LttngType before parsing? 
        // It could avoid calling parse for non-existent fields but would waste some cpu cycle on check?
        LttngEventField returnedField = fFieldsMap.get(name);
        
        if ( returnedField == null ) {
            // *** VERIFY ***
            // Should we really make sure we didn't get null before creating/inserting a field?
        	JniEvent tmpEvent = ((LttngEvent)getEvent()).convertEventTmfToJni();
        	
        	if ( tmpEvent != null) {
	        	Object newValue =  tmpEvent.parseFieldByName(name);
	            
	            if ( newValue!= null ) {
	                returnedField = new LttngEventField(this, name, newValue);
	                fFieldsMap.put(name, returnedField );
	            }
        	}
        }
        
        return returnedField;
    }

