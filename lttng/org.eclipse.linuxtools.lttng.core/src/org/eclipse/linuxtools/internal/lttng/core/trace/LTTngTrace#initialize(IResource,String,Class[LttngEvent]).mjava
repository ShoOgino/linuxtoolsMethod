    @SuppressWarnings({ "unchecked", "rawtypes" })
    @Override
    protected synchronized void initialize(final IResource resource, final String path, final Class<LttngEvent> eventType)
            throws TmfTraceException {
        try {
            currentJniTrace = JniTraceFactory.getJniTrace(path, traceLibPath, SHOW_LTT_DEBUG_DEFAULT);
        } catch (final Exception e) {
            throw new TmfTraceException(e.getMessage());
        }

        // Export all the event types from the JNI side
        traceTypes = new HashMap<Integer, LttngEventType>();
        traceTypeNames = new Vector<Integer>();
        initialiseEventTypes(currentJniTrace);

        // Build the re-used event structure
        eventTimestamp = new LttngTimestamp();
        eventSource = ""; //$NON-NLS-1$
        this.eventType = new LttngEventType();
        eventContent = new LttngEventContent(currentLttngEvent);
        eventReference = getName();

        // Create the skeleton event
        currentLttngEvent = new LttngEvent(this, eventTimestamp, eventSource, this.eventType, eventContent,
                eventReference, null);

        // Create a new current location
        previousLocation = new LttngLocation();

        // Set the currentEvent to the eventContent
        eventContent.setEvent(currentLttngEvent);

        fParser = (ITmfEventParser) this;
        fCacheSize = CHECKPOINT_PAGE_SIZE;
 
        // // Bypass indexing if asked
        // if ( bypassIndexing == false ) {
        // indexTrace(true);
        // }
        // else {
        // Even if we don't have any index, set ONE checkpoint
        // fCheckpoints.add(new TmfCheckpoint(new LttngTimestamp(0L) , new
        // LttngLocation() ) );

        initializeStreamingMonitor();
    }

