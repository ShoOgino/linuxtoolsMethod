    private void initializeStreamingMonitor() {
        final JniTrace jniTrace = getCurrentJniTrace();
        if (jniTrace == null
                || (!jniTrace.isLiveTraceSupported() || !LiveTraceManager.isLiveTrace(jniTrace.getTracepath()))) {
            // Set the time range of the trace
            final ITmfContext context = seekEvent(0);
            final LttngEvent event = getNext(context);
            final LttngTimestamp startTime = new LttngTimestamp(event.getTimestamp());
            final LttngTimestamp endTime = new LttngTimestamp(currentJniTrace.getEndTime().getTime());
            setTimeRange(new TmfTimeRange(startTime, endTime));
            final TmfTraceUpdatedSignal signal = new TmfTraceUpdatedSignal(this, this, getTimeRange());
            broadcast(signal);
            return;
        }

        // Set the time range of the trace
        final ITmfContext context = seekEvent(0);
        final LttngEvent event = getNext(context);
        setEndTime(TmfTimestamp.BIG_BANG);
        final long startTime = event != null ? event.getTimestamp().getValue() : TmfTimestamp.BIG_BANG.getValue();
        setStreamingInterval(LTTNG_STREAMING_INTERVAL);

        final Thread thread = new Thread("Streaming Monitor for trace " + getName()) { //$NON-NLS-1$

            LttngTimestamp safeTimestamp = null;
            TmfTimeRange timeRange = null;

            @SuppressWarnings({ "unchecked", "restriction" })
            @Override
            public void run() {
                while (!fExecutor.isShutdown()) {
                    final TmfExperiment<?> experiment = TmfExperiment.getCurrentExperiment();
                    if (experiment != null) {
                        @SuppressWarnings("rawtypes")
                        final TmfEventRequest request = new TmfEventRequest<TmfEvent>(TmfEvent.class,
                                TmfTimeRange.ETERNITY, 0, ExecutionType.FOREGROUND) {

                            @Override
                            public void handleCompleted() {
                                updateJniTrace();
                            }
                        };
                        synchronized (experiment) {
                            experiment.sendRequest(request);
                        }
                        try {
                            request.waitForCompletion();
                        } catch (final InterruptedException e) {
                        }
                    } else
                        updateJniTrace();
                    try {
                        Thread.sleep(LTTNG_STREAMING_INTERVAL);
                    } catch (final InterruptedException e) {
                    }
                }
            }

            private void updateJniTrace() {
                final JniTrace jniTrace = getCurrentJniTrace();
                currentJniTrace.updateTrace();
                final long endTime = jniTrace.getEndTime().getTime();
                final LttngTimestamp startTimestamp = new LttngTimestamp(startTime);
                final LttngTimestamp endTimestamp = new LttngTimestamp(endTime);
                if (safeTimestamp != null && safeTimestamp.compareTo(getTimeRange().getEndTime(), false) > 0)
                    timeRange = new TmfTimeRange(startTimestamp, safeTimestamp);
                else
                    timeRange = null;
                safeTimestamp = endTimestamp;
                if (timeRange != null)
                    setTimeRange(timeRange);
            }
        };
        thread.start();
    }

