    private void initializeStreamingMonitor() {
        JniTrace jniTrace = getCurrentJniTrace();
        if (jniTrace == null || (!jniTrace.isLiveTraceSupported() || !LiveTraceManager.isLiveTrace(jniTrace.getTracepath()))) {
            // Set the time range of the trace
            TmfContext context = seekLocation(null);
            LttngEvent event = getNextEvent(context);
            LttngTimestamp startTime = new LttngTimestamp(event.getTimestamp());
            LttngTimestamp endTime = new LttngTimestamp(currentJniTrace.getEndTime().getTime());
            setTimeRange(new TmfTimeRange(startTime, endTime));
            TmfTraceUpdatedSignal signal = new TmfTraceUpdatedSignal(this, this, getTimeRange());
            broadcast(signal);
            return;
        }

        // Set the time range of the trace
        TmfContext context = seekLocation(null);
        LttngEvent event = getNextEvent(context);
        setEndTime(TmfTimestamp.BIG_BANG);
        final long startTime = event != null ? event.getTimestamp().getValue() : TmfTimestamp.BIG_BANG.getValue();
        fStreamingInterval = LTTNG_STREAMING_INTERVAL;

        final Thread thread = new Thread("Streaming Monitor for trace " + getName()) { //$NON-NLS-1$
            LttngTimestamp safeTimestamp = null;
            TmfTimeRange timeRange = null;

            @SuppressWarnings("unchecked")
            @Override
            public void run() {
                while (!fExecutor.isShutdown()) {
                    TmfExperiment<?> experiment = TmfExperiment.getCurrentExperiment();
                    if (experiment != null) {
                        @SuppressWarnings("rawtypes")
                        final TmfEventRequest request = new TmfEventRequest<TmfEvent>(TmfEvent.class, TmfTimeRange.ETERNITY, 0, ExecutionType.FOREGROUND) {
                            @Override
                            public void handleCompleted() {
                                updateJniTrace();
                            }
                        };
                        synchronized (experiment) {
                            experiment.sendRequest(request);
                        }
                        try {
                            request.waitForCompletion();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    } else {
                        updateJniTrace();
                    }
                    try {
                        Thread.sleep(LTTNG_STREAMING_INTERVAL);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
            
            private void updateJniTrace() {
                JniTrace jniTrace = getCurrentJniTrace();
                currentJniTrace.updateTrace();
                long endTime = jniTrace.getEndTime().getTime();
                LttngTimestamp startTimestamp = new LttngTimestamp(startTime);
                LttngTimestamp endTimestamp = new LttngTimestamp(endTime);
                if (safeTimestamp != null && safeTimestamp.compareTo(getTimeRange().getEndTime(), false) > 0) {
                    timeRange = new TmfTimeRange(startTimestamp, safeTimestamp);
                } else {
                    timeRange = null;
                }
                safeTimestamp = endTimestamp;
                if (timeRange != null) {
                    setTimeRange(timeRange);
                }
            }
        };
        thread.start();
    }

