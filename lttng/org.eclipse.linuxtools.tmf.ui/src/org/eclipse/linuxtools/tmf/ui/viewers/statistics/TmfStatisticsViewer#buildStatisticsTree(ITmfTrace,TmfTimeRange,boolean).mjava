    /**
     * Requests all the data of the trace to the state system which
     * contains information about the statistics.
     *
     * Since the viewer may be listening to multiple traces, it may receive
     * an experiment rather than a single trace. The filtering is done with the
     * method {@link #isListeningTo(String trace)}.
     *
     * @param trace
     *            The trace for which a request must be done
     * @param timeRange
     *            The time range that will be requested to the state system
     * @param isGlobal
     *            Tells if the request is for the global event count or the
     *            partial one.
     */
    private void buildStatisticsTree(final ITmfTrace trace, final TmfTimeRange timeRange, final boolean isGlobal) {
        final TmfStatisticsTreeNode statTree = TmfStatisticsTreeManager.getStatTreeRoot(getTreeID());
        final TmfStatisticsTree statsData = TmfStatisticsTreeManager.getStatTree(getTreeID());
        if (statsData == null) {
            return;
        }

        synchronized (statsData) {
            if (isGlobal) {
                statTree.resetGlobalValue();
            } else {
                statTree.resetTimeRangeValue();
            }

            for (final ITmfTrace aTrace : TmfTraceManager.getTraceSet(trace)) {
                if (!isListeningTo(aTrace)) {
                    continue;
                }

                /* Retrieve the statistics object */
                final TmfStatisticsModule statsMod = aTrace.getAnalysisModuleOfClass(TmfStatisticsModule.class, TmfStatisticsModule.ID);
                if (statsMod == null) {
                    /* No statistics module available for this trace */
                    continue;
                }

                /* Run the potentially long queries in a separate thread */
                Thread statsThread = new Thread("Statistics update") { //$NON-NLS-1$
                    @Override
                    public void run() {
                        /* Wait until the analysis is ready to be queried */
                        statsMod.waitForInitialization();
                        ITmfStatistics stats = statsMod.getStatistics();
                        if (stats == null) {
                            /* It should have worked, but didn't */
                            throw new IllegalStateException();
                        }

                        /*
                         * The generic statistics are stored in nanoseconds, so
                         * we must make sure the time range is scaled correctly.
                         */
                        long start = timeRange.getStartTime().normalize(0, TIME_SCALE).getValue();
                        long end = timeRange.getEndTime().normalize(0, TIME_SCALE).getValue();

                        /*
                         * Wait on the state system object we are going to query.
                         *
                         * TODO Eventually this could be exposed through the
                         * TmfStateSystemAnalysisModule directly.
                         */
                        ITmfStateSystem ss = statsMod.getStateSystem(TmfStatisticsEventTypesModule.ID);
                        if (ss == null) {
                            /* It should be instantiated after the
                             * statsMod.waitForInitialization() above. */
                            throw new IllegalStateException();
                        }

                        /*
                         * Periodically update the statistics while they are
                         * being built (or, if the back-end is already completely
                         * built, it will skip over the while() immediately.
                         */
                        while(!ss.waitUntilBuilt(LIVE_UPDATE_DELAY)) {
                            Map<String, Long> map = stats.getEventTypesInRange(start, end);
                            updateStats(isGlobal, map);
                        }
                        /* Query one last time for the final values */
                        Map<String, Long> map = stats.getEventTypesInRange(start, end);
                        updateStats(isGlobal, map);
                    }
                };
                statsThread.start();
                return;
            }
        }
    }

