	/**
	 * Allows to update the GUI from a stream of events handling addition one by
	 * one over known TmfTaTrace parents.
	 * 
	 * @param parent
	 * @param childItem
	 */
	public void refreshPartial(ITmfTimeAnalysisEntry parent, TimeEvent childItem) {
		// Find the Trace item within the current list
		TraceItem item = findTraceItem(parent);

		if (item == null) {
			// If the parent item is not found, make room for it in the current
			// array
			int length = 1;
			Object[] traces;
			if (_traces != null) {
				length = _traces.length + 1;
				traces = Arrays.copyOf(_traces, length);
			} else {
				traces = new Object[length];
			}

			// Add the new parent element to the end of the array.
			traces[length - 1] = parent;

			// update the filter array to accomodate a postion to the new
			// element
			traceFilter = new boolean[traces.length];
			java.util.Arrays.fill(traceFilter, true);

			// rebuild internal data
			_traces = traces;
			refreshData();

			// item must be there
			item = findTraceItem(parent);
		}

		ITmfTimeAnalysisEntry localTraceItem = item._trace;
		// Local trace found
		Vector<TimeEvent> children = localTraceItem.getTraceEvents();
		TimeEvent lastChildIn = children.lastElement();
		long lastChildSTime = lastChildIn.getTime();
		long newChildSTime = childItem.getTime();
		if (newChildSTime < lastChildSTime) {
			// The children are expected to arrive sorted by time
			// since the new time is earlier than the last child
			// The infomation is being refreshed from start, remove all
			// children and start over
			children.clear();
		}
		// Add the new item
		children.add(childItem);

	}

