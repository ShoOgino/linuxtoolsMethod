    public TmfEventsTable(Composite parent, int cacheSize, ColumnData[] columnData) {
        super("TmfEventsTable"); //$NON-NLS-1$
        
        fCacheSize = cacheSize;
        fCache = new TmfEvent[fCacheSize];
        
        // Create a virtual table
        final int style = SWT.H_SCROLL | SWT.V_SCROLL | SWT.SINGLE | SWT.FULL_SELECTION;
        fTable = new TmfVirtualTable(parent, style);

        // Set the table layout
        GridData layoutData = new GridData(SWT.FILL, SWT.FILL, true, true);
        fTable.setLayoutData(layoutData);

        // Some cosmetic enhancements
        fTable.setHeaderVisible(true);
        fTable.setLinesVisible(true);

        // Set the columns
        setColumnHeaders(columnData);

        // Handle the table item requests 
        fTable.addSelectionListener(new SelectionAdapter() {
            @Override
            public void widgetSelected(SelectionEvent e) {
                TmfTimestamp ts = (TmfTimestamp) fTable.getSelection()[0].getData();
                broadcast(new TmfTimeSynchSignal(fTable, ts));
            }
        });

        // Handle the table item requests 
        fTable.addListener(SWT.SetData, new Listener() {

            @Override
			public void handleEvent(Event event) {

                final TableItem item = (TableItem) event.item;
                final int index = fTable.indexOf(item);

                // If available, return the cached data  
                if ((index >= fCacheStartIndex) && (index < fCacheEndIndex)) {
                    int i = index - fCacheStartIndex;
                    item.setText(extractItemFields(fCache[i]));
                    item.setData(new TmfTimestamp(fCache[i].getTimestamp()));
                    return;
                }

                // Else, fill the cache asynchronously (and off the UI thread)
                populateCache(index);
            }
        });

        fTable.setItemCount(0);
    }

