    private void formatImage(final GC imageGC, final Image image) {

        if (fScaledData == null) {
            return;
        }

        final HistogramScaledData scaledData = new HistogramScaledData(fScaledData);

        try {
            // Get drawing boundaries
            final int width = image.getBounds().width;
            final int height = image.getBounds().height;

            // Clear the drawing area
            imageGC.setBackground(fBackgroundColor);
            imageGC.fillRectangle(0, 0, image.getBounds().width + 1, image.getBounds().height + 1);

            // Draw the histogram bars
            final int limit = width < scaledData.fWidth ? width : scaledData.fWidth;
            double factor = HistogramScaledData.hideLostEvents ? scaledData.fScalingFactor : scaledData.fScalingFactorCombined;
            for (int i = 0; i < limit; i++) {
                imageGC.setForeground(fHistoBarColor);
                final int value = (int) Math.ceil(scaledData.fData[i] * factor);
                imageGC.drawLine(i, height - value, i, height);

                if (!HistogramScaledData.hideLostEvents) {
                    imageGC.setForeground(fLostEventColor);
                    final int lostEventValue = (int) Math.ceil(scaledData.fLostEventsData[i] * factor);
                    if (lostEventValue != 0) {
                        if (lostEventValue == 1) {
                            // in linux, a line from x to x is not drawn, in windows it is.
                            imageGC.drawPoint(i, height - value - 1);
                        } else {
                            // drawing a line is inclusive, so we need to remove 1 from the destination to have the correct length
                            imageGC.drawLine(i, height - value - lostEventValue, i, height - value - 1);
                        }
                    }
                }
            }

            // Add a dashed line as a delimiter
            int delimiterIndex = (int) ((getDataModel().getEndTime() - scaledData.getFirstBucketTime()) / scaledData.fBucketDuration) + 1;
            drawDelimiter(imageGC, fLastEventColor, height, delimiterIndex);

            // Fill the area to the right of delimiter with background color
            imageGC.setBackground(fFillColor);
            imageGC.fillRectangle(delimiterIndex + 1, 0, width - (delimiterIndex + 1), height);

            // Draw the selection bars
            int alpha = imageGC.getAlpha();
            imageGC.setAlpha(100);
            imageGC.setForeground(fSelectionForegroundColor);
            imageGC.setBackground(fSelectionBackgroundColor);
            final int beginBucket = scaledData.fSelectionBeginBucket;
            if (beginBucket >= 0 && beginBucket < limit) {
                imageGC.drawLine(beginBucket, 0, beginBucket, height);
            }
            final int endBucket = scaledData.fSelectionEndBucket;
            if (endBucket >= 0 && endBucket < limit && endBucket != beginBucket) {
                imageGC.drawLine(endBucket, 0, endBucket, height);
            }
            if (endBucket - beginBucket > 1) {
                imageGC.fillRectangle(beginBucket + 1, 0, endBucket - beginBucket - 1, height);
            }
            imageGC.setAlpha(alpha);
        } catch (final Exception e) {
            // Do nothing
        }
    }

