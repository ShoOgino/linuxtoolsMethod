    	@SuppressWarnings("unchecked")
    	@Override
    	protected IStatus run(final IProgressMonitor monitor) {
    		final Display display = Display.getDefault();
    		if (startIndex < 0) {
    			rank = (int) fTrace.getNbEvents() - 1;
    		} else if (startIndex >= fTable.getItemCount() - (eventFilter == null ? 1 : 3)) { // -1 for header row, -2 for top and bottom filter status rows
    			rank = 0;
    		} else {
        		int idx = startIndex;
        		while (foundRank == -1) {
        			CachedEvent event = fCache.peekEvent(idx);
        			if (event == null) {
        				break;
        			}
        			rank = event.rank;
        			if (searchFilter.matches(event.event) && (eventFilter == null || eventFilter.matches(event.event))) {
        				foundRank = event.rank;
        				break;
        			}
        			if (direction == Direction.FORWARD) {
        				idx++;
        			} else {
        				idx--;
        			}
        		}
        		if (foundRank == -1) {
        			if (direction == Direction.FORWARD) {
        				rank++;
        				if (rank > fTrace.getNbEvents() - 1) {
        	    			rank = 0;
        				}
        			} else {
        				rank--;
        				if (rank < 0) {
        	    			rank = (int) fTrace.getNbEvents() - 1;
        				}
        			}
        		}
    		}
    		int startRank = (int) rank;
    		boolean wrapped = false;
    		while (!monitor.isCanceled() && foundRank == -1) {
    			int nbRequested = (direction == Direction.FORWARD ? Integer.MAX_VALUE : Math.min((int) rank + 1, fTrace.getCacheSize()));
    			if (direction == Direction.BACKWARD) {
    				rank = Math.max(0, rank - fTrace.getCacheSize() + 1);
    			}
    			request = new TmfDataRequest<TmfEvent>(TmfEvent.class, (int) rank, nbRequested) {
    				long currentRank = rank;
    				@Override
    				public void handleData(TmfEvent event) {
    					super.handleData(event);
    					if (searchFilter.matches(event) && (eventFilter == null || eventFilter.matches(event))) {
    						foundRank = currentRank;
    						if (direction == Direction.FORWARD) {
        						done();
        						return;
    						}
    					}
    					currentRank++;
    				}
    			};
    			((ITmfDataProvider<TmfEvent>) fTrace).sendRequest(request);
    			try {
    				request.waitForCompletion();
    				if (request.isCancelled()) {
    					return Status.OK_STATUS;
    				}
    			} catch (InterruptedException e) {
    				synchronized (fSearchSyncObj) {
    					fSearchThread = null;
    				}
    				return Status.OK_STATUS;
    			}
    			if (foundRank == -1) {
    				if (direction == Direction.FORWARD) {
    					if (rank == 0) {
    	    				synchronized (fSearchSyncObj) {
    	    					fSearchThread = null;
    	    				}
    						return Status.OK_STATUS;
    					} else {
    						nbRequested = (int) rank;
    						rank = 0;
    						wrapped = true;
    					}
    				} else {
    					rank--;
    					if (rank < 0) {
    						rank = (int) fTrace.getNbEvents() - 1;
    						wrapped = true;
    					}
    					if (rank <= startRank && wrapped) {
    	    				synchronized (fSearchSyncObj) {
    	    					fSearchThread = null;
    	    				}
    						return Status.OK_STATUS;
    					}
    				}
    			}
    		}
    		int index = (int) foundRank;
    		if (eventFilter != null) {
    			index = fCache.getFilteredEventIndex(foundRank);
    		}
    		final int selection = (int) index + 1 + (eventFilter != null ? +1 : 0); // +1 for header row, +1 for top filter status row

    		display.asyncExec(new Runnable() {
    			@Override
    			public void run() {
    				if (monitor.isCanceled()) return;
    				if (fTable.isDisposed()) return;
    				fTable.setSelection(selection);
    				fSelectedRank = foundRank;
    				synchronized (fSearchSyncObj) {
    					fSearchThread = null;
    				}
    			}
    		});
    		return Status.OK_STATUS;
    	}

