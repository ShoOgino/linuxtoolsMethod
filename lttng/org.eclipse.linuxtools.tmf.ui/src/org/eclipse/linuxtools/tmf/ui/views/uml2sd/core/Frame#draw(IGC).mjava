    @Override
    public void draw(IGC context) {
        drawFrame(context);
        if (!hasChildren()) {
            return;
        }

        if (fHighlightLifeline != null) {
            IColor backupColor = context.getBackground();
            context.setBackground(SDViewPref.getInstance().getTimeCompressionSelectionColor());
            int gy = fHighlightLifeline.getY() + fHighlightLifeline.getHeight() + (Metrics.getMessageFontHeigth() + Metrics.getMessagesSpacing()) * fStartEvent;
            context.fillRectangle(Metrics.FRAME_H_MARGIN + 1, gy, fHighlightLifeline.getX() + Metrics.getLifelineWidth() / 2 - Metrics.FRAME_H_MARGIN, (Metrics.getMessageFontHeigth() + Metrics.getMessagesSpacing()) * fNbEvent);
            context.setBackground(backupColor);
        }
        super.draw(context, false);
        int lifelineArryStep = 1;
        if (Metrics.swimmingLaneWidth() * context.getZoom() < Metrics.LIFELINE_SIGNIFICANT_HSPACING) {
            lifelineArryStep = Math.round(Metrics.LIFELINE_SIGNIFICANT_HSPACING / (Metrics.swimmingLaneWidth() * context.getZoom()));
        }
        if (getIndexes().size() == 0) {
            return;
        }
        int lifeLineDrawIndex = getIndexes().get(Lifeline.LIFELINE_TAG).intValue();
        for (int i = lifeLineDrawIndex; i < getNodeMap().get(Lifeline.LIFELINE_TAG).size(); i = i + lifelineArryStep) {
            Lifeline toDraw = (Lifeline) getNodeMap().get(Lifeline.LIFELINE_TAG).get(i);
            if (toDraw.getX() - Metrics.LIFELINE_SPACING / 2 > context.getContentsX() + context.getVisibleWidth()) {
                break;
            }
            toDraw.drawName(context);

            if (fHighlightLifeline != null) {
                if (toDraw == fHighlightLifeline) {
                    toDraw.highlightExecOccurrenceRegion(context, fStartEvent, fNbEvent, fHighlightColor);
                } else if ((toDraw.getIndex() < fHighlightLifeline.getIndex()) || ((toDraw.getIndex() < fHighlightLifeline.getIndex()))) {

                    int acIndex = toDraw.getExecOccurrenceDrawIndex();
                    // acIndex = first visible execution occurrence
                    // for drawing speed reason with only search on the visible subset
                    if (toDraw.getExecutions() != null) {
                        for (int index = acIndex; index < toDraw.getExecutions().size(); index++) {
                            BasicExecutionOccurrence exec = (BasicExecutionOccurrence) toDraw.getExecutions().get(index);
                            int tempEvent = fStartEvent;
                            for (int j = 0; j < fNbEvent; j++) {
                                if (((tempEvent >= exec.getStartOccurrence()) && (tempEvent <= exec.getEndOccurrence()) && (tempEvent + 1 >= exec.getStartOccurrence()) && (tempEvent + 1 <= exec.getEndOccurrence()))) {
                                    toDraw.highlightExecOccurrenceRegion(context, tempEvent, 1, SDViewPref.getInstance().getTimeCompressionSelectionColor());
                                }
                                tempEvent = tempEvent + 1;
                            }
                            // if we are outside the visible area we stop right now
                            // This works because execution occurrences are ordered along the Y axis
                            if (exec.getY() > getY()) {
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

