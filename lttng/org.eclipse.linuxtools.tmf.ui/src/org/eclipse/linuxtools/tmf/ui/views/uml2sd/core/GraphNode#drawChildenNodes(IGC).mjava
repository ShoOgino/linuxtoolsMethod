    /**
     * Draws the children nodes on the given context.<br>
     * This method start width GraphNodes ordering if needed.<br>
     * After, depending on the visible area, only visible GraphNodes are drawn.<br>
     *
     * @param context the context to draw to
     * @see org.eclipse.linuxtools.tmf.ui.views.uml2sd.core.GraphNode#draw(IGC)
     */
    protected void drawChildenNodes(IGC context) {

        if (!fHasChilden) {
            return;
        }
        // If the nodes have not been added ordered, the array is ordered
        Iterator<String> it = fForwardSort.keySet().iterator();
        while (it.hasNext()) {
            String nodeType = it.next();
            boolean sort = ((Boolean) fForwardSort.get(nodeType)).booleanValue();
            if (sort) {
                GraphNode[] temp = ((List<GraphNode>) fForwardNodes.get(nodeType)).toArray(new GraphNode[((List<GraphNode>)fForwardNodes.get(nodeType)).size()]);
                GraphNode node = (GraphNode) ((List<GraphNode>) fNodes.get(nodeType)).get(0);
                Arrays.sort(temp, node.getComparator());
                fForwardSort.put(nodeType, Boolean.FALSE);
                fNodes.put(nodeType, Arrays.asList(temp));
                fForwardNodes.put(nodeType, Arrays.asList(temp));
                if (TmfUiTracer.isSortingTraced()) {
                    TmfUiTracer.traceSorting(nodeType + " array sorted\n"); //$NON-NLS-1$
                }
            }
        }

        Iterator<String> it2 = fBackwardSort.keySet().iterator();
        while (it2.hasNext()) {
            String nodeType = it2.next();
            boolean sort = ((Boolean) fBackwardSort.get(nodeType)).booleanValue();
            if (sort) {
                GraphNode[] temp = ((List<GraphNode>) fBackwardNodes.get(nodeType)).toArray(new GraphNode[((List<GraphNode>) fBackwardNodes.get(nodeType)).size()]);
                GraphNode node = (GraphNode) ((List<GraphNode>) fNodes.get(nodeType)).get(0);
                Arrays.sort(temp, node.getBackComparator());
                fBackwardSort.put(nodeType, Boolean.FALSE);
                fBackwardNodes.put(nodeType, Arrays.asList(temp));
                if (TmfUiTracer.isSortingTraced()) {
                    TmfUiTracer.traceSorting(nodeType + " back array sorted\n"); //$NON-NLS-1$
                }
            }
        }

        if (TmfUiTracer.isDisplayTraced()) {
            TmfUiTracer.traceDisplay("*****************************\n"); //$NON-NLS-1$
        }

        int arrayStep = 1;
        if ((Metrics.getMessageFontHeigth() + Metrics.MESSAGES_NAME_SPACING * 2) * context.getZoom() < Metrics.MESSAGE_SIGNIFICANT_VSPACING) {
            arrayStep = Math.round(Metrics.MESSAGE_SIGNIFICANT_VSPACING / ((Metrics.getMessageFontHeigth() + Metrics.MESSAGES_NAME_SPACING * 2) * context.getZoom()));
        }

        int count = 0;
        Iterator<String> it3 = fForwardSort.keySet().iterator();
        while (it3.hasNext()) {
            count = 0;
            Object nodeType = it3.next();
            GraphNode node = (GraphNode) ((List<GraphNode>) fNodes.get(nodeType)).get(0);
            context.setFont(SDViewPref.getInstance().getFont(node.fPrefId));
            int index = ((Integer) fIndexes.get(nodeType)).intValue();
            count = drawNodes(context, (List<GraphNode>) fNodes.get(nodeType), index, arrayStep);
            if (TmfUiTracer.isDisplayTraced()) {
                TmfUiTracer.traceDisplay(count + " " + nodeType + " drawn, starting from index " + index + "\r\n"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
            }
        }
        if (TmfUiTracer.isDisplayTraced()) {
            TmfUiTracer.traceDisplay("*****************************\n"); //$NON-NLS-1$
        }

    }

