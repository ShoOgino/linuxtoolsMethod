    @SuppressWarnings("unchecked")
    @TmfSignalHandler
    public void currentTimeUpdated(final TmfTimeSynchSignal signal) {
        if ((signal.getSource() != fTable) && (fTrace != null) && (!fTable.isDisposed())) {

            // Create a request for one event that will be queued after other ongoing requests. When this request is
            // completed
            // do the work to select the actual event with the timestamp specified in the signal. This procedure
            // prevents
            // the method fTrace.getRank() from interfering and delaying ongoing requests.
            final TmfDataRequest<TmfEvent> subRequest = new TmfDataRequest<TmfEvent>(TmfEvent.class, 0, 1,
                    ExecutionType.FOREGROUND) {

                TmfTimestamp ts = new TmfTimestamp(signal.getCurrentTime());

                @Override
                public void handleData(TmfEvent event) {
                    super.handleData(event);
                }

                @Override
                public void handleCompleted() {
                    super.handleCompleted();
                    if (fTrace == null) {
                        return;
                    }
                    // Verify if event is within the trace range
                    final ITmfTimestamp timestamp[] = new TmfTimestamp[1];
                    timestamp[0] = ts; // signal.getCurrentTime();
                    if (timestamp[0].compareTo(fTrace.getStartTime(), true) == -1) {
                        timestamp[0] = fTrace.getStartTime();
                    }
                    if (timestamp[0].compareTo(fTrace.getEndTime(), true) == 1) {
                        timestamp[0] = fTrace.getEndTime();
                    }

                    // Get the rank for the event selection in the table
                    final long rank = fTrace.getRank(timestamp[0]);
                    fSelectedRank = rank;

                    fTable.getDisplay().asyncExec(new Runnable() {
                        @Override
                        public void run() {
                            // Return if table is disposed
                            if (fTable.isDisposed())
                                return;

                            int index = (int) rank;
                            if (fTable.isDisposed())
                                return;
                            if (fTable.getData(Key.FILTER_OBJ) != null) {
                                index = fCache.getFilteredEventIndex(rank) + 1; // +1 for top filter status row
                            }
                            fTable.setSelection(index + 1); // +1 for header row
                            fRawViewer.selectAndReveal(rank);
                        }
                    });
                }
            };

            ((ITmfDataProvider<TmfEvent>) fTrace).sendRequest(subRequest);
        }
    }

