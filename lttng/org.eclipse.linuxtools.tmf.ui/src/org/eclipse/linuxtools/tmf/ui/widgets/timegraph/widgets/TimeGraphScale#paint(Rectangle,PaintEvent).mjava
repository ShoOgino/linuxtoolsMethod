    @Override
    void paint(Rectangle rect, PaintEvent e) {

        if (_isInUpdate || null == _timeProvider) {
            return;
        }

        GC gc = e.gc;
        gc.fillRectangle(rect);

        long time0 = _timeProvider.getTime0();
        long time1 = _timeProvider.getTime1();
        long selectedTime = _timeProvider.getSelectedTime();
        int leftSpace = _timeProvider.getNameSpace();
        int timeSpace = _timeProvider.getTimeSpace();

        gc.setBackground(_colors.getColor(TimeGraphColorScheme.TOOL_BACKGROUND));
        gc.setForeground(_colors.getColor(TimeGraphColorScheme.TOOL_FOREGROUND));
        Utils.init(_rect0, rect);

        // draw top left area
        _rect0.width = leftSpace;
        _rect0.x += 4;
        _rect0.width -= 4;
        Rectangle absHeaderRect = new Rectangle(_rect0.x, _rect0.y, _rect0.width, _rect0.height);
        _rect0.x -= 4;
        _rect0.width += 4;

        // prepare and draw right rect of the timescale
        _rect0.x += leftSpace;
        _rect0.width = rect.width - leftSpace;

        // draw bottom border and erase all other area
        gc.drawLine(rect.x, rect.y + rect.height - 1, rect.x + rect.width - 1,
                rect.y + rect.height - 1);
        _rect0.height--;
        gc.fillRectangle(_rect0);

        if (time1 <= time0 || timeSpace < 2) {
            return;
        }

        int numDigits = calculateDigits(time0, time1);

        int labelWidth = gc.getCharWidth('0') * numDigits;
        double pixelsPerNanoSec = (timeSpace <= RIGHT_MARGIN) ? 0 :
            (double) (timeSpace - RIGHT_MARGIN) / (time1 - time0);
        calcTimeDelta(labelWidth, pixelsPerNanoSec);

        TimeDraw timeDraw = getTimeDraw(_timeDelta);

        // draw zoom rectangle
        if (3 == _dragState && null != _timeProvider) {
            if (_dragX0 < _dragX) {
                gc.drawRectangle(leftSpace + _dragX0, rect.y, _dragX - _dragX0 - 1, rect.height - 8);
            } else if (_dragX0 > _dragX) {
                gc.drawRectangle(leftSpace + _dragX, rect.y, _dragX0 - _dragX - 1, rect.height - 8);
            }
        }

        if (_rect0.isEmpty()) {
            return;
        }

        // draw selected time
        int x = _rect0.x + (int) ((selectedTime - time0) * pixelsPerNanoSec);
        if (x >= _rect0.x && x < _rect0.x + _rect0.width) {
            gc.setForeground(_colors.getColor(TimeGraphColorScheme.SELECTED_TIME));
            gc.drawLine(x, _rect0.y + _rect0.height - 6, x, _rect0.y
                    + _rect0.height);
            gc.setForeground(_colors.getColor(TimeGraphColorScheme.TOOL_FOREGROUND));
        }

        // draw time scale ticks
        _rect0.y = rect.y;
        _rect0.height = rect.height - 4;
        _rect0.width = labelWidth;

        long time;
        if (_timeProvider != null && _timeProvider.isCalendarFormat()) {
            time = floorToCalendar(time0, _timeDelta);
        } else {
            time = (long) (Math.ceil((double) time0 / _timeDelta) * _timeDelta);
        }

        int y = _rect0.y + _rect0.height;

        if (_timeProvider != null && _timeProvider.isCalendarFormat()) {
            timeDraw.drawAbsHeader(gc, time, absHeaderRect);
        }

        while (true) {
            x = rect.x + leftSpace + (int) (Math.floor((time - time0) * pixelsPerNanoSec));
            if (x >= rect.x + leftSpace + rect.width - _rect0.width) {
                break;
            }
            if (x >= rect.x + leftSpace) {
                gc.drawLine(x, y, x, y + 4);
                _rect0.x = x;
                if (x + _rect0.width <= rect.x + rect.width) {
                    timeDraw.draw(gc, time, _rect0);
                }
            }
            if (pixelsPerNanoSec == 0 || time > Long.MAX_VALUE - _timeDelta || _timeDelta == 0) {
                break;
            }
            if (_timeProvider != null && _timeProvider.isCalendarFormat()) {
                if (_timeDelta >= YEAR_IN_NS) {
                    long millis = time / 1000000L;
                    GREGORIAN_CALENDAR.setTime(new Date(millis));
                    GREGORIAN_CALENDAR.add(Calendar.YEAR, (int) (_timeDelta / YEAR_IN_NS));
                    millis = GREGORIAN_CALENDAR.getTimeInMillis();
                    time = millis * 1000000L;
                } else if (_timeDelta >= MONTH_IN_NS) {
                    long millis = time / 1000000L;
                    GREGORIAN_CALENDAR.setTime(new Date(millis));
                    GREGORIAN_CALENDAR.add(Calendar.MONTH, (int) (_timeDelta / MONTH_IN_NS));
                    millis = GREGORIAN_CALENDAR.getTimeInMillis();
                    time = millis * 1000000L;
                } else if (_timeDelta >= DAY_IN_NS) {
                    long millis = time / 1000000L;
                    GREGORIAN_CALENDAR.setTime(new Date(millis));
                    GREGORIAN_CALENDAR.add(Calendar.DAY_OF_MONTH, (int) (_timeDelta / DAY_IN_NS));
                    millis = GREGORIAN_CALENDAR.getTimeInMillis();
                    time = millis * 1000000L;
                } else {
                    time += _timeDelta;
                }
            } else {
                time += _timeDelta;
            }
        }
    }

