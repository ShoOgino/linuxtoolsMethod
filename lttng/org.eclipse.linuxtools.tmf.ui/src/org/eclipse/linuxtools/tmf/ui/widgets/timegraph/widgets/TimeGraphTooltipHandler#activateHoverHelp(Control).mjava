    /**
     * Callback for the mouse-over tooltip
     *
     * @param control
     *            The control object to use
     */
    public void activateHoverHelp(final Control control) {
        control.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseDown(MouseEvent e) {
                if (fTipShell != null && ! fTipShell.isDisposed()) {
                    fTipShell.dispose();
                }
            }
        });

        control.addMouseMoveListener(new MouseMoveListener() {
            @Override
            public void mouseMove(MouseEvent e) {
                if (fTipShell != null && ! fTipShell.isDisposed()) {
                    fTipShell.dispose();
                }
            }
        });

        control.addMouseTrackListener(new MouseTrackAdapter() {
            @Override
            public void mouseExit(MouseEvent e) {
                if (fTipShell != null && ! fTipShell.isDisposed()) {
                    Point pt = control.toDisplay(e.x, e.y);
                    if (! fTipShell.getBounds().contains(pt)) {
                        fTipShell.dispose();
                    }
                }
            }

            private void addItem(String name, String value) {
                Label nameLabel = new Label(fTipComposite, SWT.NO_FOCUS);
                nameLabel.setText(name);
                setupControl(nameLabel);
                Label separator = new Label(fTipComposite, SWT.NO_FOCUS | SWT.SEPARATOR | SWT.VERTICAL);
                GridData gd = new GridData(SWT.CENTER, SWT.CENTER, false, false);
                gd.heightHint = nameLabel.computeSize(SWT.DEFAULT, SWT.DEFAULT).y;
                separator.setLayoutData(gd);
                setupControl(separator);
                Label valueLabel = new Label(fTipComposite, SWT.NO_FOCUS);
                valueLabel.setText(value);
                setupControl(valueLabel);
            }

            private void fillValues(Point pt, TimeGraphControl timeGraphControl, ITimeGraphEntry entry) {
                if (entry == null) {
                    return;
                }
                if (entry.hasTimeEvents()) {
                    long currPixelTime = timeGraphControl.getTimeAtX(pt.x);
                    long nextPixelTime = timeGraphControl.getTimeAtX(pt.x + 1);
                    if (nextPixelTime == currPixelTime) {
                        nextPixelTime++;
                    }
                    ITimeEvent currEvent = Utils.findEvent(entry, currPixelTime, 0);
                    ITimeEvent nextEvent = Utils.findEvent(entry, currPixelTime, 1);

                    // if there is no current event at the start of the current pixel range,
                    // or if the current event starts before the current pixel range,
                    // use the next event as long as it starts within the current pixel range
                    if ((currEvent == null || currEvent.getTime() < currPixelTime) &&
                        (nextEvent != null && nextEvent.getTime() < nextPixelTime)) {
                        currEvent = nextEvent;
                        currPixelTime = nextEvent.getTime();
                    }

                    // state name
                    String stateTypeName = fTimeGraphProvider.getStateTypeName(entry);
                    String entryName = entry.getName();
                    if (stateTypeName == null) {
                        stateTypeName = fTimeGraphProvider.getStateTypeName();
                    }

                    if (!entryName.isEmpty()) {
                        addItem(stateTypeName, entry.getName());
                    }

                    if (currEvent == null || currEvent instanceof NullTimeEvent) {
                        return;
                    }

                    // state
                    String state = fTimeGraphProvider.getEventName(currEvent);
                    if (state != null) {
                        addItem(Messages.TmfTimeTipHandler_TRACE_STATE, state);
                    }

                    // This block receives a list of <String, String> values to be added to the tip table
                    Map<String, String> eventAddOns = fTimeGraphProvider.getEventHoverToolTipInfo(currEvent, currPixelTime);
                    if (eventAddOns != null) {
                        for (Iterator<String> iter = eventAddOns.keySet().iterator(); iter.hasNext();) {
                            String message = iter.next();
                            addItem(message, eventAddOns.get(message));
                        }
                    }
                    if (fTimeGraphProvider.displayTimesInTooltip()) {
                        long eventStartTime = -1;
                        long eventDuration = -1;
                        long eventEndTime = -1;

                        eventStartTime = currEvent.getTime();
                        eventDuration = currEvent.getDuration();
                        if (eventDuration < 0 && nextEvent != null) {
                            eventEndTime = nextEvent.getTime();
                            eventDuration = eventEndTime - eventStartTime;
                        } else {
                            eventEndTime = eventStartTime + eventDuration;
                        }

                        Resolution res = Resolution.NANOSEC;
                        TimeFormat tf = fTimeDataProvider.getTimeFormat();
                        if (tf == TimeFormat.CALENDAR) {
                            addItem(Messages.TmfTimeTipHandler_TRACE_DATE, eventStartTime > -1 ?
                                    Utils.formatDate(eventStartTime)
                                    : "?"); //$NON-NLS-1$
                        }
                        if (eventDuration > 0) {
                            addItem(Messages.TmfTimeTipHandler_TRACE_START_TIME, eventStartTime > -1 ?
                                    Utils.formatTime(eventStartTime, tf, res)
                                    : "?"); //$NON-NLS-1$

                            addItem(Messages.TmfTimeTipHandler_TRACE_STOP_TIME, eventEndTime > -1 ?
                                    Utils.formatTime(eventEndTime, tf, res)
                                    : "?"); //$NON-NLS-1$
                        } else {
                            addItem(Messages.TmfTimeTipHandler_TRACE_EVENT_TIME, eventStartTime > -1 ?
                                    Utils.formatTime(eventStartTime, tf, res)
                                    : "?"); //$NON-NLS-1$
                        }

                        if (eventDuration > 0) {
                            // Duration in relative format in any case
                            if (tf == TimeFormat.CALENDAR) {
                                tf = TimeFormat.RELATIVE;
                            }
                            addItem(Messages.TmfTimeTipHandler_DURATION, eventDuration > -1 ?
                                    Utils.formatTime(eventDuration, tf, res)
                                    : "?"); //$NON-NLS-1$
                        }
                    }
                }
            }

            private void fillValues(ILinkEvent linkEvent) {
                addItem(Messages.TmfTimeTipHandler_LINK_SOURCE, linkEvent.getEntry().getName());
                addItem(Messages.TmfTimeTipHandler_LINK_TARGET, linkEvent.getDestinationEntry().getName());

                // This block receives a list of <String, String> values to be added to the tip table
                Map<String, String> eventAddOns = fTimeGraphProvider.getEventHoverToolTipInfo(linkEvent);
                if (eventAddOns != null) {
                    for (Iterator<String> iter = eventAddOns.keySet().iterator(); iter.hasNext();) {
                        String message = iter.next();
                        addItem(message, eventAddOns.get(message));
                    }
                }
                if (fTimeGraphProvider.displayTimesInTooltip()) {
                    long sourceTime = linkEvent.getTime();
                    long duration = linkEvent.getDuration();
                    long targetTime = sourceTime + duration;

                    Resolution res = Resolution.NANOSEC;
                    TimeFormat tf = fTimeDataProvider.getTimeFormat();
                    if (tf == TimeFormat.CALENDAR) {
                        addItem(Messages.TmfTimeTipHandler_TRACE_DATE, Utils.formatDate(sourceTime));
                    }
                    if (duration > 0) {
                        addItem(Messages.TmfTimeTipHandler_LINK_SOURCE_TIME, Utils.formatTime(sourceTime, tf, res));
                        addItem(Messages.TmfTimeTipHandler_LINK_TARGET_TIME, Utils.formatTime(targetTime, tf, res));
                        // Duration in relative format in any case
                        if (tf == TimeFormat.CALENDAR) {
                            tf = TimeFormat.RELATIVE;
                        }
                        addItem(Messages.TmfTimeTipHandler_DURATION, Utils.formatTime(duration, tf, res));
                    } else {
                        addItem(Messages.TmfTimeTipHandler_LINK_TIME, Utils.formatTime(sourceTime, tf, res));
                    }
                }
            }

            @Override
            public void mouseHover(MouseEvent event) {
                if ((event.stateMask & SWT.BUTTON_MASK) != 0) {
                    return;
                }
                Point pt = new Point(event.x, event.y);
                TimeGraphControl timeGraphControl = (TimeGraphControl) event.widget;
                createTooltipShell(timeGraphControl.getShell());
                for (Control child : fTipComposite.getChildren()) {
                    child.dispose();
                }
                if ((event.stateMask & SWT.MODIFIER_MASK) != SWT.SHIFT) {
                    ILinkEvent linkEvent = timeGraphControl.getArrow(pt);
                    if (linkEvent != null) {
                        fillValues(linkEvent);
                    }
                }
                if (fTipComposite.getChildren().length == 0) {
                    ITimeGraphEntry entry = timeGraphControl.getEntry(pt);
                    fillValues(pt, timeGraphControl, entry);
                }
                if (fTipComposite.getChildren().length == 0) {
                    return;
                }
                fTipShell.pack();
                Point tipPosition = control.toDisplay(pt);
                fTipShell.pack();
                setHoverLocation(fTipShell, tipPosition);
                fTipShell.setVisible(true);
            }
        });
    }

