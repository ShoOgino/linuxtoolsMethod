	void paint(Rectangle rect, PaintEvent e) {

		if (_isInUpdate || null == _timeProvider)
			return;

		GC gc = e.gc;
		if (null == _timeProvider) {
			gc.fillRectangle(rect);
			return;
		}

		gc.setBackground(_colors.getColor(TraceColorScheme.TOOL_BACKGROUND));
		gc.setForeground(_colors.getColor(TraceColorScheme.TOOL_FOREGROUND));
		long time0 = _timeProvider.getTime0();
		long time1 = _timeProvider.getTime1();
		long selectedTime = _timeProvider.getSelectedTime();
		int leftSpace = _timeProvider.getNameSpace();
		int timeSpace = _timeProvider.getTimeSpace();

		if (time1 <= time0 || timeSpace < 2) {
			gc.fillRectangle(rect);
			return;
		}

		int numDigits = calculateDigits(time0, time1);

		Utils.init(_rect0, rect);
		int labelWidth = gc.getCharWidth('0') * numDigits;
		double K = 1;
		if (rect.width - leftSpace > 0) {
			K = (double) timeSpace / (time1 - time0);
			calcTimeDelta(labelWidth, K);
		}
		
		TimeDraw timeDraw = getTimeDraw(_timeDelta);

		// draw top left area
		_rect0.width = leftSpace;
		gc.fillRectangle(_rect0);
		_rect0.x += 4;
		_rect0.width -= 4;
		if (_rect0.width > 0) {
// TODO: Check if we really need that piece of code...			
//			if (false && rect.width - leftSpace > 0)
//				Utils.drawText(gc, Messages._Timescale + ": "
//						+ timeDraw.hint(), _rect0, true);
//			else
				Utils.drawText(gc, Messages._Timescale + ":", _rect0, true);
		}
		_rect0.x -= 4;
		_rect0.width += 4;

		// prepare and draw right rect of the timescale
		_rect0.x += leftSpace;
		_rect0.width = rect.width - leftSpace;

		// draw bottom border and erase all other area
		gc.drawLine(rect.x, rect.y + rect.height - 1, rect.x + rect.width - 1,
				rect.y + rect.height - 1);
		_rect0.height--;
		gc.fillRectangle(_rect0);

		if (_rect0.isEmpty())
			return;

		// draw selected time
		int x = _rect0.x + (int) ((selectedTime - time0) * K);
		if (x >= _rect0.x && x < _rect0.x + _rect0.width) {
			gc.setForeground(_colors.getColor(TraceColorScheme.SELECTED_TIME));
			gc.drawLine(x, _rect0.y + _rect0.height - 6, x, _rect0.y
					+ _rect0.height);
			gc
					.setForeground(_colors
							.getColor(TraceColorScheme.TOOL_FOREGROUND));
		}

		// draw time scale ticks
		_rect0.y = rect.y;
		_rect0.height = rect.height - 4;
		_rect0.width = labelWidth;
		long time = (long) (Math.floor(time0 / _timeDeltaD) * _timeDeltaD);
		// long t = (long) (time * 1000000000);
		long t = time;
		int y = _rect0.y + _rect0.height;
		while (true) {
			x = rect.x + leftSpace + (int) ((time - time0) * K);
			if (x >= rect.x + leftSpace + rect.width - _rect0.width) {
				break;
			}
			if (x >= rect.x + leftSpace) {
				gc.drawLine(x, y, x, y + 4);
				_rect0.x = x;
				if (x + _rect0.width <= rect.x + rect.width)
					timeDraw.draw(gc, t, _rect0);
			}
			time += _timeDeltaD;
			t += _timeDelta;
		}
	}

