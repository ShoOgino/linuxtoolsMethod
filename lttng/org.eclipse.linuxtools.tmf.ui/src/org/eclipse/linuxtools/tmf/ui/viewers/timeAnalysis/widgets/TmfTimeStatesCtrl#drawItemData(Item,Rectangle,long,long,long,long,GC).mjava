    void drawItemData(Item item, Rectangle rect, long time0, long time1, long endTime, long selectedTime, GC gc) {
        if (rect.isEmpty())
            return;
        if (time1 <= time0) {
            gc.setBackground(_colors.getBkColor(false, false, false));
            gc.fillRectangle(rect);
            return;
        }

        Utils.init(_rect1, rect);
        boolean selected = item._selected;
        double pixelsPerNanoSec = (rect.width <= RIGHT_MARGIN) ? 0 : (double) (rect.width - RIGHT_MARGIN) / (time1 - time0);
        boolean group = item instanceof GroupItem;

        if (group) {
            // gc.setBackground(_colors.getBkColorGroup(selected, _isInFocus));
            // gc.fillRectangle(rect);
        } else if (item instanceof TraceItem) {
            ITmfTimeAnalysisEntry trace = ((TraceItem) item)._trace;

            int x0 = rect.x;
            List<TimeEvent> list = trace.getTraceEvents();
            // Iterator it = list.iterator();
            int count = list.size();
            ITimeEvent lastEvent = null;
            if (count > 0) {
                ITimeEvent currEvent = list.get(0);
                ITimeEvent nextEvent = null;
                long currEventTime = currEvent.getTime();
                long nextEventTime = currEventTime;
                x0 = rect.x + (int) ((currEventTime - time0) * pixelsPerNanoSec);
                int xEnd = rect.x + (int) ((time1 - time0) * pixelsPerNanoSec);
                int x1 = -1;
                int idx = 1;

                // reduce rect
                _rect1.y += 3;
                _rect1.height -= 6;
                fillSpace(rect, gc, selected, _rect1.x, x0, xEnd);

                // draw event states
                while (x0 <= xEnd && null != currEvent) {
                    boolean stopped = false;// currEvent instanceof
                    // TsfTmTraceDeadEvent;
                    if (idx < count) {
                        nextEvent = list.get(idx);
                        nextEventTime = nextEvent.getTime();
                        idx++;
                    } else if (stopped) {
                        nextEvent = null;
                        nextEventTime = time1;
                    } else {
                        nextEvent = null;
                        nextEventTime = endTime;
                    }
                    x1 = rect.x + (int) ((nextEventTime - time0) * pixelsPerNanoSec);
                    if (x1 >= rect.x) {
                        _rect1.x = x0 >= rect.x ? x0 : rect.x;
                        _rect1.width = (x1 <= xEnd ? x1 : xEnd) - _rect1.x;
                        boolean timeSelected = currEventTime <= selectedTime && selectedTime < nextEventTime;
                        // Trace.debug("Drawing rectangle: " + _rect1.x + ","
                        // + _rect1.y + "," + _rect1.height + ", "
                        // + _rect1.width + "-->"
                        // + ((int) _rect1.x + (int) _rect1.width));
                        utilImpl.drawState(_colors, currEvent, _rect1, gc, selected, false, timeSelected);
                    }
                    lastEvent = currEvent;
                    currEvent = nextEvent;
                    currEventTime = nextEventTime;
                    x0 = x1;
                }
            }

            // fill space after last event
            int xEnd = rect.x + rect.width;
            if (x0 < xEnd) {
                _rect1.x = x0 >= rect.x ? x0 : rect.x;
                _rect1.width = xEnd - _rect1.x;
                gc.setBackground(_colors.getBkColor(selected, _isInFocus, false));
                gc.fillRectangle(_rect1);
                // draw middle line
                gc.setForeground(_colors.getColor(utilImpl.getEventColorVal(lastEvent)));
                int midy = _rect1.y + _rect1.height / 2;
                int lw = gc.getLineWidth();
                gc.setLineWidth(2);
                gc.drawLine(_rect1.x, midy, _rect1.x + _rect1.width, midy);
                gc.setLineWidth(lw);
            }

            // draw focus ares
            Utils.init(_rect1, rect);
            gc.setForeground(_colors.getBkColor(selected, _isInFocus, false));
            int y = _rect1.y;
            gc.drawLine(_rect1.x, y, _rect1.x + _rect1.width, y);
            y++;
            gc.drawLine(_rect1.x, y, _rect1.x + _rect1.width, y);
            y++;
            gc.drawLine(_rect1.x, y, _rect1.x + _rect1.width, y);
            y = _rect1.y + _rect1.height - 1;
            gc.drawLine(_rect1.x, y, _rect1.x + _rect1.width, y);
            y--;
            gc.drawLine(_rect1.x, y, _rect1.x + _rect1.width, y);
            y--;
            gc.drawLine(_rect1.x, y, _rect1.x + _rect1.width, y);
        }

        // draw selected time
        int x = rect.x + (int) ((selectedTime - time0) * pixelsPerNanoSec);
        if (x >= rect.x && x < rect.x + rect.width) {
            gc.setForeground(_colors.getColor(TraceColorScheme.SELECTED_TIME));
            if (group)
                gc.drawLine(x, rect.y + rect.height - 1, x, rect.y + rect.height);
            else
                gc.drawLine(x, rect.y, x, rect.y + rect.height);
        }
    }

