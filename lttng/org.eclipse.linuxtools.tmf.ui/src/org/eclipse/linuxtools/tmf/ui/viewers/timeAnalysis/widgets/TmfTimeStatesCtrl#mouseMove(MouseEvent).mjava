	@Override
	public void mouseMove(MouseEvent e) {
		if (null == _timeProvider)
			return;
		Point size = getCtrlSize();
		if (1 == _dragState) {
			int nameWidth = _timeProvider.getNameSpace();
			int x = e.x - nameWidth;
			if (x > 0 && size.x > nameWidth && _dragX != x) {
				_dragX = x;
				double pixelsPerNanoSec = (size.x - nameWidth <= RIGHT_MARGIN) ? 0
						: (double) (size.x - nameWidth - RIGHT_MARGIN) / (_time1bak - _time0bak);
				long timeDelta = (long) ((pixelsPerNanoSec == 0) ? 0 : ((_dragX - _dragX0) / pixelsPerNanoSec));
				long time1 = _time1bak - timeDelta;
				long maxTime = _timeProvider.getMaxTime();
				if (time1 > maxTime)
					time1 = maxTime;
				long time0 = time1 - (_time1bak - _time0bak);
				if (time0 < _timeProvider.getMinTime()) {
					time0 = _timeProvider.getMinTime();
					time1 = time0 + (_time1bak - _time0bak);
				}
				_timeProvider.setStartFinishTime(time0, time1);
			}
		} else if (3 == _dragState) {
			_dragX = e.x;
			_timeProvider.setNameSpace(_hitIdx + _dragX - _dragX0);
		} else if (0 == _dragState) {
			boolean mouseHover = hitSplitTest(e.x, e.y) > 0;
			if (_mouseHover != mouseHover)
				redraw();
			_mouseHover = mouseHover;
			// Make sure any time changes are notified to the application e.g.
			// getting back from the horizontal scroll bar or zoomed using the
			// mouse wheel
			_timeProvider.notifyStartFinishTime();
		}
		updateCursor(e.x, e.y);
	}

