    /**
     * Draw the state (color fill)
     *
     * @param colors
     *            Color scheme
     * @param event
     *            Time event for which we're drawing the state
     * @param rect
     *            Where to draw
     * @param gc
     *            Graphics context
     * @param selected
     *            Is this time event currently selected (so it appears
     *            highlighted)
     * @param timeSelected
     *            Is the timestamp currently selected
     * @return true if the state was drawn
     * @since 2.0
     */
    protected boolean drawState(TimeGraphColorScheme colors, ITimeEvent event,
            Rectangle rect, GC gc, boolean selected, boolean timeSelected) {

        int colorIdx = fTimeGraphProvider.getStateTableIndex(event);
        if (colorIdx < 0 && colorIdx != ITimeGraphPresentationProvider.TRANSPARENT) {
            return false;
        }
        boolean visible = rect.width == 0 ? false : true;
        Color black =  Display.getDefault().getSystemColor(SWT.COLOR_BLACK);
        gc.setForeground(black);

        if (visible) {
            if (colorIdx == ITimeGraphPresentationProvider.TRANSPARENT) {
                // Only draw the top and bottom borders
                gc.drawLine(rect.x, rect.y, rect.x + rect.width - 1, rect.y);
                gc.drawLine(rect.x, rect.y + rect.height - 1, rect.x + rect.width - 1, rect.y + rect.height - 1);
                if (rect.width == 1) {
                    gc.drawPoint(rect.x, rect.y - 2);
                }
                return false;
            }
            Color stateColor = null;
            if (colorIdx < fEventColorMap.length) {
                stateColor = fEventColorMap[colorIdx];
            } else {
                stateColor = black;
            }

            boolean reallySelected = timeSelected && selected;
            // fill all rect area
            gc.setBackground(stateColor);
            gc.fillRectangle(rect);

            if (reallySelected) {
                gc.drawLine(rect.x, rect.y - 1, rect.x + rect.width - 1, rect.y - 1);
                gc.drawLine(rect.x, rect.y + rect.height, rect.x + rect.width - 1, rect.y + rect.height);
            }
        } else {
            gc.drawPoint(rect.x, rect.y - 2);
        }
        fTimeGraphProvider.postDrawEvent(event, rect, gc);
        return visible;
    }

