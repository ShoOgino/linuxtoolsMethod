    /**
     * Constructs a new instance of this class given its parent and a style
     * value describing its behavior and appearance.
     *
     * @param parent
     *            a widget which will be the parent of the new instance (cannot
     *            be null)
     * @param style
     *            the style of widget to construct
     * @param weights
     *            The relative weights of each side of the sash form
     * @since 3.0
     */
    public TimeGraphCombo(Composite parent, int style, int[] weights) {
        super(parent, style);
        setLayout(new FillLayout());

        final SashForm sash = new SashForm(this, SWT.NONE);

        fTreeViewer = new TreeViewer(sash, SWT.FULL_SELECTION | SWT.H_SCROLL);
        final Tree tree = fTreeViewer.getTree();
        tree.setHeaderVisible(true);
        tree.setLinesVisible(true);

        fTimeGraphViewer = new TimeGraphViewer(sash, SWT.NONE);
        fTimeGraphViewer.setItemHeight(getItemHeight(tree));
        fTimeGraphViewer.setHeaderHeight(tree.getHeaderHeight());
        fTimeGraphViewer.setBorderWidth(tree.getBorderWidth());
        fTimeGraphViewer.setNameWidthPref(0);

        fFilter = new RawViewerFilter();
        addFilter(fFilter);

        fFilterDialog = new TimeGraphFilterDialog(getShell());

        // Feature in Windows. The tree vertical bar reappears when
        // the control is resized so we need to hide it again.
        // Bug in Linux. The tree header height is 0 in constructor,
        // so we need to reset it later when the control is resized.
        tree.addControlListener(new ControlAdapter() {
            private int depth = 0;
            @Override
            public void controlResized(ControlEvent e) {
                if (depth == 0) {
                    depth++;
                    tree.getVerticalBar().setEnabled(false);
                    // this can trigger controlResized recursively
                    tree.getVerticalBar().setVisible(false);
                    depth--;
                }
                fTimeGraphViewer.setHeaderHeight(tree.getHeaderHeight());
            }
        });

        // ensure synchronization of expanded items between tree and time graph
        fTreeViewer.addTreeListener(new ITreeViewerListener() {
            @Override
            public void treeCollapsed(TreeExpansionEvent event) {
                fTimeGraphViewer.setExpandedState((ITimeGraphEntry) event.getElement(), false);
                List<TreeItem> treeItems = getVisibleExpandedItems(tree);
                if (treeItems.size() == 0) {
                    return;
                }
                TreeItem treeItem = treeItems.get(fTimeGraphViewer.getTopIndex());
                tree.setTopItem(treeItem);
            }

            @Override
            public void treeExpanded(TreeExpansionEvent event) {
                ITimeGraphEntry entry = (ITimeGraphEntry) event.getElement();
                fTimeGraphViewer.setExpandedState(entry, true);
                for (ITimeGraphEntry child : entry.getChildren()) {
                    boolean expanded = fTreeViewer.getExpandedState(child);
                    fTimeGraphViewer.setExpandedState(child, expanded);
                }
                List<TreeItem> treeItems = getVisibleExpandedItems(tree);
                if (treeItems.size() == 0) {
                    return;
                }
                final TreeItem treeItem = treeItems.get(fTimeGraphViewer.getTopIndex());
                // queue the top item update because the tree can change its top item
                // autonomously immediately after the listeners have been notified
                getDisplay().asyncExec(new Runnable() {
                    @Override
                    public void run() {
                        tree.setTopItem(treeItem);
                    }});
            }
        });

        // ensure synchronization of expanded items between tree and time graph
        fTimeGraphViewer.addTreeListener(new ITimeGraphTreeListener() {
            @Override
            public void treeCollapsed(TimeGraphTreeExpansionEvent event) {
                fTreeViewer.setExpandedState(event.getEntry(), false);
            }

            @Override
            public void treeExpanded(TimeGraphTreeExpansionEvent event) {
                ITimeGraphEntry entry = event.getEntry();
                fTreeViewer.setExpandedState(entry, true);
                for (ITimeGraphEntry child : entry.getChildren()) {
                    boolean expanded = fTreeViewer.getExpandedState(child);
                    fTimeGraphViewer.setExpandedState(child, expanded);
                }
            }
        });

        // prevent mouse button from selecting a filler tree item
        tree.addListener(SWT.MouseDown, new Listener() {
            @Override
            public void handleEvent(Event event) {
                TreeItem treeItem = tree.getItem(new Point(event.x, event.y));
                if (treeItem == null || treeItem.getData() == FILLER) {
                    event.doit = false;
                    List<TreeItem> treeItems = getVisibleExpandedItems(tree);
                    if (treeItems.size() == 0) {
                        fTreeViewer.setSelection(new StructuredSelection());
                        fTimeGraphViewer.setSelection(null);
                        return;
                    }
                    // this prevents from scrolling up when selecting
                    // the partially visible tree item at the bottom
                    tree.select(treeItems.get(treeItems.size() - 1));
                    fTreeViewer.setSelection(new StructuredSelection());
                    fTimeGraphViewer.setSelection(null);
                }
            }
        });

        // prevent mouse wheel from scrolling down into filler tree items
        tree.addListener(SWT.MouseWheel, new Listener() {
            @Override
            public void handleEvent(Event event) {
                event.doit = false;
                Slider scrollBar = fTimeGraphViewer.getVerticalBar();
                fTimeGraphViewer.setTopIndex(scrollBar.getSelection() - event.count);
                List<TreeItem> treeItems = getVisibleExpandedItems(tree);
                if (treeItems.size() == 0) {
                    return;
                }
                TreeItem treeItem = treeItems.get(fTimeGraphViewer.getTopIndex());
                tree.setTopItem(treeItem);
            }
        });

        // prevent key stroke from selecting a filler tree item
        tree.addListener(SWT.KeyDown, new Listener() {
            @Override
            public void handleEvent(Event event) {
                List<TreeItem> treeItems = getVisibleExpandedItems(tree);
                if (treeItems.size() == 0) {
                    fTreeViewer.setSelection(new StructuredSelection());
                    event.doit = false;
                    return;
                }
                if (event.keyCode == SWT.ARROW_DOWN) {
                    int index = Math.min(fTimeGraphViewer.getSelectionIndex() + 1, treeItems.size() - 1);
                    fTimeGraphViewer.setSelection((ITimeGraphEntry) treeItems.get(index).getData());
                    event.doit = false;
                } else if (event.keyCode == SWT.PAGE_DOWN) {
                    int height = tree.getSize().y - tree.getHeaderHeight() - tree.getHorizontalBar().getSize().y;
                    int countPerPage = height / getItemHeight(tree);
                    int index = Math.min(fTimeGraphViewer.getSelectionIndex() + countPerPage - 1, treeItems.size() - 1);
                    fTimeGraphViewer.setSelection((ITimeGraphEntry) treeItems.get(index).getData());
                    event.doit = false;
                } else if (event.keyCode == SWT.END) {
                    fTimeGraphViewer.setSelection((ITimeGraphEntry) treeItems.get(treeItems.size() - 1).getData());
                    event.doit = false;
                }
                TreeItem treeItem = treeItems.get(fTimeGraphViewer.getTopIndex());
                tree.setTopItem(treeItem);
                if (fTimeGraphViewer.getSelectionIndex() >= 0) {
                    fTreeViewer.setSelection(new StructuredSelection(fTimeGraphViewer.getSelection()));
                } else {
                    fTreeViewer.setSelection(new StructuredSelection());
                }
            }
        });

        // ensure alignment of top item between tree and time graph
        fTimeGraphViewer.getTimeGraphControl().addControlListener(new ControlAdapter() {
            @Override
            public void controlResized(ControlEvent e) {
                List<TreeItem> treeItems = getVisibleExpandedItems(tree);
                if (treeItems.size() == 0) {
                    return;
                }
                TreeItem treeItem = treeItems.get(fTimeGraphViewer.getTopIndex());
                tree.setTopItem(treeItem);
            }
        });

        // ensure synchronization of selected item between tree and time graph
        fTreeViewer.addSelectionChangedListener(new ISelectionChangedListener() {
            @Override
            public void selectionChanged(SelectionChangedEvent event) {
                if (fInhibitTreeSelection) {
                    return;
                }
                if (event.getSelection() instanceof IStructuredSelection) {
                    Object selection = ((IStructuredSelection) event.getSelection()).getFirstElement();
                    if (selection instanceof ITimeGraphEntry) {
                        fTimeGraphViewer.setSelection((ITimeGraphEntry) selection);
                    }
                    List<TreeItem> treeItems = getVisibleExpandedItems(tree);
                    if (treeItems.size() == 0) {
                        return;
                    }
                    TreeItem treeItem = treeItems.get(fTimeGraphViewer.getTopIndex());
                    tree.setTopItem(treeItem);
                }
            }
        });

        // ensure synchronization of selected item between tree and time graph
        fTimeGraphViewer.addSelectionListener(new ITimeGraphSelectionListener() {
            @Override
            public void selectionChanged(TimeGraphSelectionEvent event) {
                ITimeGraphEntry entry = fTimeGraphViewer.getSelection();
                fInhibitTreeSelection = true; // block the tree selection changed listener
                if (entry != null) {
                    StructuredSelection selection = new StructuredSelection(entry);
                    fTreeViewer.setSelection(selection);
                } else {
                    fTreeViewer.setSelection(new StructuredSelection());
                }
                fInhibitTreeSelection = false;
                List<TreeItem> treeItems = getVisibleExpandedItems(tree);
                if (treeItems.size() == 0) {
                    return;
                }
                TreeItem treeItem = treeItems.get(fTimeGraphViewer.getTopIndex());
                tree.setTopItem(treeItem);
            }
        });

        // ensure alignment of top item between tree and time graph
        fTimeGraphViewer.getVerticalBar().addSelectionListener(new SelectionAdapter() {
            @Override
            public void widgetSelected(SelectionEvent e) {
                List<TreeItem> treeItems = getVisibleExpandedItems(tree);
                if (treeItems.size() == 0) {
                    return;
                }
                TreeItem treeItem = treeItems.get(fTimeGraphViewer.getTopIndex());
                tree.setTopItem(treeItem);
            }
        });

        // ensure alignment of top item between tree and time graph
        fTimeGraphViewer.getTimeGraphControl().addMouseWheelListener(new MouseWheelListener() {
            @Override
            public void mouseScrolled(MouseEvent e) {
                List<TreeItem> treeItems = getVisibleExpandedItems(tree);
                if (treeItems.size() == 0) {
                    return;
                }
                TreeItem treeItem = treeItems.get(fTimeGraphViewer.getTopIndex());
                tree.setTopItem(treeItem);
            }
        });

        // ensure the tree has focus control when mouse is over it if the time graph had control
        fTreeViewer.getControl().addMouseTrackListener(new MouseTrackAdapter() {
            @Override
            public void mouseEnter(MouseEvent e) {
                if (fTimeGraphViewer.getTimeGraphControl().isFocusControl()) {
                    fTreeViewer.getControl().setFocus();
                }
            }
        });

        // ensure the time graph has focus control when mouse is over it if the tree had control
        fTimeGraphViewer.getTimeGraphControl().addMouseTrackListener(new MouseTrackAdapter() {
            @Override
            public void mouseEnter(MouseEvent e) {
                if (fTreeViewer.getControl().isFocusControl()) {
                    fTimeGraphViewer.getTimeGraphControl().setFocus();
                }
            }
        });
        fTimeGraphViewer.getTimeGraphScale().addMouseTrackListener(new MouseTrackAdapter() {
            @Override
            public void mouseEnter(MouseEvent e) {
                if (fTreeViewer.getControl().isFocusControl()) {
                    fTimeGraphViewer.getTimeGraphControl().setFocus();
                }
            }
        });

        // ensure the time graph item heights are equal to the tree item heights
        tree.addPaintListener(new PaintListener() {
            @Override
            public void paintControl(PaintEvent e) {
                List<TreeItem> items = getVisibleExpandedItems(tree);
                for (int i = 0; i < items.size() - 1; i++) {
                    TreeItem item = items.get(i);
                    /*
                     * Bug in Linux. The method getBounds doesn't always return the correct height.
                     * Use the difference of y position between items to calculate the height.
                     */
                    Integer itemHeight = items.get(i + 1).getBounds().y - item.getBounds().y;
                    if (!itemHeight.equals(item.getData(ITEM_HEIGHT))) {
                        ITimeGraphEntry entry = (ITimeGraphEntry) item.getData();
                        if (fTimeGraphViewer.getTimeGraphControl().setItemHeight(entry, itemHeight)) {
                            item.setData(ITEM_HEIGHT, itemHeight);
                        }
                    }
                }
            }
        });

        // The filler rows are required to ensure alignment when the tree does not have a
        // visible horizontal scroll bar. The tree does not allow its top item to be set
        // to a value that would cause blank space to be drawn at the bottom of the tree.
        fNumFillerRows = Display.getDefault().getBounds().height / getItemHeight(tree);

        sash.setWeights(weights);
    }

