    /**
     * Create the initial tree from a trace.
     */
    private synchronized void createTable() {

        long ts = fCurrentTimestamp;

        if (fTrace == null) {
            return;
        }

        /* Clear the table, in case a trace was previously using it */
        fTree.getDisplay().asyncExec(new Runnable() {
            @Override
            public void run() {
                fTree.setItemCount(0);
            }
        });

        for (final ITmfTrace currentTrace : TmfTraceManager.getTraceSet(fTrace)) {
            /*
             * We will first do all the queries for this trace, then update that
             * sub-tree in the UI thread.
             */
            final Map<String, ITmfStateSystem> sss = currentTrace.getStateSystems();
            final Map<String, List<ITmfStateInterval>> fullStates =
                    new LinkedHashMap<String, List<ITmfStateInterval>>();
            for (Map.Entry<String, ITmfStateSystem> entry : sss.entrySet()) {
                String ssName = entry.getKey();
                ITmfStateSystem ss = entry.getValue();
                ss.waitUntilBuilt();
                if (ts == -1 || ts < ss.getStartTime() || ts > ss.getCurrentEndTime()) {
                    ts = ss.getStartTime();
                }
                try {
                    fullStates.put(ssName, ss.queryFullState(ts));
                } catch (TimeRangeException e) {
                    /* We already checked the limits ourselves */
                    throw new RuntimeException();
                } catch (StateSystemDisposedException e) {
                    /* Probably shutting down, cancel and return */
                    return;
                }
            }

            /* Update the table (in the UI thread) */
            fTree.getDisplay().asyncExec(new Runnable() {
                @Override
                public void run() {
                    TreeItem traceRoot = new TreeItem(fTree, SWT.NONE);
                    traceRoot.setText(ATTRIBUTE_NAME_COL, currentTrace.getName());

                    for (Map.Entry<String, ITmfStateSystem> entry : sss.entrySet()) {
                        String ssName = entry.getKey();
                        ITmfStateSystem ss = entry.getValue();
                        List<ITmfStateInterval> fullState = fullStates.get(ssName);

                        /* Root item of the current state system */
                        TreeItem item = new TreeItem(traceRoot, SWT.NONE);

                        /* Name of the SS goes in the first column */
                        item.setText(ATTRIBUTE_NAME_COL, ssName);

                        /*
                         * Calling with quark '-1' here to start with the root
                         * attribute, then it will be called recursively.
                         */
                        addChildren(ss, fullState, -1, item);
                    }

                    /* Expand the first-level tree items */
                    for (TreeItem item : fTree.getItems()) {
                        item.setExpanded(true);
                    }
                    packColumns();

                    if (filterStatus) {
                        filterChildren(traceRoot);
                    }
                }
            });
        }
    }

