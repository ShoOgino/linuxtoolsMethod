    /**
     * Create the initial tree from a trace.
     */
    private synchronized void createTable() {

        long ts = fCurrentTimestamp;

        if (fTrace == null) {
            return;
        }

        /* Clear the table, in case a trace was previously using it */
        fTree.getDisplay().asyncExec(new Runnable() {
            @Override
            public void run() {
                fTree.setItemCount(0);
            }
        });

        for (final ITmfTrace currentTrace : TmfTraceManager.getTraceSet(fTrace)) {
            /*
             * We will first do all the queries for this trace, then update that
             * sub-tree in the UI thread.
             */
            Iterable<ITmfAnalysisModuleWithStateSystems> modules = currentTrace.getAnalysisModulesOfClass(ITmfAnalysisModuleWithStateSystems.class);
            final Map<String, ITmfStateSystem> sss = new HashMap<>();
            final Map<String, List<ITmfStateInterval>> fullStates =
                    new LinkedHashMap<>();
            for (ITmfAnalysisModuleWithStateSystems module : modules) {
                /*
                 * FIXME: For now, this view is a way to execute and display
                 * state system. But with phase 2 of analysis API, we won't want
                 * to run state system that have not been requested. We will
                 * leave the title, but there won't be anything underneath.
                 */
                module.schedule();
                module.waitForCompletion(new NullProgressMonitor());
                for (ITmfStateSystem ss : module.getStateSystems()) {
                    if (ss == null) {
                        continue;
                    }
                    String ssName = module.getStateSystemId(ss);
                    sss.put(ssName, ss);

                    if (ts == -1 || ts < ss.getStartTime() || ts > ss.getCurrentEndTime()) {
                        ts = ss.getStartTime();
                    }
                    try {
                        fullStates.put(ssName, ss.queryFullState(ts));
                    } catch (TimeRangeException e) {
                        /* We already checked the limits ourselves */
                        throw new IllegalStateException();
                    } catch (StateSystemDisposedException e) {
                        /* Probably shutting down, cancel and return */
                        return;
                    }
                }
            }

            /* Update the table (in the UI thread) */
            fTree.getDisplay().asyncExec(new Runnable() {
                @Override
                public void run() {
                    TreeItem traceRoot = new TreeItem(fTree, SWT.NONE);
                    traceRoot.setText(ATTRIBUTE_NAME_COL, currentTrace.getName());

                    for (Map.Entry<String, ITmfStateSystem> entry : sss.entrySet()) {
                        String ssName = entry.getKey();
                        ITmfStateSystem ss = entry.getValue();
                        List<ITmfStateInterval> fullState = fullStates.get(ssName);

                        /* Root item of the current state system */
                        TreeItem item = new TreeItem(traceRoot, SWT.NONE);

                        /* Name of the SS goes in the first column */
                        item.setText(ATTRIBUTE_NAME_COL, ssName);

                        /*
                         * Calling with quark '-1' here to start with the root
                         * attribute, then it will be called recursively.
                         */
                        if (ss != null) {
                            addChildren(ss, fullState, -1, item);
                        }
                    }

                    /* Expand the first-level tree items */
                    for (TreeItem item : fTree.getItems()) {
                        item.setExpanded(true);
                    }
                    packColumns();

                    if (filterStatus) {
                        filterChildren(traceRoot);
                    }
                }
            });
        }
    }

