    /**
     * Update the tree, which means keep the tree of attributes in the first
     * column as-is, but update the values to the ones at a new timestamp.
     */
    private synchronized void updateTable() {
        ITmfTrace[] traces = TmfTraceManager.getTraceSet(fTrace);
        long ts = fCurrentTimestamp;

        /* For each trace... */
        for (int traceNb = 0; traceNb < traces.length; traceNb++) {
            Iterable<ITmfAnalysisModuleWithStateSystems> modules = traces[traceNb].getAnalysisModulesOfClass(ITmfAnalysisModuleWithStateSystems.class);

            /* For each state system associated with this trace... */
            int ssNb = 0;
            for (ITmfAnalysisModuleWithStateSystems module : modules) {

                /*
                 * Even though we only use the value, it just feels safer to
                 * iterate the same way as before to keep the order the same.
                 */
                for (final ITmfStateSystem ss : module.getStateSystems()) {
                    final int traceNb1 = traceNb;
                    final int ssNb1 = ssNb;
                    if (ss != null) {
                        final String ssName = ss.getSSID();
                        ts = (ts == -1 ? ss.getStartTime() : ts);
                        try {
                            final List<ITmfStateInterval> fullState = ss.queryFullState(ts);
                            fTree.getDisplay().asyncExec(new Runnable() {
                                @Override
                                public void run() {
                                    /*
                                     * Get the tree item of the relevant state
                                     * system
                                     */
                                    TreeItem traceItem = fTree.getItem(traceNb1);
                                    /* Find the item corresponding to this state system */
                                    TreeItem item = null;
                                    for (TreeItem ssItem : traceItem.getItems()) {
                                        if (ssItem.getText(ATTRIBUTE_NAME_COL).equals(ssName)) {
                                            item = ssItem;
                                            break;
                                        }
                                    }
                                    if (item != null) {
                                        /* Update it, then its children, recursively */
                                        item.setText(VALUE_COL, emptyString);
                                        updateChildren(ss, fullState, -1, item);
                                    }
                                }
                            });

                        } catch (TimeRangeException e) {
                            /*
                             * This can happen in an experiment, if the user
                             * selects a range valid in the experiment, but this
                             * specific does not exist. Print "out-of-range"
                             * into all the values.
                             */
                            fTree.getDisplay().asyncExec(new Runnable() {
                                @Override
                                public void run() {
                                    TreeItem traceItem = fTree.getItem(traceNb1);
                                    TreeItem item = traceItem.getItem(ssNb1);
                                    markOutOfRange(item);
                                }
                            });
                        } catch (StateSystemDisposedException e) {
                            return;
                        }
                    }

                    ssNb++;
                }
            }
        }
    }

