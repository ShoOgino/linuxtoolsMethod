    private void buildThreadList(final ITmfTrace trace, IProgressMonitor monitor) {
        fStartTime = Long.MAX_VALUE;
        fEndTime = Long.MIN_VALUE;
        ITmfTrace[] traces = TmfTraceManager.getTraceSet(trace);
        ArrayList<TraceEntry> entryList = new ArrayList<>();
        for (ITmfTrace aTrace : traces) {
            if (monitor.isCanceled()) {
                return;
            }
            AbstractCallStackAnalysis module = getCallStackModule(trace);
            if (module == null) {
                return;
            }
            ITmfStateSystem ss = module.getStateSystem();
            if (ss == null) {
                addUnavailableEntry(aTrace, entryList);
                continue;
            }
            ss.waitUntilBuilt();
            if (ss.isCancelled()) {
                addUnavailableEntry(aTrace, entryList);
                continue;
            }
            long startTime = ss.getStartTime();
            long endTime = ss.getCurrentEndTime() + 1;
            fStartTime = Math.min(fStartTime, startTime);
            fEndTime = Math.max(fEndTime, endTime);
            String[] threadPaths = module.getThreadsPattern();
            List<Integer> threadQuarks = ss.getQuarks(threadPaths);
            TraceEntry traceEntry = new TraceEntry(trace.getName(), startTime, endTime);
            entryList.add(traceEntry);
            for (int i = 0; i < threadQuarks.size(); i++) {
                if (monitor.isCanceled()) {
                    return;
                }
                int threadQuark = threadQuarks.get(i);
                try {
                    String[] callStackPath = module.getCallStackPath();
                    int callStackQuark = ss.getQuarkRelative(threadQuark, callStackPath);
                    String threadName = ss.getAttributeName(threadQuark);
                    ThreadEntry threadEntry = new ThreadEntry(ss, threadName, callStackQuark, startTime, endTime);
                    traceEntry.addChild(threadEntry);
                    int level = 1;
                    for (int stackLevelQuark : ss.getSubAttributes(callStackQuark, false)) {
                        CallStackEntry callStackEntry = new CallStackEntry(threadName, stackLevelQuark, level++, aTrace, ss);
                        threadEntry.addChild(callStackEntry);
                    }
                } catch (AttributeNotFoundException e) {
                    Activator.getDefault().logError("Error querying state system", e); //$NON-NLS-1$
                }
            }
        }
        synchronized (fEntryListMap) {
            fEntryListMap.put(trace, new ArrayList<>(entryList));
        }
        if (trace == fTrace) {
            refresh();
        }
        for (TraceEntry traceEntry : entryList) {
            for (ITimeGraphEntry threadEntry : traceEntry.getChildren()) {
                for (ITimeGraphEntry callStackEntry : threadEntry.getChildren()) {
                    if (monitor.isCanceled()) {
                        return;
                    }
                    buildStatusEvents(trace, (CallStackEntry) callStackEntry, monitor);
                }
            }
        }
    }

