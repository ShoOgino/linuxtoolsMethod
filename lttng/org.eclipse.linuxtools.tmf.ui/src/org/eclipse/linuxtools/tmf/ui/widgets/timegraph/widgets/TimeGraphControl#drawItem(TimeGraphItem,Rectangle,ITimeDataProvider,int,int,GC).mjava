    /**
     * Draws the item
     * 
     * @param item the item to draw
     * @param bounds the container rectangle
     * @param i the item index
     * @param nameSpace the name space
     * @param gc
     */
    public void drawItem(TimeGraphItem item, Rectangle bounds, ITimeDataProvider timeProvider, int i, int nameSpace, GC gc) {
        long time0 = timeProvider.getTime0();
        long time1 = timeProvider.getTime1();
        long endTime = timeProvider.getEndTime();
        long selectedTime = timeProvider.getSelectedTime();

        Rectangle nameRect = getNameRect(bounds, i, nameSpace);
        if (nameRect.y >= bounds.y + bounds.height) {
            return;
        }

        if (item._trace.getTimeEventsIterator() == null) {
            Rectangle statesRect = getStatesRect(bounds, i, nameSpace);
            nameRect.width += statesRect.width;
            drawName(item, nameRect, gc);
        } else {
            drawName(item, nameRect, gc);
        }
        Rectangle rect = getStatesRect(bounds, i, nameSpace);
        if (rect.isEmpty())
            return;
        if (time1 <= time0) {
            gc.setBackground(_colors.getBkColor(false, false, false));
            gc.fillRectangle(rect);
            return;
        }

        // Initialize _rect1 to same values as enclosing rectangle rect
        Rectangle stateRect = Utils.clone(rect);
        boolean selected = item._selected;
        // K pixels per second
        double pixelsPerNanoSec = (rect.width <= RIGHT_MARGIN) ? 0 : (double) (rect.width - RIGHT_MARGIN) / (time1 - time0);

        boolean group = item._trace.getTimeEventsIterator() == null;

        if (group) {
            // gc.setBackground(_colors.getBkColorGroup(selected, _isInFocus));
            // gc.fillRectangle(rect);
        } else {
            ITimeGraphEntry trace = item._trace;

            double x0 = rect.x;
            long maxDuration = (timeProvider.getTimeSpace() == 0) ? Long.MAX_VALUE : 1 * (time1 - time0) / timeProvider.getTimeSpace();
            Iterator<ITimeEvent> iterator = trace.getTimeEventsIterator(time0, time1, maxDuration);
            // Drawing rectangle is smaller than reserved space
            stateRect.y += 3;
            stateRect.height -= 6;

            // Clean up to empty line to draw on top
            int xEnd = rect.x + rect.width;
            fillSpace(rect, gc, selected);
            if (iterator.hasNext()) {
                ITimeEvent currEvent = iterator.next();
                ITimeEvent nextEvent = null;
                long currEventTime = currEvent.getTime();
                long currEventDuration = currEvent.getDuration();
                // initial value
                long nextEventTime = currEventTime;
                // x0 - Points to the beginning of the event being drawn
                double step = (double) ((currEventTime - time0) * pixelsPerNanoSec);
                x0 = rect.x + step;
                // xEnd - Points to the end of the events rectangle
                double x1 = -1;
                double xNext = 0;

                // draw event states
                while (/* x0 <= xEnd && */null != currEvent) {
                    boolean stopped = false;// currEvent instanceof
                    // refresh current event duration as the loop moves
                    currEventDuration = currEvent.getDuration();
                    // TsfTmTraceDeadEvent;
                    if (iterator.hasNext()) {
                        nextEvent = iterator.next();
                        nextEventTime = nextEvent.getTime();
                    } else if (stopped) {
                        nextEvent = null;
                        nextEventTime = time1;
                    } else {
                        nextEvent = null;
                        nextEventTime = endTime;
                    }

                    // Calculate position to next event
                    xNext = rect.x + (double) ((nextEventTime - time0) * pixelsPerNanoSec);

                    // Calculate end position of current event
                    if (currEventDuration < 0) {
                        x1 = rect.x + (double) ((nextEventTime - time0) * pixelsPerNanoSec);
                    } else if (currEventDuration == 0) {
                        x1 = x0;
                    } else {
                        x1 = x0 + (double) ((currEventDuration) * pixelsPerNanoSec);
                    }

                    // If event end position x1 further away than start position
                    // of next event, cut width till next event
                    if (currEventDuration != 0) {
                        x1 = x1 > xNext ? xNext : x1;
                    }
                    // if event end boundary is within time range
                    if (x1 >= rect.x && x0 <= xEnd) {
                        if (currEventDuration != 0) {
                            x0 = (double) (x0 >= rect.x ? x0 : rect.x);
                            stateRect.width = (int) ((x1 <= xEnd ? x1 : xEnd) - x0);
                        } else {
                            stateRect.width = 1;
                        }
                        stateRect.width = Math.max(getMinimumItemWidth(), stateRect.width);
                        stateRect.x = (int) x0;
                        boolean timeSelected = currEventTime <= selectedTime && selectedTime < nextEventTime;
                        fTimeGraphProvider.drawState(_colors, currEvent, stateRect, gc, selected, false, timeSelected);
                        // Advance rectangle to next start position and Fill
                        // with space until next event
                        stateRect.x += stateRect.width;
                        x0 = stateRect.x;
                    }

                    // lastEvent = currEvent;
                    currEvent = nextEvent;
                    currEventTime = nextEventTime;
                    // Move x0 to the beginning of next event
                    x0 = rect.x + (double) ((nextEventTime - time0) * pixelsPerNanoSec);
                }
            }
        }
    }

