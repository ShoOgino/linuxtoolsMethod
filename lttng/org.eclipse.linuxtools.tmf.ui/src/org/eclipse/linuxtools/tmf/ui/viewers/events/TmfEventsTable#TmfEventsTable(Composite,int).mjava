    public TmfEventsTable(Composite parent, int cacheSize) {
        super("TmfEventsTable");
        
        fCacheSize = cacheSize;
        
//        fShell = parent.getShell();
        
        // Create a virtual table
        // TODO: change SINGLE to MULTI line selection and adjust the selection listener
        final int style = SWT.SINGLE | SWT.FULL_SELECTION | SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER | SWT.VIRTUAL;
        fTable = new Table(parent, style);

        // Set the table layout
        GridData layoutData = new GridData(SWT.FILL, SWT.FILL, true, true);
        fTable.setLayoutData(layoutData);

        // Some cosmetic enhancements
        fTable.setHeaderVisible(true);
        fTable.setLinesVisible(true);

        // Set the columns
        createColumnHeaders(fTable);

        // Handle the table item requests 
        fTable.addSelectionListener(new SelectionAdapter() {

            @Override
            public void widgetSelected(SelectionEvent e) {
                TmfTimestamp ts = (TmfTimestamp) fTable.getSelection()[0].getData();
                broadcast(new TmfTimeSynchSignal(fTable, ts));
            }
        });

        // Handle the table item requests 
        fTable.addListener(SWT.SetData, new Listener() {

            @SuppressWarnings("unchecked")
			public void handleEvent(Event event) {

                final TableItem item = (TableItem) event.item;
                final int index = fTable.indexOf(item);

                // Note: this works because handleEvent() is called once for each row, in sequence  
                if ((index >= cacheStartIndex ) && (index < cacheEndIndex)) {
                    int i = index - cacheStartIndex;
                    item.setText(extractItemFields(cache[i]));
                    item.setData(new TmfTimestamp(cache[i].getTimestamp()));
                    return;
                }

                TmfDataRequest<TmfEvent> request = new TmfDataRequest<TmfEvent>(TmfEvent.class, index, fCacheSize) {
                    @Override
                    public void handleData() {
                        TmfEvent[] tmpEvent = getData();
                        if ((tmpEvent != null) && (tmpEvent.length > 0)) {
                            cache = tmpEvent;
                            cacheStartIndex = index;
                            cacheEndIndex = index + tmpEvent.length;
                        }
                    }
                };
                ((ITmfDataProvider<TmfEvent>) fTrace).sendRequest(request);
                try {
                    request.waitForCompletion();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                
                if (cache[0] != null && cacheStartIndex == index) {
                    item.setText(extractItemFields(cache[0]));
                    item.setData(new TmfTimestamp(cache[0].getTimestamp()));
                    packColumns(fTable);
                }
                
            }
        });

        fTable.setItemCount(0);
    }

