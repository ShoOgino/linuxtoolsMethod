    /**
     * Builds the time array based on the list of graph nodes.
     *
     * @return the time array else empty list.
     */
    protected List<SDTimeEvent> buildTimeArray() {
        if (!fHasChilden) {
            return new ArrayList<SDTimeEvent>();
        }

        Iterator<String> it = fForwardSort.keySet().iterator();
        List<SDTimeEvent> timeArray = new ArrayList<SDTimeEvent>();
        while (it.hasNext()) {
            String nodeType = it.next();
            List<GraphNode> list = fNodes.get(nodeType);
            for (int i = 0; i < list.size(); i++) {
                Object timedNode = list.get(i);
                if ((timedNode instanceof ITimeRange) && ((ITimeRange) timedNode).hasTimeInfo()) {
                    int event = list.get(i).getStartOccurrence();
                    ITmfTimestamp time = ((ITimeRange) list.get(i)).getStartTime();
                    SDTimeEvent f = new SDTimeEvent(time, event, (ITimeRange) list.get(i));
                    timeArray.add(f);
                    if (event != list.get(i).getEndOccurrence()) {
                        event = ((AsyncMessage) list.get(i)).getEndOccurrence();
                        time = ((ITimeRange) list.get(i)).getEndTime();
                        f = new SDTimeEvent(time, event, (ITimeRange) list.get(i));
                        timeArray.add(f);
                    }
                }
            }
        }
        return timeArray;
    }

