	/**
	 * N means: <list> <li>-1: Previous Event</li> <li>0: Current Event</li> <li>
	 * 1: Next Event</li> <li>2: Previous Event when located in a non Event Area
	 * </list>
	 * 
	 * @param thread
	 * @param time
	 * @param n
	 * @return
	 */
	static ITimeEvent findEvent(ITmfTimeAnalysisEntry thread, long time, int n) {
		if (null == thread)
			return null;
		List<TimeEvent> list = thread.getTraceEvents();
		Iterator<TimeEvent> it = list.iterator();
		ITimeEvent event = null;
		ITimeEvent prevEvent = null;
		ITimeEvent nextEvent = null;
		if (it.hasNext()) {
			event = (ITimeEvent) it.next();
			long currStartTime = event.getTime();
			long currEndTime = currStartTime + event.getDuration();

			if (time < currStartTime) {
				if (1 != n)
					event = null;
				return event;
			}
			while (it.hasNext()) {
				currStartTime = event.getTime();
				currEndTime = currStartTime + event.getDuration();
				nextEvent = (ITimeEvent) it.next();

				long nextEventTime = nextEvent.getTime();
				currEndTime = currEndTime >= nextEventTime ? (nextEventTime - 1)
						: currEndTime;

//				Trace.debug("currStartTime: " + currStartTime
//						+ " currEndTime: " + currEndTime + " nextEventTime: "
//						+ nextEventTime + " time: " + time);
				if (currStartTime <= time && time <= currEndTime) {
					if (1 == n)
						event = nextEvent;
					else if (-1 == n)
						event = prevEvent;
					return event;
				}

				if (time > currEndTime && time < nextEventTime) {
					//Located in a non Event area
					if (2 == n || -1 == n) {
						return event;
					} else if (1 == n) {
						return nextEvent;
					}
					return null;
				}

				prevEvent = event;
				event = nextEvent;
			}
		}
		if (1 == n)
			event = null;
		else if (-1 == n)
			event = prevEvent;
		return event;
	}

