    private void updatePreviews(boolean updateAll) {
        if (inputText == null) {
            // early update during construction
            return;
        }
        inputText.setStyleRanges(new StyleRange[] {});

        try (Scanner scanner = new Scanner(inputText.getText());) {
            scanner.useDelimiter("\n"); //$NON-NLS-1$

            int rawPos = 0;
            // skip starting delimiters
            String skip = scanner.findWithinHorizon("\\A\n+", 0); //$NON-NLS-1$
            if (skip != null) {
                rawPos += skip.length();
            }

            timeStampFormat = null;
            if (selectedLine != null) {
                for (InputGroup input : selectedLine.inputs) {
                    input.previewText.setText(Messages.CustomTxtParserInputWizardPage_noMathcingLine);
                }
            }

            Map<String, String> data = new HashMap<>();
            int rootLineMatches = 0;
            String firstEntryTimeStamp = null;
            String firstEntryTimeStampInputFormat = null;
            String line = null;
            boolean lineIsNull = true; // needed because of JDT bug with continue at label
            event: while (scanner.hasNext() || !lineIsNull) {
                if (rootLineMatches > 0 && !updateAll) {
                    break;
                }
                if (line == null) {
                    line = scanner.next();
                    lineIsNull = false;
                }
                int length = line.length();
                String log = line.replaceAll("\r", ""); //$NON-NLS-1$ //$NON-NLS-2$
                for (InputLine rootInputLine : definition.inputs) {
                    Pattern pattern;
                    try {
                        pattern = rootInputLine.getPattern();
                    } catch (PatternSyntaxException e) {
                        continue;
                    }
                    Matcher matcher = pattern.matcher(log);
                    if (matcher.matches()) {
                        rootLineMatches++;
                        inputText.setStyleRange(new StyleRange(rawPos, length,
                                COLOR_BLACK, COLOR_YELLOW, SWT.ITALIC));
                        data = new HashMap<>();
                        timeStampFormat = null;
                        updatePreviewLine(rootInputLine, matcher, data, rawPos, rootLineMatches);
                        if (rootLineMatches == 1) {
                            firstEntryTimeStamp = data.get(CustomTraceDefinition.TAG_TIMESTAMP);
                            firstEntryTimeStampInputFormat = timeStampFormat;
                        }
                        HashMap<InputLine, Integer> countMap = new HashMap<>();
                        InputLine currentInput = null;
                        if (rootInputLine.childrenInputs != null && rootInputLine.childrenInputs.size() > 0) {
                            currentInput = rootInputLine.childrenInputs.get(0);
                            countMap.put(currentInput, 0);
                        }
                        rawPos += length + 1; // +1 for \n
                        while (scanner.hasNext()) {
                            line = scanner.next();
                            length = line.length();
                            log = line.replaceAll("\r", ""); //$NON-NLS-1$ //$NON-NLS-2$
                            boolean processed = false;
                            if (currentInput == null) {
                                for (InputLine input : definition.inputs) {
                                    try {
                                        matcher = input.getPattern().matcher(log);
                                    } catch (PatternSyntaxException e) {
                                        continue;
                                    }
                                    if (matcher.matches()) {
                                        continue event;
                                    }
                                }
                            } else {
                                if (countMap.get(currentInput) >= currentInput.getMinCount()) {
                                    List<InputLine> nextInputs = currentInput.getNextInputs(countMap);
                                    if (nextInputs.size() == 0 || nextInputs.get(nextInputs.size() - 1).getMinCount() == 0) {
                                        for (InputLine input : definition.inputs) {
                                            try {
                                                matcher = input.getPattern().matcher(log);
                                            } catch (PatternSyntaxException e) {
                                                continue;
                                            }
                                            if (matcher.matches()) {
                                                continue event;
                                            }
                                        }
                                    }
                                    for (InputLine input : nextInputs) {
                                        try {
                                            matcher = input.getPattern().matcher(log);
                                        } catch (PatternSyntaxException e) {
                                            continue;
                                        }
                                        if (matcher.matches()) {
                                            inputText.setStyleRange(new StyleRange(rawPos, length,
                                                    COLOR_BLACK, COLOR_LIGHT_YELLOW, SWT.ITALIC));
                                            currentInput = input;
                                            updatePreviewLine(currentInput, matcher, data, rawPos, rootLineMatches);
                                            if (countMap.get(currentInput) == null) {
                                                countMap.put(currentInput, 1);
                                            } else {
                                                countMap.put(currentInput, countMap.get(currentInput) + 1);
                                            }
                                            Iterator<InputLine> iter = countMap.keySet().iterator();
                                            while (iter.hasNext()) {
                                                InputLine inputLine = iter.next();
                                                if (inputLine.level > currentInput.level) {
                                                    iter.remove();
                                                }
                                            }
                                            if (currentInput.childrenInputs != null && currentInput.childrenInputs.size() > 0) {
                                                currentInput = currentInput.childrenInputs.get(0);
                                                countMap.put(currentInput, 0);
                                            } else {
                                                if (countMap.get(currentInput) >= currentInput.getMaxCount()) {
                                                    if (currentInput.getNextInputs(countMap).size() > 0) {
                                                        currentInput = currentInput.getNextInputs(countMap).get(0);
                                                        if (countMap.get(currentInput) == null) {
                                                            countMap.put(currentInput, 0);
                                                        }
                                                        iter = countMap.keySet().iterator();
                                                        while (iter.hasNext()) {
                                                            InputLine inputLine = iter.next();
                                                            if (inputLine.level > currentInput.level) {
                                                                iter.remove();
                                                            }
                                                        }
                                                    } else {
                                                        currentInput = null;
                                                    }
                                                }
                                            }
                                            processed = true;
                                            break;
                                        }
                                    }
                                }
                                if (!processed && currentInput != null) {
                                    matcher = null;
                                    try {
                                        matcher = currentInput.getPattern().matcher(log);
                                    } catch (PatternSyntaxException e) {
                                    }
                                    if (matcher != null && matcher.matches()) {
                                        inputText.setStyleRange(new StyleRange(rawPos, length,
                                                COLOR_BLACK, COLOR_LIGHT_YELLOW, SWT.ITALIC));
                                        updatePreviewLine(currentInput, matcher, data, rawPos, rootLineMatches);
                                        countMap.put(currentInput, countMap.get(currentInput) + 1);
                                        if (currentInput.childrenInputs != null && currentInput.childrenInputs.size() > 0) {
                                            currentInput = currentInput.childrenInputs.get(0);
                                            countMap.put(currentInput, 0);
                                        } else {
                                            if (countMap.get(currentInput) >= currentInput.getMaxCount()) {
                                                if (currentInput.getNextInputs(countMap).size() > 0) {
                                                    currentInput = currentInput.getNextInputs(countMap).get(0);
                                                    if (countMap.get(currentInput) == null) {
                                                        countMap.put(currentInput, 0);
                                                    }
                                                    Iterator<InputLine> iter = countMap.keySet().iterator();
                                                    while (iter.hasNext()) {
                                                        InputLine inputLine = iter.next();
                                                        if (inputLine.level > currentInput.level) {
                                                            iter.remove();
                                                        }
                                                    }
                                                } else {
                                                    currentInput = null;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            rawPos += length + 1; // +1 for \n
                        }

                        break;
                    }
                }
                rawPos += length + 1; // +1 for \n
                line = null;
                lineIsNull = true;
            }

            if (rootLineMatches == 1) {
                firstEntryTimeStamp = data.get(CustomTraceDefinition.TAG_TIMESTAMP);
                firstEntryTimeStampInputFormat = timeStampFormat;
            }
            if (firstEntryTimeStamp == null) {
                timestampPreviewText.setText(Messages.CustomTxtParserInputWizardPage_noTimestampGroup);
                if (selectedLine != null) {
                    for (InputGroup group : selectedLine.inputs) {
                        if (group.tagCombo.getText().equals(CustomTraceDefinition.TAG_TIMESTAMP)) {
                            timestampPreviewText.setText(Messages.CustomTxtParserInputWizardPage_noMatchingTimestamp);
                            break;
                        }
                    }
                }
            } else {
                try {
                    TmfTimestampFormat timestampFormat = new TmfTimestampFormat(firstEntryTimeStampInputFormat);
                    long timestamp = timestampFormat.parseValue(firstEntryTimeStamp);
                    timestampFormat = new TmfTimestampFormat(timestampOutputFormatText.getText().trim());
                    timestampPreviewText.setText(timestampFormat.format(timestamp));
                } catch (ParseException e) {
                    timestampPreviewText.setText("*parse exception* [" + firstEntryTimeStamp + "] <> [" + firstEntryTimeStampInputFormat + "]"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
                } catch (IllegalArgumentException e) {
                    timestampPreviewText.setText("*parse exception* [Illegal Argument: " + e.getMessage() + "]"); //$NON-NLS-1$ //$NON-NLS-2$
                }

            }
        }
    }

