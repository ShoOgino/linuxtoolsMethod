    @Override
    protected List<ILinkEvent> getLinkList(long startTime, long endTime, long resolution, IProgressMonitor monitor) {
        List<ILinkEvent> list = new ArrayList<ILinkEvent>();
        ITmfTrace[] traces = TmfTraceManager.getTraceSet(getTrace());
        List<TimeGraphEntry> entryList = getEntryListMap().get(getTrace());
        if (traces == null || entryList == null) {
            return list;
        }
        for (ITmfTrace trace : traces) {
            if (trace instanceof LttngKernelTrace) {
                ITmfStateSystem ssq = trace.getStateSystems().get(LttngKernelTrace.STATE_ID);
                try {
                    long start = Math.max(startTime, ssq.getStartTime());
                    long end = Math.min(endTime, ssq.getCurrentEndTime());
                    if (end < start) {
                        continue;
                    }
                    List<Integer> currentThreadQuarks = ssq.getQuarks(Attributes.CPUS, "*", Attributes.CURRENT_THREAD); //$NON-NLS-1$
                    for (int currentThreadQuark : currentThreadQuarks) {
                        List<ITmfStateInterval> currentThreadIntervals = ssq.queryHistoryRange(currentThreadQuark, start, end, resolution, monitor);
                        int prevThread = 0;
                        long prevEnd = 0;
                        for (ITmfStateInterval currentThreadInterval : currentThreadIntervals) {
                            if (monitor.isCanceled()) {
                                return null;
                            }
                            long time = currentThreadInterval.getStartTime();
                            int thread = currentThreadInterval.getStateValue().unboxInt();
                            if (thread > 0 && prevThread > 0 && thread != prevThread && time == prevEnd) {
                                ITimeGraphEntry prevEntry = findEntry(entryList, trace, prevThread);
                                ITimeGraphEntry nextEntry = findEntry(entryList, trace, thread);
                                list.add(new TimeLinkEvent(prevEntry, nextEntry, time, 0, 0));
                            }
                            prevThread = thread;
                            prevEnd = currentThreadInterval.getEndTime() + 1;
                        }
                    }
                } catch (TimeRangeException e) {
                    e.printStackTrace();
                } catch (AttributeNotFoundException e) {
                    e.printStackTrace();
                } catch (StateValueTypeException e) {
                    e.printStackTrace();
                } catch (StateSystemDisposedException e) {
                    /* Ignored */
                }
            }
        }
        return list;
    }

