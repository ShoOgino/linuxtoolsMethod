    @Override
    protected List<ILinkEvent> getLinkList(long startTime, long endTime, long resolution, IProgressMonitor monitor) {
        List<ILinkEvent> list = new ArrayList<>();
        ITmfTrace[] traces = TmfTraceManager.getTraceSet(getTrace());
        List<TimeGraphEntry> entryList = getEntryList(getTrace());
        if (traces == null || entryList == null) {
            return list;
        }
        for (ITmfTrace trace : traces) {
            LttngKernelAnalysisModule module = trace.getAnalysisModuleOfClass(LttngKernelAnalysisModule.class, LttngKernelAnalysisModule.ID);
            if (module == null) {
                continue;
            }
            ITmfStateSystem ssq = module.getStateSystem();
            if (ssq == null) {
                continue;
            }
            try {
                long start = Math.max(startTime, ssq.getStartTime());
                long end = Math.min(endTime, ssq.getCurrentEndTime());
                if (end < start) {
                    continue;
                }
                List<Integer> currentThreadQuarks = ssq.getQuarks(Attributes.CPUS, "*", Attributes.CURRENT_THREAD); //$NON-NLS-1$
                for (int currentThreadQuark : currentThreadQuarks) {
                    // adjust the query range to include the previous and following intervals
                    long qstart = Math.max(ssq.querySingleState(start, currentThreadQuark).getStartTime() - 1, ssq.getStartTime());
                    long qend = Math.min(ssq.querySingleState(end, currentThreadQuark).getEndTime() + 1, ssq.getCurrentEndTime());
                    List<ITmfStateInterval> currentThreadIntervals = ssq.queryHistoryRange(currentThreadQuark, qstart, qend, resolution, monitor);
                    int prevThread = 0;
                    long prevEnd = 0;
                    long lastEnd = 0;
                    for (ITmfStateInterval currentThreadInterval : currentThreadIntervals) {
                        if (monitor.isCanceled()) {
                            return null;
                        }
                        long time = currentThreadInterval.getStartTime();
                        if (time != lastEnd) {
                            // don't create links where there are gaps in intervals due to the resolution
                            prevThread = 0;
                            prevEnd = 0;
                        }
                        int thread = currentThreadInterval.getStateValue().unboxInt();
                        if (thread > 0 && prevThread > 0) {
                            ITimeGraphEntry prevEntry = findEntry(entryList, trace, prevThread);
                            ITimeGraphEntry nextEntry = findEntry(entryList, trace, thread);
                            list.add(new TimeLinkEvent(prevEntry, nextEntry, prevEnd, time - prevEnd, 0));
                        }
                        lastEnd = currentThreadInterval.getEndTime() + 1;
                        if (thread != 0) {
                            prevThread = thread;
                            prevEnd = lastEnd;
                        }
                    }
                }
            } catch (TimeRangeException | AttributeNotFoundException | StateValueTypeException e) {
                e.printStackTrace();
            } catch (StateSystemDisposedException e) {
                /* Ignored */
            }
        }
        return list;
    }

