    @Override
    protected List<ILinkEvent> getLinkList(long startTime, long endTime, long resolution, IProgressMonitor monitor) {
        List<ILinkEvent> list = new ArrayList<ILinkEvent>();
        ITmfTrace[] traces = TmfTraceManager.getTraceSet(getTrace());
        List<TimeGraphEntry> entryList = getEntryListMap().get(getTrace());
        if (traces == null || entryList == null) {
            return list;
        }
        for (ITmfTrace trace : traces) {
            if (trace instanceof LttngKernelTrace) {
                ITmfStateSystem ssq = trace.getStateSystems().get(LttngKernelTrace.STATE_ID);
                try {
                    long start = Math.max(startTime, ssq.getStartTime());
                    long end = Math.min(endTime, ssq.getCurrentEndTime());
                    if (end < start) {
                        continue;
                    }
                    List<Integer> currentThreadQuarks = ssq.getQuarks(Attributes.CPUS, "*", Attributes.CURRENT_THREAD); //$NON-NLS-1$
                    for (int currentThreadQuark : currentThreadQuarks) {
                        // adjust the query range to include the previous and following intervals
                        long qstart = Math.max(ssq.querySingleState(start, currentThreadQuark).getStartTime() - 1, ssq.getStartTime());
                        long qend = Math.min(ssq.querySingleState(end, currentThreadQuark).getEndTime() + 1, ssq.getCurrentEndTime());
                        List<ITmfStateInterval> currentThreadIntervals = ssq.queryHistoryRange(currentThreadQuark, qstart, qend, resolution, monitor);
                        int prevThread = 0;
                        long prevEnd = 0;
                        long lastEnd = 0;
                        for (ITmfStateInterval currentThreadInterval : currentThreadIntervals) {
                            if (monitor.isCanceled()) {
                                return null;
                            }
                            long time = currentThreadInterval.getStartTime();
                            if (time != lastEnd) {
                                // don't create links where there are gaps in intervals due to the resolution
                                prevThread = 0;
                                prevEnd = 0;
                            }
                            int thread = currentThreadInterval.getStateValue().unboxInt();
                            if (thread > 0 && prevThread > 0) {
                                ITimeGraphEntry prevEntry = findEntry(entryList, trace, prevThread);
                                ITimeGraphEntry nextEntry = findEntry(entryList, trace, thread);
                                list.add(new TimeLinkEvent(prevEntry, nextEntry, prevEnd, time - prevEnd, 0));
                            }
                            lastEnd = currentThreadInterval.getEndTime() + 1;
                            if (thread != 0) {
                                prevThread = thread;
                                prevEnd = lastEnd;
                            }
                        }
                    }
                } catch (TimeRangeException e) {
                    e.printStackTrace();
                } catch (AttributeNotFoundException e) {
                    e.printStackTrace();
                } catch (StateValueTypeException e) {
                    e.printStackTrace();
                } catch (StateSystemDisposedException e) {
                    /* Ignored */
                }
            }
        }
        return list;
    }

