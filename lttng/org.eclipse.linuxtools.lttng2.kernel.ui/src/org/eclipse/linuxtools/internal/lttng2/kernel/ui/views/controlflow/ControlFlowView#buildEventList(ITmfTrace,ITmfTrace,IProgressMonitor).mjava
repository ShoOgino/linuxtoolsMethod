    @Override
    protected void buildEventList(final ITmfTrace trace, ITmfTrace parentTrace, IProgressMonitor monitor) {
        if (trace == null) {
            return;
        }
        ITmfStateSystem ssq = TmfStateSystemAnalysisModule.getStateSystem(trace, LttngKernelAnalysisModule.ID);
        if (ssq == null) {
            return;
        }

        List<ControlFlowEntry> entryList = new ArrayList<>();
        Map<Integer, ControlFlowEntry> entryMap = new HashMap<>();

        long start = ssq.getStartTime();
        setStartTime(Math.min(getStartTime(), start));

        boolean complete = false;
        while (!complete) {
            if (monitor.isCanceled()) {
                return;
            }
            complete = ssq.waitUntilBuilt(TmfUiRefreshHandler.UPDATE_PERIOD);
            if (ssq.isCancelled()) {
                return;
            }
            long end = ssq.getCurrentEndTime();
            if (start == end && !complete) { // when complete execute one last time regardless of end time
                continue;
            }
            setEndTime(Math.max(getEndTime(), end + 1));
            List<Integer> threadQuarks = ssq.getQuarks(Attributes.THREADS, "*"); //$NON-NLS-1$
            for (int threadQuark : threadQuarks) {
                if (monitor.isCanceled()) {
                    return;
                }
                String threadName = ssq.getAttributeName(threadQuark);
                int threadId = -1;
                try {
                    threadId = Integer.parseInt(threadName);
                } catch (NumberFormatException e1) {
                    continue;
                }
                if (threadId <= 0) { // ignore the 'unknown' (-1) and swapper (0) threads
                    continue;
                }

                int execNameQuark;
                List<ITmfStateInterval> execNameIntervals;
                try {
                    execNameQuark = ssq.getQuarkRelative(threadQuark, Attributes.EXEC_NAME);
                    execNameIntervals = ssq.queryHistoryRange(execNameQuark, start, end);
                } catch (AttributeNotFoundException e) {
                    /* No information on this thread (yet?), skip it for now */
                    continue;
                } catch (StateSystemDisposedException e) {
                    /* State system is closing down, no point continuing */
                    break;
                }

                for (ITmfStateInterval execNameInterval : execNameIntervals) {
                    if (monitor.isCanceled()) {
                        return;
                    }
                    ControlFlowEntry entry = entryMap.get(threadId);
                    if (!execNameInterval.getStateValue().isNull() &&
                            execNameInterval.getStateValue().getType() == ITmfStateValue.Type.STRING) {
                        String execName = execNameInterval.getStateValue().unboxStr();
                        long startTime = execNameInterval.getStartTime();
                        long endTime = execNameInterval.getEndTime() + 1;
                        if (entry == null) {
                            ITmfStateInterval ppidInterval = null;
                            try {
                                int ppidQuark = ssq.getQuarkRelative(threadQuark, Attributes.PPID);
                                ppidInterval = ssq.querySingleState(startTime, ppidQuark);
                            } catch (AttributeNotFoundException e) {
                                /* No info, keep PPID at -1 */
                            } catch (StateSystemDisposedException e) {
                                /* SS is closing down, time to bail */
                                break;
                            }
                            int ppid = -1;
                            if (!(ppidInterval == null) && !ppidInterval.getStateValue().isNull()) {
                                ppid = ppidInterval.getStateValue().unboxInt();
                            }
                            entry = new ControlFlowEntry(threadQuark, trace, execName, threadId, ppid, startTime, endTime);
                            entryList.add(entry);
                            entryMap.put(threadId, entry);
                        } else {
                            // update the name of the entry to the latest
                            // execName
                            entry.setName(execName);
                            entry.updateEndTime(endTime);
                        }
                    } else {
                        entryMap.remove(threadId);
                    }
                }
            }

            updateTree(entryList, parentTrace);

            if (parentTrace.equals(getTrace())) {
                refresh();
            }

            for (ControlFlowEntry entry : entryList) {
                if (monitor.isCanceled()) {
                    return;
                }
                buildStatusEvents(entry.getTrace(), entry, monitor, start, end);
            }

            start = end;
        }
    }

