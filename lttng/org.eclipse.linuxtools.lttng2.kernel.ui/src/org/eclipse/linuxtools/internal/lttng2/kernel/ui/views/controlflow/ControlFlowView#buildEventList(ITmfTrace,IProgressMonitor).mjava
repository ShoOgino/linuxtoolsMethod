    private void buildEventList(final ITmfTrace trace, IProgressMonitor monitor) {
        fStartTime = Long.MAX_VALUE;
        fEndTime = Long.MIN_VALUE;
        ITmfTrace[] traces;
        if (trace instanceof TmfExperiment) {
            TmfExperiment experiment = (TmfExperiment) trace;
            traces = experiment.getTraces();
        } else {
            traces = new ITmfTrace[] { trace };
        }
        ArrayList<ControlFlowEntry> rootList = new ArrayList<ControlFlowEntry>();
        for (ITmfTrace aTrace : traces) {
            if (monitor.isCanceled()) {
                return;
            }
            if (aTrace instanceof CtfKernelTrace) {
                ArrayList<ControlFlowEntry> entryList = new ArrayList<ControlFlowEntry>();
                CtfKernelTrace ctfKernelTrace = (CtfKernelTrace) aTrace;
                ITmfStateSystem ssq = ctfKernelTrace.getStateSystem();
                if (!ssq.waitUntilBuilt()) {
                    return;
                }
                long start = ssq.getStartTime();
                long end = ssq.getCurrentEndTime() + 1;
                fStartTime = Math.min(fStartTime, start);
                fEndTime = Math.max(fEndTime, end);
                List<Integer> threadQuarks = ssq.getQuarks(Attributes.THREADS, "*"); //$NON-NLS-1$
                for (int threadQuark : threadQuarks) {
                    if (monitor.isCanceled()) {
                        return;
                    }
                    String threadName = ssq.getAttributeName(threadQuark);
                    int threadId = -1;
                    try {
                        threadId = Integer.parseInt(threadName);
                    } catch (NumberFormatException e1) {
                        continue;
                    }
                    if (threadId == 0) { // ignore the swapper thread
                        continue;
                    }
                    int execNameQuark = -1;
                    try {
                        try {
                            execNameQuark = ssq.getQuarkRelative(threadQuark, Attributes.EXEC_NAME);
                        } catch (AttributeNotFoundException e) {
                            continue;
                        }
                        int ppidQuark = ssq.getQuarkRelative(threadQuark, Attributes.PPID);
                        List<ITmfStateInterval> execNameIntervals = ssq.queryHistoryRange(execNameQuark, start, end - 1); // use monitor when available in api
                        if (monitor.isCanceled()) {
                            return;
                        }
                        long birthTime = -1;
                        for (ITmfStateInterval execNameInterval : execNameIntervals) {
                            if (monitor.isCanceled()) {
                                return;
                            }
                            if (!execNameInterval.getStateValue().isNull() && execNameInterval.getStateValue().getType() == 1) {
                                String execName = execNameInterval.getStateValue().unboxStr();
                                long startTime = execNameInterval.getStartTime();
                                long endTime = execNameInterval.getEndTime() + 1;
                                if (birthTime == -1) {
                                    birthTime = startTime;
                                }
                                int ppid = -1;
                                if (ppidQuark != -1) {
                                    ITmfStateInterval ppidInterval = ssq.querySingleState(startTime, ppidQuark);
                                    ppid = ppidInterval.getStateValue().unboxInt();
                                }
                                ControlFlowEntry entry = new ControlFlowEntry(threadQuark, ctfKernelTrace, execName, threadId, ppid, birthTime, startTime, endTime);
                                entryList.add(entry);
                                entry.addEvent(new TimeEvent(entry, startTime, endTime - startTime));
                            } else {
                                birthTime = -1;
                            }
                        }
                    } catch (AttributeNotFoundException e) {
                        e.printStackTrace();
                    } catch (TimeRangeException e) {
                        e.printStackTrace();
                    } catch (StateValueTypeException e) {
                        e.printStackTrace();
                    } catch (StateSystemDisposedException e) {
                        /* Ignored */
                    }
                }
                buildTree(entryList, rootList);
            }
            Collections.sort(rootList, fControlFlowEntryComparator);
            synchronized (fEntryListMap) {
                fEntryListMap.put(trace, (ArrayList<ControlFlowEntry>) rootList.clone());
            }
            if (trace == fTrace) {
                refresh(INITIAL_WINDOW_OFFSET);
            }
        }
        for (ControlFlowEntry entry : rootList) {
            if (monitor.isCanceled()) {
                return;
            }
            buildStatusEvents(trace, entry, monitor);
        }
    }

