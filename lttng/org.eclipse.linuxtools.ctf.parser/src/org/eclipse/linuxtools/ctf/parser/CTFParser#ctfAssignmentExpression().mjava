    // $ANTLR start "ctfAssignmentExpression"
    // Grammar/CTFParser.g:977:1: ctfAssignmentExpression : ( (left= unaryExpression ( (assignment= ASSIGNMENT right1= unaryExpression ) -> ^( CTF_EXPRESSION_VAL ^( CTF_LEFT $left) ^( CTF_RIGHT $right1) ) | (type_assignment= TYPE_ASSIGNMENT right2= typeSpecifier ) -> ^( CTF_EXPRESSION_TYPE ^( CTF_LEFT $left) ^( CTF_RIGHT ^( TYPE_SPECIFIER_LIST $right2) ) ) ) ) | ( declarationSpecifiers {...}? declaratorList ) -> ^( TYPEDEF declaratorList declarationSpecifiers ) | typealiasDecl );
    public final CTFParser.ctfAssignmentExpression_return ctfAssignmentExpression() throws RecognitionException {
        CTFParser.ctfAssignmentExpression_return retval = new CTFParser.ctfAssignmentExpression_return();
        retval.start = input.LT(1);

        CommonTree root_0 = null;

        Token assignment=null;
        Token type_assignment=null;
        CTFParser.unaryExpression_return left = null;

        CTFParser.unaryExpression_return right1 = null;

        CTFParser.typeSpecifier_return right2 = null;

        CTFParser.declarationSpecifiers_return declarationSpecifiers178 = null;

        CTFParser.declaratorList_return declaratorList179 = null;

        CTFParser.typealiasDecl_return typealiasDecl180 = null;


        CommonTree assignment_tree=null;
        CommonTree type_assignment_tree=null;
        RewriteRuleTokenStream stream_ASSIGNMENT=new RewriteRuleTokenStream(adaptor,"token ASSIGNMENT");
        RewriteRuleTokenStream stream_TYPE_ASSIGNMENT=new RewriteRuleTokenStream(adaptor,"token TYPE_ASSIGNMENT");
        RewriteRuleSubtreeStream stream_declaratorList=new RewriteRuleSubtreeStream(adaptor,"rule declaratorList");
        RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
        RewriteRuleSubtreeStream stream_declarationSpecifiers=new RewriteRuleSubtreeStream(adaptor,"rule declarationSpecifiers");
        RewriteRuleSubtreeStream stream_typeSpecifier=new RewriteRuleSubtreeStream(adaptor,"rule typeSpecifier");

          enter("ctfAssignmentExpression");

        try {
            // Grammar/CTFParser.g:987:1: ( (left= unaryExpression ( (assignment= ASSIGNMENT right1= unaryExpression ) -> ^( CTF_EXPRESSION_VAL ^( CTF_LEFT $left) ^( CTF_RIGHT $right1) ) | (type_assignment= TYPE_ASSIGNMENT right2= typeSpecifier ) -> ^( CTF_EXPRESSION_TYPE ^( CTF_LEFT $left) ^( CTF_RIGHT ^( TYPE_SPECIFIER_LIST $right2) ) ) ) ) | ( declarationSpecifiers {...}? declaratorList ) -> ^( TYPEDEF declaratorList declarationSpecifiers ) | typealiasDecl )
            int alt59=3;
            switch ( input.LA(1) ) {
            case IDENTIFIER:
                {
                int LA59_1 = input.LA(2);

                if ( ((LA59_1>=CONSTTOK && LA59_1<=ENUMTOK)||(LA59_1>=FLOATINGPOINTTOK && LA59_1<=SIGNEDTOK)||(LA59_1>=STRINGTOK && LA59_1<=STRUCTTOK)||(LA59_1>=TYPEDEFTOK && LA59_1<=IMAGINARYTOK)||LA59_1==POINTER||LA59_1==IDENTIFIER) && ((inTypealiasAlias() || isTypeName(input.LT(1).getText())))) {
                    alt59=2;
                }
                else if ( ((LA59_1>=ASSIGNMENT && LA59_1<=TYPE_ASSIGNMENT)||LA59_1==OPENBRAC||(LA59_1>=ARROW && LA59_1<=DOT)) ) {
                    alt59=1;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 59, 1, input);

                    throw nvae;
                }
                }
                break;
            case ALIGNTOK:
            case EVENTTOK:
            case STREAMTOK:
            case TRACETOK:
            case ENVTOK:
            case CLOCKTOK:
            case SIGN:
            case OCTAL_LITERAL:
            case DECIMAL_LITERAL:
            case HEX_LITERAL:
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
                {
                alt59=1;
                }
                break;
            case SIGNEDTOK:
                {
                switch ( input.LA(2) ) {
                case ASSIGNMENT:
                case TYPE_ASSIGNMENT:
                case OPENBRAC:
                case ARROW:
                case DOT:
                    {
                    alt59=1;
                    }
                    break;
                case CONSTTOK:
                case CHARTOK:
                case DOUBLETOK:
                case ENUMTOK:
                case FLOATINGPOINTTOK:
                case FLOATTOK:
                case INTEGERTOK:
                case INTTOK:
                case LONGTOK:
                case SHORTTOK:
                case SIGNEDTOK:
                case STRINGTOK:
                case STRUCTTOK:
                case UNSIGNEDTOK:
                case VARIANTTOK:
                case VOIDTOK:
                case BOOLTOK:
                case COMPLEXTOK:
                case IMAGINARYTOK:
                case POINTER:
                case IDENTIFIER:
                    {
                    alt59=2;
                    }
                    break;
                case TYPEDEFTOK:
                    {
                    alt59=2;
                    }
                    break;
                default:
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 59, 3, input);

                    throw nvae;
                }

                }
                break;
            case CONSTTOK:
            case CHARTOK:
            case DOUBLETOK:
            case ENUMTOK:
            case FLOATINGPOINTTOK:
            case FLOATTOK:
            case INTEGERTOK:
            case INTTOK:
            case LONGTOK:
            case SHORTTOK:
            case STRUCTTOK:
            case TYPEDEFTOK:
            case UNSIGNEDTOK:
            case VARIANTTOK:
            case VOIDTOK:
            case BOOLTOK:
            case COMPLEXTOK:
            case IMAGINARYTOK:
                {
                alt59=2;
                }
                break;
            case STRINGTOK:
                {
                switch ( input.LA(2) ) {
                case ASSIGNMENT:
                case TYPE_ASSIGNMENT:
                case OPENBRAC:
                case ARROW:
                case DOT:
                    {
                    alt59=1;
                    }
                    break;
                case CONSTTOK:
                case CHARTOK:
                case DOUBLETOK:
                case ENUMTOK:
                case FLOATINGPOINTTOK:
                case FLOATTOK:
                case INTEGERTOK:
                case INTTOK:
                case LONGTOK:
                case SHORTTOK:
                case SIGNEDTOK:
                case STRINGTOK:
                case STRUCTTOK:
                case UNSIGNEDTOK:
                case VARIANTTOK:
                case VOIDTOK:
                case BOOLTOK:
                case COMPLEXTOK:
                case IMAGINARYTOK:
                case LCURL:
                case POINTER:
                case IDENTIFIER:
                    {
                    alt59=2;
                    }
                    break;
                case TYPEDEFTOK:
                    {
                    alt59=2;
                    }
                    break;
                default:
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 59, 5, input);

                    throw nvae;
                }

                }
                break;
            case TYPEALIASTOK:
                {
                alt59=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 59, 0, input);

                throw nvae;
            }

            switch (alt59) {
                case 1 :
                    // Grammar/CTFParser.g:988:3: (left= unaryExpression ( (assignment= ASSIGNMENT right1= unaryExpression ) -> ^( CTF_EXPRESSION_VAL ^( CTF_LEFT $left) ^( CTF_RIGHT $right1) ) | (type_assignment= TYPE_ASSIGNMENT right2= typeSpecifier ) -> ^( CTF_EXPRESSION_TYPE ^( CTF_LEFT $left) ^( CTF_RIGHT ^( TYPE_SPECIFIER_LIST $right2) ) ) ) )
                    {
                    // Grammar/CTFParser.g:988:3: (left= unaryExpression ( (assignment= ASSIGNMENT right1= unaryExpression ) -> ^( CTF_EXPRESSION_VAL ^( CTF_LEFT $left) ^( CTF_RIGHT $right1) ) | (type_assignment= TYPE_ASSIGNMENT right2= typeSpecifier ) -> ^( CTF_EXPRESSION_TYPE ^( CTF_LEFT $left) ^( CTF_RIGHT ^( TYPE_SPECIFIER_LIST $right2) ) ) ) )
                    // Grammar/CTFParser.g:989:5: left= unaryExpression ( (assignment= ASSIGNMENT right1= unaryExpression ) -> ^( CTF_EXPRESSION_VAL ^( CTF_LEFT $left) ^( CTF_RIGHT $right1) ) | (type_assignment= TYPE_ASSIGNMENT right2= typeSpecifier ) -> ^( CTF_EXPRESSION_TYPE ^( CTF_LEFT $left) ^( CTF_RIGHT ^( TYPE_SPECIFIER_LIST $right2) ) ) )
                    {
                    pushFollow(FOLLOW_unaryExpression_in_ctfAssignmentExpression3381);
                    left=unaryExpression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_unaryExpression.add(left.getTree());
                    // Grammar/CTFParser.g:990:5: ( (assignment= ASSIGNMENT right1= unaryExpression ) -> ^( CTF_EXPRESSION_VAL ^( CTF_LEFT $left) ^( CTF_RIGHT $right1) ) | (type_assignment= TYPE_ASSIGNMENT right2= typeSpecifier ) -> ^( CTF_EXPRESSION_TYPE ^( CTF_LEFT $left) ^( CTF_RIGHT ^( TYPE_SPECIFIER_LIST $right2) ) ) )
                    int alt58=2;
                    int LA58_0 = input.LA(1);

                    if ( (LA58_0==ASSIGNMENT) ) {
                        alt58=1;
                    }
                    else if ( (LA58_0==TYPE_ASSIGNMENT) ) {
                        alt58=2;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return retval;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 58, 0, input);

                        throw nvae;
                    }
                    switch (alt58) {
                        case 1 :
                            // Grammar/CTFParser.g:991:9: (assignment= ASSIGNMENT right1= unaryExpression )
                            {
                            // Grammar/CTFParser.g:991:9: (assignment= ASSIGNMENT right1= unaryExpression )
                            // Grammar/CTFParser.g:991:10: assignment= ASSIGNMENT right1= unaryExpression
                            {
                            assignment=(Token)match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_ctfAssignmentExpression3400); if (state.failed) return retval; 
                            if ( state.backtracking==0 ) stream_ASSIGNMENT.add(assignment);

                            pushFollow(FOLLOW_unaryExpression_in_ctfAssignmentExpression3404);
                            right1=unaryExpression();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) stream_unaryExpression.add(right1.getTree());

                            }



                            // AST REWRITE
                            // elements: right1, left
                            // token labels: 
                            // rule labels: retval, left, right1
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            if ( state.backtracking==0 ) {
                            retval.tree = root_0;
                            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
                            RewriteRuleSubtreeStream stream_left=new RewriteRuleSubtreeStream(adaptor,"rule left",left!=null?left.tree:null);
                            RewriteRuleSubtreeStream stream_right1=new RewriteRuleSubtreeStream(adaptor,"rule right1",right1!=null?right1.tree:null);

                            root_0 = (CommonTree)adaptor.nil();
                            // 991:56: -> ^( CTF_EXPRESSION_VAL ^( CTF_LEFT $left) ^( CTF_RIGHT $right1) )
                            {
                                // Grammar/CTFParser.g:991:59: ^( CTF_EXPRESSION_VAL ^( CTF_LEFT $left) ^( CTF_RIGHT $right1) )
                                {
                                CommonTree root_1 = (CommonTree)adaptor.nil();
                                root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(CTF_EXPRESSION_VAL, "CTF_EXPRESSION_VAL"), root_1);

                                // Grammar/CTFParser.g:991:80: ^( CTF_LEFT $left)
                                {
                                CommonTree root_2 = (CommonTree)adaptor.nil();
                                root_2 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(CTF_LEFT, "CTF_LEFT"), root_2);

                                adaptor.addChild(root_2, stream_left.nextTree());

                                adaptor.addChild(root_1, root_2);
                                }
                                // Grammar/CTFParser.g:991:98: ^( CTF_RIGHT $right1)
                                {
                                CommonTree root_2 = (CommonTree)adaptor.nil();
                                root_2 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(CTF_RIGHT, "CTF_RIGHT"), root_2);

                                adaptor.addChild(root_2, stream_right1.nextTree());

                                adaptor.addChild(root_1, root_2);
                                }

                                adaptor.addChild(root_0, root_1);
                                }

                            }

                            retval.tree = root_0;}
                            }
                            break;
                        case 2 :
                            // Grammar/CTFParser.g:992:9: (type_assignment= TYPE_ASSIGNMENT right2= typeSpecifier )
                            {
                            // Grammar/CTFParser.g:992:9: (type_assignment= TYPE_ASSIGNMENT right2= typeSpecifier )
                            // Grammar/CTFParser.g:992:10: type_assignment= TYPE_ASSIGNMENT right2= typeSpecifier
                            {
                            type_assignment=(Token)match(input,TYPE_ASSIGNMENT,FOLLOW_TYPE_ASSIGNMENT_in_ctfAssignmentExpression3438); if (state.failed) return retval; 
                            if ( state.backtracking==0 ) stream_TYPE_ASSIGNMENT.add(type_assignment);

                            pushFollow(FOLLOW_typeSpecifier_in_ctfAssignmentExpression3443);
                            right2=typeSpecifier();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) stream_typeSpecifier.add(right2.getTree());

                            }



                            // AST REWRITE
                            // elements: left, right2
                            // token labels: 
                            // rule labels: retval, left, right2
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            if ( state.backtracking==0 ) {
                            retval.tree = root_0;
                            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
                            RewriteRuleSubtreeStream stream_left=new RewriteRuleSubtreeStream(adaptor,"rule left",left!=null?left.tree:null);
                            RewriteRuleSubtreeStream stream_right2=new RewriteRuleSubtreeStream(adaptor,"rule right2",right2!=null?right2.tree:null);

                            root_0 = (CommonTree)adaptor.nil();
                            // 992:65: -> ^( CTF_EXPRESSION_TYPE ^( CTF_LEFT $left) ^( CTF_RIGHT ^( TYPE_SPECIFIER_LIST $right2) ) )
                            {
                                // Grammar/CTFParser.g:992:68: ^( CTF_EXPRESSION_TYPE ^( CTF_LEFT $left) ^( CTF_RIGHT ^( TYPE_SPECIFIER_LIST $right2) ) )
                                {
                                CommonTree root_1 = (CommonTree)adaptor.nil();
                                root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(CTF_EXPRESSION_TYPE, "CTF_EXPRESSION_TYPE"), root_1);

                                // Grammar/CTFParser.g:992:90: ^( CTF_LEFT $left)
                                {
                                CommonTree root_2 = (CommonTree)adaptor.nil();
                                root_2 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(CTF_LEFT, "CTF_LEFT"), root_2);

                                adaptor.addChild(root_2, stream_left.nextTree());

                                adaptor.addChild(root_1, root_2);
                                }
                                // Grammar/CTFParser.g:992:108: ^( CTF_RIGHT ^( TYPE_SPECIFIER_LIST $right2) )
                                {
                                CommonTree root_2 = (CommonTree)adaptor.nil();
                                root_2 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(CTF_RIGHT, "CTF_RIGHT"), root_2);

                                // Grammar/CTFParser.g:992:120: ^( TYPE_SPECIFIER_LIST $right2)
                                {
                                CommonTree root_3 = (CommonTree)adaptor.nil();
                                root_3 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(TYPE_SPECIFIER_LIST, "TYPE_SPECIFIER_LIST"), root_3);

                                adaptor.addChild(root_3, stream_right2.nextTree());

                                adaptor.addChild(root_2, root_3);
                                }

                                adaptor.addChild(root_1, root_2);
                                }

                                adaptor.addChild(root_0, root_1);
                                }

                            }

                            retval.tree = root_0;}
                            }
                            break;

                    }


                    }


                    }
                    break;
                case 2 :
                    // Grammar/CTFParser.g:998:5: ( declarationSpecifiers {...}? declaratorList )
                    {
                    // Grammar/CTFParser.g:998:5: ( declarationSpecifiers {...}? declaratorList )
                    // Grammar/CTFParser.g:998:6: declarationSpecifiers {...}? declaratorList
                    {
                    pushFollow(FOLLOW_declarationSpecifiers_in_ctfAssignmentExpression3493);
                    declarationSpecifiers178=declarationSpecifiers();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_declarationSpecifiers.add(declarationSpecifiers178.getTree());
                    if ( !((inTypedef())) ) {
                        if (state.backtracking>0) {state.failed=true; return retval;}
                        throw new FailedPredicateException(input, "ctfAssignmentExpression", "inTypedef()");
                    }
                    pushFollow(FOLLOW_declaratorList_in_ctfAssignmentExpression3497);
                    declaratorList179=declaratorList();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_declaratorList.add(declaratorList179.getTree());

                    }



                    // AST REWRITE
                    // elements: declaratorList, declarationSpecifiers
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    if ( state.backtracking==0 ) {
                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

                    root_0 = (CommonTree)adaptor.nil();
                    // 999:5: -> ^( TYPEDEF declaratorList declarationSpecifiers )
                    {
                        // Grammar/CTFParser.g:999:8: ^( TYPEDEF declaratorList declarationSpecifiers )
                        {
                        CommonTree root_1 = (CommonTree)adaptor.nil();
                        root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(TYPEDEF, "TYPEDEF"), root_1);

                        adaptor.addChild(root_1, stream_declaratorList.nextTree());
                        adaptor.addChild(root_1, stream_declarationSpecifiers.nextTree());

                        adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}
                    }
                    break;
                case 3 :
                    // Grammar/CTFParser.g:1002:5: typealiasDecl
                    {
                    root_0 = (CommonTree)adaptor.nil();

                    pushFollow(FOLLOW_typealiasDecl_in_ctfAssignmentExpression3525);
                    typealiasDecl180=typealiasDecl();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, typealiasDecl180.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);

            if ( state.backtracking==0 ) {

            retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
            if ( state.backtracking==0 ) {

                if (inTypedef()) {
                  typedefOff();
                }
                exit("ctfAssignmentExpression");

            }
        }

        	catch (RecognitionException e)
        	{
        	  throw e;
        	}
        finally {
        }
        return retval;
    }
    // $ANTLR end "ctfAssignmentExpression"

