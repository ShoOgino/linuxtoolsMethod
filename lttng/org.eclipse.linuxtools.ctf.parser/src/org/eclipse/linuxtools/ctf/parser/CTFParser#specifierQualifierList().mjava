    // $ANTLR start "specifierQualifierList"
    // Grammar/CTFParser.g:536:1: specifierQualifierList : ( typeQualifier | typeSpecifier )+ -> ^( TYPE_SPECIFIER_LIST ( typeQualifier )* ( typeSpecifier )* ) ;
    public final CTFParser.specifierQualifierList_return specifierQualifierList() throws RecognitionException {
        CTFParser.specifierQualifierList_return retval = new CTFParser.specifierQualifierList_return();
        retval.start = input.LT(1);

        CommonTree root_0 = null;

        CTFParser.typeQualifier_return typeQualifier81 = null;

        CTFParser.typeSpecifier_return typeSpecifier82 = null;


        RewriteRuleSubtreeStream stream_typeSpecifier=new RewriteRuleSubtreeStream(adaptor,"rule typeSpecifier");
        RewriteRuleSubtreeStream stream_typeQualifier=new RewriteRuleSubtreeStream(adaptor,"rule typeQualifier");

          enter("specifierQualifierList");

        try {
            // Grammar/CTFParser.g:543:1: ( ( typeQualifier | typeSpecifier )+ -> ^( TYPE_SPECIFIER_LIST ( typeQualifier )* ( typeSpecifier )* ) )
            // Grammar/CTFParser.g:544:3: ( typeQualifier | typeSpecifier )+
            {
            // Grammar/CTFParser.g:544:3: ( typeQualifier | typeSpecifier )+
            int cnt26=0;
            loop26:
            do {
                int alt26=3;
                int LA26_0 = input.LA(1);

                if ( (LA26_0==CONSTTOK) ) {
                    alt26=1;
                }
                else if ( ((LA26_0>=CHARTOK && LA26_0<=ENUMTOK)||(LA26_0>=FLOATINGPOINTTOK && LA26_0<=SIGNEDTOK)||(LA26_0>=STRINGTOK && LA26_0<=STRUCTTOK)||(LA26_0>=UNSIGNEDTOK && LA26_0<=IMAGINARYTOK)) ) {
                    alt26=2;
                }
                else if ( (LA26_0==IDENTIFIER) && ((inTypealiasAlias() || isTypeName(input.LT(1).getText())))) {
                    alt26=2;
                }


                switch (alt26) {
            	case 1 :
            	    // Grammar/CTFParser.g:544:4: typeQualifier
            	    {
            	    pushFollow(FOLLOW_typeQualifier_in_specifierQualifierList1771);
            	    typeQualifier81=typeQualifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_typeQualifier.add(typeQualifier81.getTree());

            	    }
            	    break;
            	case 2 :
            	    // Grammar/CTFParser.g:544:20: typeSpecifier
            	    {
            	    pushFollow(FOLLOW_typeSpecifier_in_specifierQualifierList1775);
            	    typeSpecifier82=typeSpecifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_typeSpecifier.add(typeSpecifier82.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt26 >= 1 ) break loop26;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(26, input);
                        throw eee;
                }
                cnt26++;
            } while (true);



            // AST REWRITE
            // elements: typeSpecifier, typeQualifier
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {
            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (CommonTree)adaptor.nil();
            // 544:36: -> ^( TYPE_SPECIFIER_LIST ( typeQualifier )* ( typeSpecifier )* )
            {
                // Grammar/CTFParser.g:544:39: ^( TYPE_SPECIFIER_LIST ( typeQualifier )* ( typeSpecifier )* )
                {
                CommonTree root_1 = (CommonTree)adaptor.nil();
                root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(TYPE_SPECIFIER_LIST, "TYPE_SPECIFIER_LIST"), root_1);

                // Grammar/CTFParser.g:544:61: ( typeQualifier )*
                while ( stream_typeQualifier.hasNext() ) {
                    adaptor.addChild(root_1, stream_typeQualifier.nextTree());

                }
                stream_typeQualifier.reset();
                // Grammar/CTFParser.g:544:76: ( typeSpecifier )*
                while ( stream_typeSpecifier.hasNext() ) {
                    adaptor.addChild(root_1, stream_typeSpecifier.nextTree());

                }
                stream_typeSpecifier.reset();

                adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}
            }

            retval.stop = input.LT(-1);

            if ( state.backtracking==0 ) {

            retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
            if ( state.backtracking==0 ) {

                exit("specifierQualifierList");

            }
        }

        	catch (RecognitionException e)
        	{
        	  throw e;
        	}
        finally {
        }
        return retval;
    }
    // $ANTLR end "specifierQualifierList"

