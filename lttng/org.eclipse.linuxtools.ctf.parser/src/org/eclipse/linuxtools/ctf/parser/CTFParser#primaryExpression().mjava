    // $ANTLR start "primaryExpression"
    // Grammar/CTFParser.g:242:1: primaryExpression : ( ( IDENTIFIER )=> IDENTIFIER -> ^( UNARY_EXPRESSION_STRING IDENTIFIER ) | ( ctfKeyword )=> ctfKeyword -> ^( UNARY_EXPRESSION_STRING ctfKeyword ) | ( STRING_LITERAL )=> STRING_LITERAL -> ^( UNARY_EXPRESSION_STRING_QUOTES STRING_LITERAL ) | constant );
    public final CTFParser.primaryExpression_return primaryExpression() throws RecognitionException {
        CTFParser.primaryExpression_return retval = new CTFParser.primaryExpression_return();
        retval.start = input.LT(1);

        CommonTree root_0 = null;

        Token IDENTIFIER10=null;
        Token STRING_LITERAL12=null;
        CTFParser.ctfKeyword_return ctfKeyword11 = null;

        CTFParser.constant_return constant13 = null;


        CommonTree IDENTIFIER10_tree=null;
        CommonTree STRING_LITERAL12_tree=null;
        RewriteRuleTokenStream stream_STRING_LITERAL=new RewriteRuleTokenStream(adaptor,"token STRING_LITERAL");
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");
        RewriteRuleSubtreeStream stream_ctfKeyword=new RewriteRuleSubtreeStream(adaptor,"rule ctfKeyword");

          enter("primaryExpression"); 

        try {
            // Grammar/CTFParser.g:249:1: ( ( IDENTIFIER )=> IDENTIFIER -> ^( UNARY_EXPRESSION_STRING IDENTIFIER ) | ( ctfKeyword )=> ctfKeyword -> ^( UNARY_EXPRESSION_STRING ctfKeyword ) | ( STRING_LITERAL )=> STRING_LITERAL -> ^( UNARY_EXPRESSION_STRING_QUOTES STRING_LITERAL ) | constant )
            int alt5=4;
            switch ( input.LA(1) ) {
            case IDENTIFIER:
                {
                int LA5_1 = input.LA(2);

                if ( (synpred1_CTFParser()) ) {
                    alt5=1;
                }
                else if ( (true) ) {
                    alt5=4;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 5, 1, input);

                    throw nvae;
                }
                }
                break;
            case ALIGNTOK:
            case EVENTTOK:
            case SIGNEDTOK:
            case STRINGTOK:
                {
                int LA5_2 = input.LA(2);

                if ( (synpred2_CTFParser()) ) {
                    alt5=2;
                }
                else if ( (true) ) {
                    alt5=4;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 5, 2, input);

                    throw nvae;
                }
                }
                break;
            case STRING_LITERAL:
                {
                int LA5_3 = input.LA(2);

                if ( (synpred3_CTFParser()) ) {
                    alt5=3;
                }
                else if ( (true) ) {
                    alt5=4;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 5, 3, input);

                    throw nvae;
                }
                }
                break;
            case SIGN:
            case OCTAL_LITERAL:
            case DECIMAL_LITERAL:
            case HEX_LITERAL:
            case CHARACTER_LITERAL:
                {
                alt5=4;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 5, 0, input);

                throw nvae;
            }

            switch (alt5) {
                case 1 :
                    // Grammar/CTFParser.g:250:5: ( IDENTIFIER )=> IDENTIFIER
                    {
                    IDENTIFIER10=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_primaryExpression475); if (state.failed) return retval; 
                    if ( state.backtracking==0 ) stream_IDENTIFIER.add(IDENTIFIER10);

                    if ( state.backtracking==0 ) {
                       debug_print("IDENTIFIER: " + (IDENTIFIER10!=null?IDENTIFIER10.getText():null));
                    }


                    // AST REWRITE
                    // elements: IDENTIFIER
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    if ( state.backtracking==0 ) {
                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

                    root_0 = (CommonTree)adaptor.nil();
                    // 250:83: -> ^( UNARY_EXPRESSION_STRING IDENTIFIER )
                    {
                        // Grammar/CTFParser.g:250:86: ^( UNARY_EXPRESSION_STRING IDENTIFIER )
                        {
                        CommonTree root_1 = (CommonTree)adaptor.nil();
                        root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(UNARY_EXPRESSION_STRING, "UNARY_EXPRESSION_STRING"), root_1);

                        adaptor.addChild(root_1, stream_IDENTIFIER.nextNode());

                        adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}
                    }
                    break;
                case 2 :
                    // Grammar/CTFParser.g:251:5: ( ctfKeyword )=> ctfKeyword
                    {
                    pushFollow(FOLLOW_ctfKeyword_in_primaryExpression497);
                    ctfKeyword11=ctfKeyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_ctfKeyword.add(ctfKeyword11.getTree());


                    // AST REWRITE
                    // elements: ctfKeyword
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    if ( state.backtracking==0 ) {
                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

                    root_0 = (CommonTree)adaptor.nil();
                    // 251:32: -> ^( UNARY_EXPRESSION_STRING ctfKeyword )
                    {
                        // Grammar/CTFParser.g:251:35: ^( UNARY_EXPRESSION_STRING ctfKeyword )
                        {
                        CommonTree root_1 = (CommonTree)adaptor.nil();
                        root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(UNARY_EXPRESSION_STRING, "UNARY_EXPRESSION_STRING"), root_1);

                        adaptor.addChild(root_1, stream_ctfKeyword.nextTree());

                        adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}
                    }
                    break;
                case 3 :
                    // Grammar/CTFParser.g:252:5: ( STRING_LITERAL )=> STRING_LITERAL
                    {
                    STRING_LITERAL12=(Token)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_primaryExpression517); if (state.failed) return retval; 
                    if ( state.backtracking==0 ) stream_STRING_LITERAL.add(STRING_LITERAL12);

                    if ( state.backtracking==0 ) {
                       debug_print("STRING_LITERAL: " + (STRING_LITERAL12!=null?STRING_LITERAL12.getText():null));
                    }


                    // AST REWRITE
                    // elements: STRING_LITERAL
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    if ( state.backtracking==0 ) {
                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

                    root_0 = (CommonTree)adaptor.nil();
                    // 252:99: -> ^( UNARY_EXPRESSION_STRING_QUOTES STRING_LITERAL )
                    {
                        // Grammar/CTFParser.g:252:102: ^( UNARY_EXPRESSION_STRING_QUOTES STRING_LITERAL )
                        {
                        CommonTree root_1 = (CommonTree)adaptor.nil();
                        root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(UNARY_EXPRESSION_STRING_QUOTES, "UNARY_EXPRESSION_STRING_QUOTES"), root_1);

                        adaptor.addChild(root_1, stream_STRING_LITERAL.nextNode());

                        adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}
                    }
                    break;
                case 4 :
                    // Grammar/CTFParser.g:254:5: constant
                    {
                    root_0 = (CommonTree)adaptor.nil();

                    pushFollow(FOLLOW_constant_in_primaryExpression538);
                    constant13=constant();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, constant13.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);

            if ( state.backtracking==0 ) {

            retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
            if ( state.backtracking==0 ) {

                exit("primaryExpression");

            }
        }

        	catch (RecognitionException e)
        	{
        	  throw e;
        	}
        finally {
        }
        return retval;
    }
    // $ANTLR end "primaryExpression"

