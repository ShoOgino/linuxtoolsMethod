	// $ANTLR start "structSpecifier"
	// org/eclipse/linuxtools/ctf/parser/CTFParser.g:321:1: structSpecifier : STRUCTTOK ( ( structName ( alignAttribute | ( structBody ( alignAttribute |) ) |) ) | ( structBody ( alignAttribute |) ) ) -> ^( STRUCT ( structName )? ( structBody )? ( alignAttribute )? ) ;
	public final CTFParser.structSpecifier_return structSpecifier() throws RecognitionException {
		CTFParser.structSpecifier_return retval = new CTFParser.structSpecifier_return();
		retval.start = input.LT(1);

		CommonTree root_0 = null;

		Token STRUCTTOK65=null;
		ParserRuleReturnScope structName66 =null;
		ParserRuleReturnScope alignAttribute67 =null;
		ParserRuleReturnScope structBody68 =null;
		ParserRuleReturnScope alignAttribute69 =null;
		ParserRuleReturnScope structBody70 =null;
		ParserRuleReturnScope alignAttribute71 =null;

		CommonTree STRUCTTOK65_tree=null;
		RewriteRuleTokenStream stream_STRUCTTOK=new RewriteRuleTokenStream(adaptor,"token STRUCTTOK");
		RewriteRuleSubtreeStream stream_structName=new RewriteRuleSubtreeStream(adaptor,"rule structName");
		RewriteRuleSubtreeStream stream_structBody=new RewriteRuleSubtreeStream(adaptor,"rule structBody");
		RewriteRuleSubtreeStream stream_alignAttribute=new RewriteRuleSubtreeStream(adaptor,"rule alignAttribute");

		try {
			// org/eclipse/linuxtools/ctf/parser/CTFParser.g:322:3: ( STRUCTTOK ( ( structName ( alignAttribute | ( structBody ( alignAttribute |) ) |) ) | ( structBody ( alignAttribute |) ) ) -> ^( STRUCT ( structName )? ( structBody )? ( alignAttribute )? ) )
			// org/eclipse/linuxtools/ctf/parser/CTFParser.g:322:5: STRUCTTOK ( ( structName ( alignAttribute | ( structBody ( alignAttribute |) ) |) ) | ( structBody ( alignAttribute |) ) )
			{
			STRUCTTOK65=(Token)match(input,STRUCTTOK,FOLLOW_STRUCTTOK_in_structSpecifier1264); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_STRUCTTOK.add(STRUCTTOK65);

			// org/eclipse/linuxtools/ctf/parser/CTFParser.g:323:3: ( ( structName ( alignAttribute | ( structBody ( alignAttribute |) ) |) ) | ( structBody ( alignAttribute |) ) )
			int alt21=2;
			int LA21_0 = input.LA(1);
			if ( (LA21_0==IDENTIFIER) ) {
				alt21=1;
			}
			else if ( (LA21_0==LCURL) ) {
				alt21=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 21, 0, input);
				throw nvae;
			}

			switch (alt21) {
				case 1 :
					// org/eclipse/linuxtools/ctf/parser/CTFParser.g:325:5: ( structName ( alignAttribute | ( structBody ( alignAttribute |) ) |) )
					{
					// org/eclipse/linuxtools/ctf/parser/CTFParser.g:325:5: ( structName ( alignAttribute | ( structBody ( alignAttribute |) ) |) )
					// org/eclipse/linuxtools/ctf/parser/CTFParser.g:326:9: structName ( alignAttribute | ( structBody ( alignAttribute |) ) |)
					{
					pushFollow(FOLLOW_structName_in_structSpecifier1289);
					structName66=structName();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_structName.add(structName66.getTree());
					// org/eclipse/linuxtools/ctf/parser/CTFParser.g:327:9: ( alignAttribute | ( structBody ( alignAttribute |) ) |)
					int alt19=3;
					switch ( input.LA(1) ) {
					case ALIGNTOK:
						{
						alt19=1;
						}
						break;
					case LCURL:
						{
						switch ( input.LA(2) ) {
						case BOOLTOK:
						case CHARTOK:
						case COMPLEXTOK:
						case CONSTTOK:
						case DOUBLETOK:
						case ENUMTOK:
						case FLOATINGPOINTTOK:
						case FLOATTOK:
						case IMAGINARYTOK:
						case INTEGERTOK:
						case INTTOK:
						case LONGTOK:
						case RCURL:
						case SHORTTOK:
						case STRUCTTOK:
						case TYPEALIASTOK:
						case TYPEDEFTOK:
						case UNSIGNEDTOK:
						case VARIANTTOK:
						case VOIDTOK:
							{
							alt19=2;
							}
							break;
						case SIGNEDTOK:
							{
							int LA19_5 = input.LA(3);
							if ( (LA19_5==BOOLTOK||LA19_5==CHARTOK||(LA19_5 >= COMPLEXTOK && LA19_5 <= CONSTTOK)||LA19_5==DOUBLETOK||LA19_5==ENUMTOK||(LA19_5 >= FLOATINGPOINTTOK && LA19_5 <= FLOATTOK)||(LA19_5 >= IDENTIFIER && LA19_5 <= IMAGINARYTOK)||LA19_5==INTEGERTOK||LA19_5==INTTOK||LA19_5==LONGTOK||LA19_5==POINTER||LA19_5==SHORTTOK||LA19_5==SIGNEDTOK||LA19_5==STRINGTOK||LA19_5==STRUCTTOK||LA19_5==TYPEDEFTOK||(LA19_5 >= UNSIGNEDTOK && LA19_5 <= VOIDTOK)) ) {
								alt19=2;
							}
							else if ( (LA19_5==ASSIGNMENT||LA19_5==RCURL||LA19_5==SEPARATOR) ) {
								alt19=3;
							}

							else {
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 19, 5, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}

							}
							break;
						case STRINGTOK:
							{
							int LA19_6 = input.LA(3);
							if ( (LA19_6==BOOLTOK||LA19_6==CHARTOK||(LA19_6 >= COMPLEXTOK && LA19_6 <= CONSTTOK)||LA19_6==DOUBLETOK||LA19_6==ENUMTOK||(LA19_6 >= FLOATINGPOINTTOK && LA19_6 <= FLOATTOK)||(LA19_6 >= IDENTIFIER && LA19_6 <= IMAGINARYTOK)||LA19_6==INTEGERTOK||(LA19_6 >= INTTOK && LA19_6 <= LCURL)||LA19_6==LONGTOK||LA19_6==POINTER||LA19_6==SHORTTOK||LA19_6==SIGNEDTOK||LA19_6==STRINGTOK||LA19_6==STRUCTTOK||LA19_6==TYPEDEFTOK||(LA19_6 >= UNSIGNEDTOK && LA19_6 <= VOIDTOK)) ) {
								alt19=2;
							}
							else if ( (LA19_6==ASSIGNMENT||LA19_6==RCURL||LA19_6==SEPARATOR) ) {
								alt19=3;
							}

							else {
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 19, 6, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}

							}
							break;
						case IDENTIFIER:
							{
							int LA19_7 = input.LA(3);
							if ( (LA19_7==BOOLTOK||LA19_7==CHARTOK||(LA19_7 >= COMPLEXTOK && LA19_7 <= CONSTTOK)||LA19_7==DOUBLETOK||LA19_7==ENUMTOK||(LA19_7 >= FLOATINGPOINTTOK && LA19_7 <= FLOATTOK)||(LA19_7 >= IDENTIFIER && LA19_7 <= IMAGINARYTOK)||LA19_7==INTEGERTOK||LA19_7==INTTOK||LA19_7==LONGTOK||LA19_7==POINTER||LA19_7==SHORTTOK||LA19_7==SIGNEDTOK||LA19_7==STRINGTOK||LA19_7==STRUCTTOK||LA19_7==TYPEDEFTOK||(LA19_7 >= UNSIGNEDTOK && LA19_7 <= VOIDTOK)) ) {
								alt19=2;
							}
							else if ( (LA19_7==ASSIGNMENT||LA19_7==RCURL||LA19_7==SEPARATOR) ) {
								alt19=3;
							}

							else {
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 19, 7, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}

							}
							break;
						case ALIGNTOK:
						case EVENTTOK:
						case STRING_LITERAL:
							{
							alt19=3;
							}
							break;
						default:
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 19, 2, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}
						}
						break;
					case EOF:
					case BOOLTOK:
					case CHARTOK:
					case COMPLEXTOK:
					case CONSTTOK:
					case DOUBLETOK:
					case ENUMTOK:
					case FLOATINGPOINTTOK:
					case FLOATTOK:
					case IDENTIFIER:
					case IMAGINARYTOK:
					case INTEGERTOK:
					case INTTOK:
					case LONGTOK:
					case LPAREN:
					case POINTER:
					case SHORTTOK:
					case SIGNEDTOK:
					case STRINGTOK:
					case STRUCTTOK:
					case TERM:
					case TYPEDEFTOK:
					case TYPE_ASSIGNMENT:
					case UNSIGNEDTOK:
					case VARIANTTOK:
					case VOIDTOK:
						{
						alt19=3;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 19, 0, input);
						throw nvae;
					}
					switch (alt19) {
						case 1 :
							// org/eclipse/linuxtools/ctf/parser/CTFParser.g:328:11: alignAttribute
							{
							pushFollow(FOLLOW_alignAttribute_in_structSpecifier1311);
							alignAttribute67=alignAttribute();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_alignAttribute.add(alignAttribute67.getTree());
							}
							break;
						case 2 :
							// org/eclipse/linuxtools/ctf/parser/CTFParser.g:330:11: ( structBody ( alignAttribute |) )
							{
							// org/eclipse/linuxtools/ctf/parser/CTFParser.g:330:11: ( structBody ( alignAttribute |) )
							// org/eclipse/linuxtools/ctf/parser/CTFParser.g:331:13: structBody ( alignAttribute |)
							{
							pushFollow(FOLLOW_structBody_in_structSpecifier1347);
							structBody68=structBody();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_structBody.add(structBody68.getTree());
							// org/eclipse/linuxtools/ctf/parser/CTFParser.g:332:13: ( alignAttribute |)
							int alt18=2;
							int LA18_0 = input.LA(1);
							if ( (LA18_0==ALIGNTOK) ) {
								alt18=1;
							}
							else if ( (LA18_0==EOF||LA18_0==BOOLTOK||LA18_0==CHARTOK||(LA18_0 >= COMPLEXTOK && LA18_0 <= CONSTTOK)||LA18_0==DOUBLETOK||LA18_0==ENUMTOK||(LA18_0 >= FLOATINGPOINTTOK && LA18_0 <= FLOATTOK)||(LA18_0 >= IDENTIFIER && LA18_0 <= IMAGINARYTOK)||LA18_0==INTEGERTOK||(LA18_0 >= INTTOK && LA18_0 <= LCURL)||(LA18_0 >= LONGTOK && LA18_0 <= LPAREN)||LA18_0==POINTER||LA18_0==SHORTTOK||LA18_0==SIGNEDTOK||LA18_0==STRINGTOK||(LA18_0 >= STRUCTTOK && LA18_0 <= TERM)||(LA18_0 >= TYPEDEFTOK && LA18_0 <= TYPE_ASSIGNMENT)||(LA18_0 >= UNSIGNEDTOK && LA18_0 <= VOIDTOK)) ) {
								alt18=2;
							}

							else {
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae =
									new NoViableAltException("", 18, 0, input);
								throw nvae;
							}

							switch (alt18) {
								case 1 :
									// org/eclipse/linuxtools/ctf/parser/CTFParser.g:333:14: alignAttribute
									{
									pushFollow(FOLLOW_alignAttribute_in_structSpecifier1378);
									alignAttribute69=alignAttribute();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_alignAttribute.add(alignAttribute69.getTree());
									}
									break;
								case 2 :
									// org/eclipse/linuxtools/ctf/parser/CTFParser.g:336:13: 
									{
									}
									break;

							}

							}

							}
							break;
						case 3 :
							// org/eclipse/linuxtools/ctf/parser/CTFParser.g:340:9: 
							{
							}
							break;

					}

					}

					}
					break;
				case 2 :
					// org/eclipse/linuxtools/ctf/parser/CTFParser.g:344:5: ( structBody ( alignAttribute |) )
					{
					// org/eclipse/linuxtools/ctf/parser/CTFParser.g:344:5: ( structBody ( alignAttribute |) )
					// org/eclipse/linuxtools/ctf/parser/CTFParser.g:345:7: structBody ( alignAttribute |)
					{
					pushFollow(FOLLOW_structBody_in_structSpecifier1494);
					structBody70=structBody();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_structBody.add(structBody70.getTree());
					// org/eclipse/linuxtools/ctf/parser/CTFParser.g:346:7: ( alignAttribute |)
					int alt20=2;
					int LA20_0 = input.LA(1);
					if ( (LA20_0==ALIGNTOK) ) {
						alt20=1;
					}
					else if ( (LA20_0==EOF||LA20_0==BOOLTOK||LA20_0==CHARTOK||(LA20_0 >= COMPLEXTOK && LA20_0 <= CONSTTOK)||LA20_0==DOUBLETOK||LA20_0==ENUMTOK||(LA20_0 >= FLOATINGPOINTTOK && LA20_0 <= FLOATTOK)||(LA20_0 >= IDENTIFIER && LA20_0 <= IMAGINARYTOK)||LA20_0==INTEGERTOK||(LA20_0 >= INTTOK && LA20_0 <= LCURL)||(LA20_0 >= LONGTOK && LA20_0 <= LPAREN)||LA20_0==POINTER||LA20_0==SHORTTOK||LA20_0==SIGNEDTOK||LA20_0==STRINGTOK||(LA20_0 >= STRUCTTOK && LA20_0 <= TERM)||(LA20_0 >= TYPEDEFTOK && LA20_0 <= TYPE_ASSIGNMENT)||(LA20_0 >= UNSIGNEDTOK && LA20_0 <= VOIDTOK)) ) {
						alt20=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 20, 0, input);
						throw nvae;
					}

					switch (alt20) {
						case 1 :
							// org/eclipse/linuxtools/ctf/parser/CTFParser.g:347:9: alignAttribute
							{
							pushFollow(FOLLOW_alignAttribute_in_structSpecifier1512);
							alignAttribute71=alignAttribute();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_alignAttribute.add(alignAttribute71.getTree());
							}
							break;
						case 2 :
							// org/eclipse/linuxtools/ctf/parser/CTFParser.g:350:7: 
							{
							}
							break;

					}

					}

					}
					break;

			}

			// AST REWRITE
			// elements: structName, structBody, alignAttribute
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (CommonTree)adaptor.nil();
			// 352:5: -> ^( STRUCT ( structName )? ( structBody )? ( alignAttribute )? )
			{
				// org/eclipse/linuxtools/ctf/parser/CTFParser.g:352:8: ^( STRUCT ( structName )? ( structBody )? ( alignAttribute )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.nil();
				root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(STRUCT, "STRUCT"), root_1);
				// org/eclipse/linuxtools/ctf/parser/CTFParser.g:352:17: ( structName )?
				if ( stream_structName.hasNext() ) {
					adaptor.addChild(root_1, stream_structName.nextTree());
				}
				stream_structName.reset();

				// org/eclipse/linuxtools/ctf/parser/CTFParser.g:352:29: ( structBody )?
				if ( stream_structBody.hasNext() ) {
					adaptor.addChild(root_1, stream_structBody.nextTree());
				}
				stream_structBody.reset();

				// org/eclipse/linuxtools/ctf/parser/CTFParser.g:352:41: ( alignAttribute )?
				if ( stream_alignAttribute.hasNext() ) {
					adaptor.addChild(root_1, stream_alignAttribute.nextTree());
				}
				stream_alignAttribute.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}

		    catch (RecognitionException e) {
		        throw e;
		    }

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "structSpecifier"

