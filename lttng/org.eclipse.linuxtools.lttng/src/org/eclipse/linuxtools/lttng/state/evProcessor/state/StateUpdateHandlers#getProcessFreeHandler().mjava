	/**
	 * <p>
	 * Handles: LTT_EVENT_PROCESS_FREE
	 * </p>
	 * <p>
	 * Fields: LTT_FIELD_PID
	 * </p>
	 * 
	 * @return
	 */
	final ILttngEventProcessor getProcessFreeHandler() {
		AbsStateUpdate handler = new AbsStateUpdate() {

			// @Override
			public boolean process(LttngEvent trcEvent, LttngTraceState traceSt) {

				Long release_pid;
				LttngProcessState process;

				/* PID of the process to release */
				release_pid = getAFieldLong(trcEvent, traceSt,
						Fields.LTT_FIELD_PID);
				// s->parent.target_pid = release_pid;

				if ((release_pid != null) && (release_pid.longValue() == 0L)) {
					TraceDebug.debug("Unexpected release_pid: 0, Event time: "
							+ trcEvent.getTimestamp());
				}

				process = lttv_state_find_process(traceSt, ANY_CPU, release_pid);
				if (process != null) {
					exit_process(traceSt, process);
				}

				return false;
				// DISABLED
				// if(process != null) {
				/*
				 * release_task is happening at kernel level : we can now safely
				 * release the data structure of the process
				 */
				// This test is fun, though, as it may happen that
				// at time t : CPU 0 : process_free
				// at time t+150ns : CPU 1 : schedule out
				// Clearly due to time imprecision, we disable it. (Mathieu)
				// If this weird case happen, we have no choice but to put the
				// Currently running process on the cpu to 0.
				// I re-enable it following time precision fixes. (Mathieu)
				// Well, in the case where an process is freed by a process on
				// another
				// CPU
				// and still scheduled, it happens that this is the schedchange
				// that
				// will
				// drop the last reference count. Do not free it here!

				// int num_cpus = ltt_trace_get_num_cpu(ts->parent.t);
				// guint i;
				// for(i=0; i< num_cpus; i++) {
				// //g_assert(process != ts->running_process[i]);
				// if(process == ts->running_process[i]) {
				// //ts->running_process[i] = lttv_state_find_process(ts, i, 0);
				// break;
				// }
				// }
				// if(i == num_cpus) /* process is not scheduled */
				// exit_process(s, process);
				// }
				//	
				// return false;

			}
		};
		return handler;
	}

