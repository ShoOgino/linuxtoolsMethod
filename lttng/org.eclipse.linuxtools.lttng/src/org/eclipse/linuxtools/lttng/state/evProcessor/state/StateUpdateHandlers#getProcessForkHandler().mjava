	/**
	 * <p>
	 * Handles: LTT_EVENT_PROCESS_FORK
	 * </p>
	 * <p>
	 * Fields: FIELD_ARRAY(LTT_FIELD_PARENT_PID, LTT_FIELD_CHILD_PID,
	 * LTT_FIELD_CHILD_TGID)
	 * </p>
	 * 
	 * @return
	 */
	final ILttngEventProcessor getProcessForkHandler() {
		AbsStateUpdate handler = new AbsStateUpdate() {

			// @Override
			public boolean process(LttngEvent trcEvent, LttngTraceState traceSt) {

				Long cpu = trcEvent.getCpuId();
				LttngProcessState process = traceSt.getRunning_process().get(
						cpu);
				TmfTimestamp timeStamp = trcEvent.getTimestamp();

				// /* Parent PID */
				// Long parent_pid = getAFieldLong(trcEvent, traceSt,
				// Fields.LTT_FIELD_PARENT_PID);

				/* Child PID */
				/* In the Linux Kernel, there is one PID per thread. */
				Long child_pid = getAFieldLong(trcEvent, traceSt,
						Fields.LTT_FIELD_CHILD_PID);

				/* Child TGID */
				/* tgid in the Linux kernel is the "real" POSIX PID. */
				Long child_tgid = getAFieldLong(trcEvent, traceSt,
						Fields.LTT_FIELD_CHILD_TGID);
				if (child_tgid == null) {
					child_tgid = 0L;
				}

				/*
				 * Mathieu : it seems like the process might have been scheduled
				 * in before the fork, and, in a rare case, might be the current
				 * process. This might happen in a SMP case where we don't have
				 * enough precision on the clocks.
				 * 
				 * Test reenabled after precision fixes on time. (Mathieu)
				 */
				// #if 0
				// zombie_process = lttv_state_find_process(ts, ANY_CPU,
				// child_pid);
				//	
				// if(unlikely(zombie_process != NULL)) {
				// /* Reutilisation of PID. Only now we are sure that the old
				// PID
				// * has been released. FIXME : should know when release_task
				// happens
				// instead.
				// */
				// guint num_cpus = ltt_trace_get_num_cpu(ts->parent.t);
				// guint i;
				// for(i=0; i< num_cpus; i++) {
				// g_assert(zombie_process != ts->running_process[i]);
				// }
				//	
				// exit_process(s, zombie_process);
				// }
				// #endif //0

				if (process.getPid().equals(child_pid)) {
					TraceDebug
							.debug("Unexpected, process pid equal to child pid: "
									+ child_pid
									+ " Event Time: "
									+ trcEvent.getTimestamp());
				}

				// g_assert(process->pid != child_pid);
				// FIXME : Add this test in the "known state" section
				// g_assert(process->pid == parent_pid);
				LttngProcessState child_process = lttv_state_find_process(
						traceSt, ANY_CPU, child_pid);
				if (child_process == null) {
					child_process = create_process(traceSt, cpu, child_pid,
							child_tgid, timeStamp);
					child_process.setPpid(process.getPid(), timeStamp.getValue());
				} else {
					/*
					 * The process has already been created : due to time
					 * imprecision between multiple CPUs : it has been scheduled
					 * in before creation. Note that we shouldn't have this kind
					 * of imprecision.
					 * 
					 * Simply put a correct parent.
					 */
					StringBuilder sb = new StringBuilder("Process " + child_pid);
					sb.append(" has been created at ["
							+ child_process.getCreation_time() + "] ");
					sb.append("and inserted at ["
							+ child_process.getInsertion_time() + "] ");
					sb.append("before \nfork on cpu " + cpu + " Event time: ["
							+ trcEvent + "]\n.");
					sb
							.append("Probably an unsynchronized TSD problem on the traced machine.");
					TraceDebug.debug(sb.toString());

					// g_assert(0); /* This is a problematic case : the process
					// has
					// beencreated
					// before the fork event */
					child_process.setPpid(process.getPid());
					child_process.setTgid(child_tgid);
				}

				if (!child_process.getName().equals(
						ProcessStatus.LTTV_STATE_UNNAMED.getInName())) {
					TraceDebug.debug("Unexpected child process status: "
							+ child_process.getName());
				}

				child_process.setName(process.getName());
				child_process.setBrand(process.getBrand());

				return false;

			}
		};
		return handler;
	}

