	/* (non-Javadoc)
	 * @see org.eclipse.linuxtools.lttng.state.evProcessor.ILttngEventProcessor#process(org.eclipse.linuxtools.lttng.event.LttngEvent, org.eclipse.linuxtools.lttng.state.model.LttngTraceState)
	 */
	public boolean process(LttngEvent trcEvent, LttngTraceState traceSt) {
		if (trcEvent instanceof LttngSyntheticEvent) {

			// prepare to dispatch synthetic events to its corresponding handler
			LttngSyntheticEvent synEvent = (LttngSyntheticEvent) trcEvent;
			ILttngEventProcessor processor = null;

			// Status indicators do not contain a valid marker name
			if (synEvent.getSynType() == SequenceInd.STARTREQ) {
				reset();
				return false;
			}

			if (synEvent.getSynType() == SequenceInd.ENDREQ) {
				processor = getfinishProcessor();
				TraceDebug.debug("EndRequest satus received:");
			} else {
				// valid marker name expected
				String eventType = synEvent.getMarkerName();

				if (synEvent.getSynType() == SequenceInd.BEFORE) {
					processor = getBeforeProcessor(eventType);
					// increment event count only for one sequence indicator,
					// Note: BEFORE is selected to be used as an indicator to
					// prevent duplicated updates in the state system
					incrementBeforeEventCount();
				}

				if (synEvent.getSynType() == SequenceInd.UPDATE) {
					processor = getStateUpdaterProcessor(eventType);
					incrementStateUpdateCount();
				}

				if (synEvent.getSynType() == SequenceInd.AFTER) {
					processor = getAfterProcessor(eventType);
				}

				// TODO: Implement filter of events not associated to this trace
				// Make sure the event received is associated to this trace
				// handling context, Implementing a trace compare for each event
				// is not acceptable due to performance, and a reference check
				// may not be feasible since there are trace clones used either
				// to build the state system check points or UI requests.

				// if (traceSt != null && trcEvent.getParentTrace() !=
				// traceSt.getContext().getTraceIdRef()) {
				// // increment the number of events filtered out
				// filteredOutEventsCount++;
				// return false;
				// }
			}

			if (processor != null) {
				processor.process(trcEvent, traceSt);
			}
		}

		return true;
	}

