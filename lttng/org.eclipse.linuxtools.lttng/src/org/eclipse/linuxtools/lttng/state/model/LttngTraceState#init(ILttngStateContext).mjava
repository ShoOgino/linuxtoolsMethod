	public void init(ILttngStateContext context)
			throws LttngStateException {
		if (context == null) {
			StringBuilder sb = new StringBuilder(
					"The input provider reference must not be null");
			throw new LttngStateException(sb.toString());
		}

		// Save the input data reference
		fContext = context;

		// Save traceid
		traceId = fContext.getTraceId();

		// max time
		max_time_state_recomputed_in_seek = 0L;

		// reset cpu_states
		cpu_states.clear();
		
		// Obtain the total num of available CPUs and initialize the map
		// to the corresponding size
		int numCpus = fContext.getNumberOfCpus();
		for (Long i = 0L; i < numCpus; i++) {
			cpu_states.put(i, new LTTngCPUState());
		}

		// irq states
		irq_states.clear();
		for (Long i = 0L; i < irq_names.size(); i++) {
			irq_states.put(i, new LttngIRQState());
		}

		// soft irqs
		soft_irq_states.clear();
		for (Long i = 0L; i < soft_irq_names.size(); i++) {
			soft_irq_states.put(i, new LttngSoftIRQState());
		}

		// traps
		trap_states.clear();
		for (Long i = 0L; i < trap_names.size(); i++) {
			trap_states.put(i, new LttngTrapState(0L));
		}

		// bdev states
		bdev_states.clear();
		
		processes.clear();

		nb_events = 0;
		TmfTimeRange timeWin = fContext.getTraceTimeWindow();

		/* Put the per cpu running_process to beginning state : process 0. */
		for (Long i = 0L; i < numCpus; i++) {
			LttngProcessState process = new LttngProcessState(timeWin.getStartTime().getValue(), traceId );

			/*
			 * We are not sure is it's a kernel thread or normal thread, put the
			 * bottom stack state to unknown
			 */
			LttngExecutionState es = process.getFirstElementFromExecutionStack();
			process.setState(es);
			es.setExec_mode(ExecutionMode.LTTV_STATE_MODE_UNKNOWN);
			es.setExec_submode(ExecutionSubMode.LTTV_STATE_SUBMODE_NONE
					.getInName());
			es.setProc_status(ProcessStatus.LTTV_STATE_UNNAMED);

			// Reduce from default to only one execution state in the stack
			process.popFromExecutionStack();

			process.setCpu(i);
			// no associated user trace yet
			process.setUserTrace("");
			// processes.put(i, process);
			running_process.put(i, process);
			// reset cpu states
			LTTngCPUState cpuState = cpu_states.get(i);
			cpuState.reset();
			// Add the new process to the list
			processes.put(new ProcessStateKey(process), process);
		}

		// reset irq_states
		for (Long key : irq_states.keySet()) {
			LttngIRQState irqState = irq_states.get(key);
			irqState.clearAndSetBaseToIrqStack(IRQMode.LTTV_IRQ_UNKNOWN);
		}

		// reset soft_irq_states
		for (Long key : soft_irq_states.keySet()) {
			LttngSoftIRQState softIrqState = soft_irq_states.get(key);
			softIrqState.reset();
		}

		// reset trap_states
		for (Long key : trap_states.keySet()) {
			LttngTrapState trapState = trap_states.get(key);
			trapState.setRunning(0L);
		}

		// reset bdev_states
		for (Long key : bdev_states.keySet()) {
			LttngBdevState bdevState = bdev_states.get(key);
			bdevState.clearBdevStack();
		}

	}

