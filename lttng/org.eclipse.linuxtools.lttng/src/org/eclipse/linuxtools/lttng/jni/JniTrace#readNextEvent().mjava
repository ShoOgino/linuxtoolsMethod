    /**
     * Return the next event, determined by timestamp, among the trace files.
     * The event content is populated.
     *  
     * Returns  null in case of error or if we reach end of trace.
     * 
     * @return The next event in the trace or null
     * @see org.eclipse.linuxtools.lttng.jni.JniEvent
     */
    public JniEvent readNextEvent() {
        // Get the "next" event on the top of the heap but DO NOT remove it
        JniEvent tmpEvent = eventsHeap.peek();
        
        // If the event is null, it was the last one in the trace we can leave the function
        if (tmpEvent == null) {
            return null;
        }
        
        // Otherwise, we need to make sure the timestamp of the event we got is not the same as the last "NextEvent" we requested 
        if (tmpEvent.getEventTime().getTime() == currentEventTimestamp.getTime() ) {
            // Remove the event on top as it is the same currentEventTimestamp
            eventsHeap.poll();
            
            // Read the next event for this particular event type
            tmpEvent.readNextEvent();
            
            // If the event state is sane (not Out of Range), put it back in the heap
            if ( tmpEvent.getEventState() == EOK ) {
                eventsHeap.add(tmpEvent);
            }
            
            // Pick the top event again
            tmpEvent = eventsHeap.peek();
            
            // Save the timestamp if the event is not null (null mean we reached the last event in the trace)
            if (tmpEvent != null) {
                currentEventTimestamp = tmpEvent.getEventTime();
            }
        }
        // If the event on top has differetn timestamp than the currentTimestamp, just save this timestamp as current
        else {
            currentEventTimestamp = tmpEvent.getEventTime();
        }
            
        return tmpEvent;
    }

