    /**
     * Constructor with parameters<br>
     * <br>
     * This constructor could throw. It will happen if an event can not be populated on first read.<br>
     * In that case, the parent tracefile is probably useless and should be deleted.
     * 
     * @param newEventPtr         C pointer (converted in long) of the LttEvent C structure.
     * @param newMarkersMap       Reference an already populated HashMap of JniMarker objects 
     * @param newParentTracefile  Reference to the parent JniTracefile of this JniEvent
     *            
     * @exception JniException           
     */
    public JniEvent(C_Pointer newEventPtr, HashMap<Integer, JniMarker> newMarkersMap, JniTracefile newParentTracefile) throws JniException {

        // Basic test to make sure we didn't get null/empty value 
        if ((newEventPtr.getPointer() == NULL)
                || (newMarkersMap == null) 
                || (newMarkersMap.size() == 0)
                || (newParentTracefile == null)) {
            throw new JniEventException("Null or empty value passed to constructor, object is invalid! (JniEvent)");
        }
        
        thisEventPtr = newEventPtr;
        tracefilePtr = newParentTracefile.getTracefilePtr();
        markersMap = newMarkersMap;
        parentTracefile = newParentTracefile;

        eventTime = new JniTime();
        
        // *** FIXME ***
        // *** HACK  ***
        // Lttv C library (liblttvtraceread) fail with "assertation error" while calling ltt_seek_next_event() on "metadata" type of events
        //	 We do not really care about "metadata" stuff as these are special events type for marker self-definition in the trace
        // 	 However, this force us to add a (very bad) special case here temporary. 
        // 
        // Note that this only happen on multi-CPU trace, on single CPU trace, the call to ltt_seek_next_event() works correctly
        if ( parentTracefile.getTracefileName().equals("metadata") ) {
        	throw new JniNoSuchEventException("FIXME : Metadata tracefile badly handled in liblttvtraceread.");
        }
        
        // Try to move to the first event
        // If the event is Out of Range (ERANGE) at the first range, this event
        // type will never been usable
        // In that case, throw JafEventOutOfRangeException to warn the parent
        // tracefile
        //
        // Position ourself on the next (first?) event
        eventState = positionToFirstEvent();
        if (eventState != EOK) {
            throw new JniNoSuchEventException("Object not populated, unusable. There is probably no event of that type in the trace. (JniEvent)");
        }
        else {
            populateEventInformation();
        }
    }

