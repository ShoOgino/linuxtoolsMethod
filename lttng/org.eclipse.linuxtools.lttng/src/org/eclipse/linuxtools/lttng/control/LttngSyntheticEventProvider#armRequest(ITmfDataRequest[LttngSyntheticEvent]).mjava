	@SuppressWarnings("unchecked")
	@Override
	public ITmfContext armRequest(
			final ITmfDataRequest<LttngSyntheticEvent> request) {
		// validate
		// make sure we have the right type of request
		if (!(request instanceof ITmfEventRequest<?>)) {
			request.cancel();
			TraceDebug.debug("Request is not an instance of ITmfEventRequest");
			return null;
		}

		if (fExperiment == null) {
			TraceDebug.debug("Experiment is null");
			request.cancel();
			return null;
		}

		// get ready to start processing
		reset(fExperiment);

		// At least one base provider shall be available
		if (fEventProviderRequests.size() < 1) {
			request.cancel();
			TraceDebug.debug("No Base event providers available");
			return null;
		}

		fmainRequest = request;
		// define event data handling
		ITmfEventRequest<LttngSyntheticEvent> eventRequest = (ITmfEventRequest<LttngSyntheticEvent>) fmainRequest;
		TmfTimeRange reqWindow = eventRequest.getRange();

		TraceDebug.debug("Main Synthethic event request started on thread:  " + Thread.currentThread().getName());

		// loop for every traceManager in current experiment
		boolean subRequestQueued = false;
		TmfExperiment<LttngEvent> experiment = (TmfExperiment<LttngEvent>) fExperiment.getValue();
		experiment.startSynch(new TmfStartSynchSignal(0));
		for (IStateTraceManager traceManager : fEventProviderRequests.keySet()) {

			// restore trace state system to nearest check point
			TmfTimestamp checkPoint = traceManager
					.restoreCheckPointByTimestamp(reqWindow.getStartTime());

			// adjust start time bound to check point

			// validate so checkpoint restore is within requested bounds
			TmfTimeRange traceRange = traceManager.getTrace().getTimeRange();
			if ((checkPoint != null) && !(
					checkPoint.getValue() >= traceRange.getStartTime().getValue() &&
					checkPoint.getValue() <= traceRange.getEndTime().getValue() && 
					checkPoint.getValue() < reqWindow.getEndTime().getValue())
					) {
				// checkpoint is out of trace bounds
				continue;
			}
			TmfTimeRange adjustedRange = reqWindow;
			if (checkPoint != null) {
				adjustedRange = new TmfTimeRange(checkPoint, reqWindow.getEndTime());
			}

			LttngTraceState traceModel = traceManager.getStateModel();
			// String key = (traceManager.getTrace().getPath() +
			// traceManager.getTrace().getName()).hashCode();
			ITmfTrace trace = traceManager.getTrace();
			// create sub-request for one trace within experiment
			final LttngBaseEventRequest subRequest = new LttngBaseEventRequest(adjustedRange, reqWindow.getStartTime(),
					0, TmfEventRequest.ALL_DATA, BLOCK_SIZE, traceModel, ITmfDataRequest.ExecutionType.SHORT, trace) {

				private LttngSyntheticEvent syntheticEvent = null;
				private LttngSyntheticEvent syntheticAckIndicator = null;
				long subEventCount = 0L;

				private final long fDispatchTime = getDispatchTime().getValue();
				private final LttngTraceState fTraceModel = getTraceModel();

				/*
				 * (non-Javadoc)
				 * 
				 * @see
				 * org.eclipse.linuxtools.lttng.control.LttngEventRequest#handleData
				 * ()
				 */
				@Override
				public void handleData() {
					LttngEvent[] events = getData();
					
//					Tracer.trace("Sep: " + events[0].getTimestamp());

					if (events.length > 0) {
						for (LttngEvent e : events) {
							handleIncomingData(e);
						}
					} else {
						TraceDebug.debug("handle data received with no data");
//						handleProviderDone(getTraceModel());
//						done();
					}
				}

				/*
				 * (non-Javadoc)
				 * 
				 * @see org.eclipse.linuxtools.tmf.request.TmfDataRequest#done()
				 */
				@Override
				public void done() {
					// mark this sub-request as completed
					super.done();
					handleProviderDone(getTraceModel());
//					super.done();
				}
				
				/**
				 * Trigger the Analysis and sequential control of the events.
				 * 
				 * @param e
				 */
				private void handleIncomingData(LttngEvent e) {
					long eventTime = e.getTimestamp().getValue();

					// if (eventTime == 13589777932952L) {
					// // syscall entry id 78 expected
					// System.out.println("debug mark at 13589777932952L");
					// }

					TmfTrace<LttngEvent> inTrace =  e.getParentTrace();
					if (!(inTrace == getTrace())) {
//						System.out.println("Event from a different trace discarded");
						return;
					}
					
					// queue the new event data and an ACK
					updateSynEvent(e);

					// If time at or above requested time, update application
					if (eventTime >= fDispatchTime) {
						// Before update
						syntheticEvent.setSequenceInd(SequenceInd.BEFORE);
//						queueResult(syntheticEvent);
//						queueResult(syntheticAckIndicator);

						LttngSyntheticEvent[] result = new LttngSyntheticEvent[1];
						result[0] = syntheticEvent;
						fmainRequest.setData(result);
						fmainRequest.handleData();
						result[0] = syntheticAckIndicator;
						fmainRequest.setData(result);
						fmainRequest.handleData();

						// Update state locally
						syntheticEvent.setSequenceInd(SequenceInd.UPDATE);
						fstateUpdateProcessor.process(syntheticEvent, fTraceModel);

						// After Update
						syntheticEvent.setSequenceInd(SequenceInd.AFTER);
//						queueResult(syntheticEvent);
//						queueResult(syntheticAckIndicator);

						result = new LttngSyntheticEvent[1];
						result[0] = syntheticEvent;
						fmainRequest.setData(result);
						fmainRequest.handleData();
						result[0] = syntheticAckIndicator;
						fmainRequest.setData(result);
						fmainRequest.handleData();

						// increment once per dispatch
						incrementSynEvenCount();
						subEventCount++;
					} else {
						// event time is between checkpoint adjusted time and
						// requested time i.e. application does not expect the
						// event, however the state system needs to be re-built
						// to the dispatch point
						syntheticEvent.setSequenceInd(SequenceInd.UPDATE);
						fstateUpdateProcessor.process(syntheticEvent, fTraceModel);
					}
				}

				/**
				 * Create a synthetic event from the received new reference, if
				 * the reference is the same there is no need for a new instance
				 * 
				 * if this is the first event for this request, call start
				 * handler
				 * 
				 * @param e
				 * @return
				 */
				private LttngSyntheticEvent updateSynEvent(LttngEvent e) {
					if (syntheticEvent == null
							|| syntheticEvent.getBaseEvent() != e) {
						syntheticEvent = new LttngSyntheticEvent(e);
						syntheticAckIndicator = new LttngSyntheticEvent(e);
						syntheticAckIndicator.setSequenceInd(SequenceInd.ACK);
					}

					// Trace model needed by application handlers
					syntheticEvent.setTraceModel(fTraceModel);

					// send the start request indication once per request thread
					if (!startIndSent) {
						TraceDebug.debug("Thread started: " + Thread.currentThread().getName());
						handleProviderStarted(getTraceModel());
						startIndSent = true;
					}

					return syntheticEvent;
				}
			};
						
			// preserve the associated sub request to control it e.g.
			// cancellation
			fEventProviderRequests.put(traceManager, subRequest);

			// start request
			TmfExperiment<LttngEvent> provider = (TmfExperiment<LttngEvent>) fExperiment.getValue();
			provider.sendRequest(subRequest);

			// provider.sendRequest(subRequest, ExecutionType.LONG);
			subRequestQueued = true;
		}

		experiment.endSynch(new TmfEndSynchSignal(0));

		// Return a dummy context, not used for relay provider
		return (subRequestQueued) ? new TmfContext() : null;
	}

