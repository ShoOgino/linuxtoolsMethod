    @Override
    public synchronized LttngEvent getNextEvent(TmfContext context) {
    	
    	if ( printDebug == true ) {
    		System.out.println("getNextEvent(context) context.getLocation() -> " + context.getLocation());
    	}
    	
    	LttngEvent 	returnedEvent = null;
    	LttngLocation curLocation = null;
    	
    	// If the location in context is null, create a new one
    	if ( context.getLocation() == null ) {
    		curLocation = new LttngLocation();
    		context.setLocation(curLocation);
    	}
    	else {
    		// Otherwise, we use the one in context; it should be a valid LttngLocation
    		curLocation = (LttngLocation)context.getLocation();
    	}
    	
////    	[lmcfrch]
//    	TmfContext savedContext = context.clone();
////    	[/lmcfrch]
    	
    	// *** HACK ***
    	// TMF assumes it is possible to read (GetNextEvent) to the next Event once ParseEvent() is called
    	// In LTTNG, there is not difference between "Parsing" and "Reading" an event.
    	//  	Since parsing/reading invalidate the previous event, 
    	//		we need to make sure the sequence ParseEvent() -> GetNextEvent() will not actually move to the next event.
    	// To do so, we avoid moving for call to "GetNextEvent()" that follow call to a call to "ParseEvent()".
    	// However, calling ParseEvent() -> GetNextEvent() -> GetNextEvent() will only move next by one.
    	
    	// *** Positioning trick :
    	// GetNextEvent only read the trace if : 
    	// 1- The last operation was NOT a ParseEvent --> A read is required
    	// 	OR
    	// 2- The time of the previous location is different from the current  one --> A seek + a read is required
    	if ( (curLocation.isLastOperationParse() != true) ||
    		 (previousLocation.getOperationTimeValue() != curLocation.getOperationTimeValue() ) ) 
    	{
			if ( previousLocation.getOperationTimeValue() != curLocation.getOperationTimeValue() ) {
				if ( printDebug == true ) {
					System.out.println("\t\tSeeking in getNextEvent. [ LastTime : " + previousLocation.getOperationTimeValue() + " CurrentTime" + curLocation.getOperationTimeValue() + " ]");
				}
				seekEvent( curLocation.getOperationTime() );
			}
			// Read the next event from the trace. The last one will NO LONGER BE VALID.
	    	returnedEvent = readEvent(curLocation);
    		nbEventsRead++;
	    	
	    	// Set the operation marker as read to both location, to be able to detect we did "read" this event
	    	previousLocation.setLastOperationReadNext();
	    	curLocation.setLastOperationReadNext();
    	}
    	else {
    		// No event was read, just return the one currently loaded (the last one we read)
    		returnedEvent = currentLttngEvent;
    		
    		// *** IMPORTANT!
    		// Reset (erase) the operation marker to both location, to be able to detect we did NOT "read" this event
        	previousLocation.resetLocationState();
        	curLocation.resetLocationState();
    	}
    	
    	// If we read an event, set it's time to the locations (both previous and current)
    	if ( returnedEvent != null ) {
    		previousLocation.setOperationTime((LttngTimestamp)returnedEvent.getTimestamp());
    		curLocation.setOperationTime((LttngTimestamp)returnedEvent.getTimestamp());

////        	[lmcfrch]
//    		LttngLocation prevLocation = (LttngLocation) savedContext.getLocation();
//    		LttngLocation currLocation = (LttngLocation) context.getLocation();
//    		Tracer.trace("Trc: " + context.getRank() + ": " + returnedEvent.getTimestamp().toString() + " (" +
//    				(prevLocation.isLastOperationParse() ? "T" : "F") + "," + (prevLocation.isLastOperationReadNext() ? "T" : "F") + "," + (prevLocation.isLastOperationSeek() ? "T" : "F") + "), (" +
//    				(currLocation.isLastOperationParse() ? "T" : "F") + "," + (currLocation.isLastOperationReadNext() ? "T" : "F") + "," + (currLocation.isLastOperationSeek() ? "T" : "F") + ")"
//    				);
////        	[/lmcfrch]

    		updateIndex(context, context.getRank(), returnedEvent.getTimestamp());
    		context.updateRank(1);
    	}

    	return returnedEvent;
    }

