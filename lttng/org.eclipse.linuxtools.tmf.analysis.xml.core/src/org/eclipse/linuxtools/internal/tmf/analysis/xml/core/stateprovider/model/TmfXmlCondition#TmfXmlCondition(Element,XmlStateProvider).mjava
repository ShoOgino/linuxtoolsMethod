    /**
     * Constructor
     *
     * @param node
     *            The XML root of this condition
     * @param provider
     *            The state provider this condition belongs to
     */
    public TmfXmlCondition(Element node, XmlStateProvider provider) {
        fProvider = provider;

        Element rootNode = node;
        /* Process the conditions: in each case, only process Element nodes */
        List<Element> childElements = XmlUtils.getChildElements(rootNode);

        /*
         * If the node is an if, take the child as the root condition
         *
         * FIXME: Maybe the caller should do this instead.
         */
        if (node.getNodeName().equals(TmfXmlStrings.IF)) {
            if (childElements.isEmpty()) {
                throw new IllegalArgumentException("TmfXmlCondition constructor: IF node has no child element"); //$NON-NLS-1$
            }
            rootNode = childElements.get(0);
            childElements = XmlUtils.getChildElements(rootNode);
        }

        switch (rootNode.getNodeName()) {
        case TmfXmlStrings.CONDITION:
            fOperator = ConditionOperator.NONE;
            /* The last element is a state value node */
            Element stateValueElement = childElements.remove(childElements.size() - 1);

            /*
             * A state value is either preceded by an eventField or a number of
             * state attributes
             */
            if (childElements.size() == 1 && childElements.get(0).getNodeName().equals(TmfXmlStrings.ELEMENT_FIELD)) {
                fStateValue = new TmfXmlStateValue(stateValueElement, fProvider, childElements.get(0).getAttribute(TmfXmlStrings.NAME));
            } else {
                List<TmfXmlStateAttribute> attributes = new ArrayList<>();
                for (Element element : childElements) {
                    if (!element.getNodeName().equals(TmfXmlStrings.STATE_ATTRIBUTE)) {
                        throw new IllegalArgumentException("TmfXmlCondition: a condition either has a eventField element or a number of TmfXmlStateAttribute elements before the state value"); //$NON-NLS-1$
                    }
                    TmfXmlStateAttribute attribute = new TmfXmlStateAttribute(element, fProvider);
                    attributes.add(attribute);
                }
                fStateValue = new TmfXmlStateValue(stateValueElement, fProvider, attributes);
            }
            break;
        case TmfXmlStrings.NOT:
            fOperator = ConditionOperator.NOT;
            fStateValue = null;
            fConditions.add(new TmfXmlCondition(childElements.get(0), fProvider));
            break;
        case TmfXmlStrings.AND:
            fOperator = ConditionOperator.AND;
            fStateValue = null;
            for (Element condition : childElements) {
                fConditions.add(new TmfXmlCondition(condition, fProvider));
            }
            break;
        case TmfXmlStrings.OR:
            fOperator = ConditionOperator.OR;
            fStateValue = null;
            for (Element condition : childElements) {
                fConditions.add(new TmfXmlCondition(condition, fProvider));
            }
            break;
        default:
            throw new IllegalArgumentException("TmfXmlCondition constructor: XML node is of the wrong type"); //$NON-NLS-1$
        }
    }

