    /**
     * Write the trace to a file
     *
     * @param path
     *            the path to write the trace to
     */
    public void writeTrace(String path) {
        fPath = new File(path);

        if (!fPath.exists()) {
            fPath.mkdir();
        } else {
            if (fPath.isFile()) {
                fPath.delete();
                fPath.mkdir();
            } else {
                // the ctf parser doesn't recurse, so we don't need to.
                final File[] listFiles = fPath.listFiles();
                for (File child : listFiles) {
                    child.delete();
                }
            }
        }

        fPath.deleteOnExit();
        File metadataFile = new File(fPath.getPath() + File.separator + "metadata");
        metadataFile.deleteOnExit();
        File[] streams = new File[fNbChans];
        FileChannel[] channels = new FileChannel[fNbChans];
        FileOutputStream fos = null;

        try {
            for (int i = 0; i < fNbChans; i++) {
                streams[i] = new File(fPath.getPath() + File.separator + "channel" + i);
                channels[i] = new FileOutputStream(streams[i]).getChannel();
                streams[i].deleteOnExit();
            }
        } catch (FileNotFoundException e) {
        }
        // determine the number of events per channel
        long evPerChan = fNbEvents / fNbChans;
        int delta = (int) (fDuration / evPerChan);
        int offsetTime = 0;
        for (int chan = 0; chan < fNbChans; chan++) {
            int currentSpace = 0;
            ByteBuffer bb = ByteBuffer.allocate(65536);
            bb.order(ByteOrder.LITTLE_ENDIAN);
            Random rnd = new Random(1337);
            int rnd0 = rnd.nextInt(fProcesses.size());
            String prevComm = fProcesses.get(rnd0);
            int prevPID = rnd0 + chan * fProcesses.size();
            if (rnd0 == 0) {
                prevPID = 0;
            }
            int prevPrio = 0;
            int prevPos = -1;
            for (int eventNb = 0; eventNb < evPerChan; eventNb++) {
                int ts = eventNb * delta + delta / (fNbChans + 1) * chan;

                int pos = rnd.nextInt((int) (fProcesses.size() * 1.5));
                if (pos >= fProcesses.size()) {
                    pos = 0;
                }
                while (pos == prevPos) {
                    pos = rnd.nextInt((int) (fProcesses.size() * 1.5));
                    if (pos >= fProcesses.size()) {
                        pos = 0;
                    }
                }
                String nextComm = fProcesses.get(pos);
                int nextPID = pos + fProcesses.size() * chan;
                if (pos == 0) {
                    nextPID = 0;
                }
                int nextPrio = 0;
                if (EventWriter.SIZE > currentSpace) {
                    // pad to end
                    for (int i = 0; i < currentSpace; i++) {
                        bb.put((byte) 0x00);
                    }
                    // write new packet
                    PacketWriter pw = new PacketWriter(bb);
                    int tsBegin = ts;
                    offsetTime = ts;
                    int tsEnd = (eventNb + (PacketWriter.SIZE / EventWriter.SIZE)) * delta + 1;
                    pw.writeNewHeader(tsBegin, tsEnd, chan);
                    currentSpace = PacketWriter.CONTENT_SIZE;
                }
                EventWriter ew = new EventWriter(bb);
                int prev_state = rnd.nextInt(100);
                if (prev_state != 0) {
                    prev_state = 1;
                }
                final int shrunkenTimestamp = ts - offsetTime;
                final int tsMask = (1 << 27) - 1;
                if (shrunkenTimestamp > ((1 << 27) + tsMask)) {
                    new Object();
                    System.err.println("PROBLEM");
                }
                final int clampedTs = ts & tsMask;
                int evSize = ew.writeEvent(clampedTs, prevComm, prevPID, prevPrio, prev_state, nextComm, nextPID, nextPrio);
                currentSpace -= evSize;
                prevComm = nextComm;
                prevPID = nextPID;
                prevPrio = nextPrio;
                if (bb.position() > 63000) {
                    writeToDisk(channels, chan, bb);
                }
            }
            for (int i = 0; i < currentSpace; i++) {
                bb.put((byte) 0x00);
            }
            writeToDisk(channels, chan, bb);
            try {
                channels[chan].close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        try {
            fos = new FileOutputStream(metadataFile);
            fos.write(metadata.getBytes());
            fos.close();
        } catch (IOException e) {
        }
    }

