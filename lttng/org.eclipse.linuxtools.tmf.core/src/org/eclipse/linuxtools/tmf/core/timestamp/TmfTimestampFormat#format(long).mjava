    /**
     * Format the timestamp according to its pattern.
     *
     * @param value the timestamp value to format (in ns)
     * @return the formatted timestamp
     */
    public synchronized String format(long value) {

        // Split the timestamp value into its sub-components
        long date = value / 1000000; // milliseconds since January 1, 1970, 00:00:00 GMT
        long sec = value / 1000000000;    // seconds since January 1, 1970, 00:00:00 GMT
        long ms  = Math.abs((value % 1000000000) / 1000000); // milliseconds
        long cs  = Math.abs((value % 1000000)    / 1000);    // microseconds
        long ns  = Math.abs(value % 1000);                   // nanoseconds

        // Adjust for negative value when formatted as a date
        if (value < 0 && ms + cs + ns > 0 && !super.toPattern().contains(fOpenBracket + "T")) { //$NON-NLS-1$
            date -= 1;
            long nanosec = 1000000000 - (1000000 * ms + 1000 * cs + ns);
            ms = nanosec / 1000000;
            cs = (nanosec % 1000000) / 1000;
            ns = nanosec % 1000;
        }

        // Let the base class format the date/time pattern
        StringBuffer result = new StringBuffer(super.format(date));
        // Append the sub-second pattern
        result.append(fSubSecPattern);

        int fractionDigitsPrinted = 0;
        // Fill in our extensions
        for (String pattern : fSupplPatterns) {
            int length = pattern.length();
            long val = 0;
            int bufLength = 0;

            // Format the proper value as per the pattern
            switch (pattern.charAt(0)) {
                case 'T':
                    if (value < 0 && sec == 0) {
                        result.insert(0, '-');
                    }
                    val = sec;
                    bufLength = Math.min(length, 10);
                    break;
                case 'S':
                    val = 1000000 * ms + 1000 * cs + ns;
                    bufLength = 9;
                    break;
                case 'C':
                    val = cs;
                    bufLength = Math.min(length, 3);
                    break;
                case 'N':
                    val = ns;
                    bufLength = Math.min(length, 3);
                    break;
                default:
                    break;
            }

            // Prepare the format buffer
            StringBuffer fmt = new StringBuffer();
            for (int i = 0; i < bufLength; i++) {
                fmt.append("0"); //$NON-NLS-1$
            }
            DecimalFormat dfmt = new DecimalFormat(fmt.toString());
            String fmtVal = dfmt.format(val);
            if (pattern.charAt(0) == 'S') {
                fmtVal = fmtVal.substring(fractionDigitsPrinted, Math.min(bufLength, fractionDigitsPrinted + length));
                fractionDigitsPrinted += fmtVal.length();
            }

            // Substitute the placeholder pattern with the formatted value
            String ph = new StringBuffer(fOpenBracket + pattern + fCloseBracket).toString();
            int loc = result.indexOf(ph);
            result.replace(loc, loc + length + fOpenBracket.length() + fCloseBracket.length(), fmtVal);
        }

        return result.toString();
    }

