    /**
     * Method that start the process of matching events
     *
     * @return Whether the match was completed correctly or not
     */
    @Override
    public boolean matchEvents() {

        /* Are there traces to match? If no, return false */
        if (!(fTraces.size() > 0)) {
            return false;
        }

        // TODO Start a new thread here?
        initMatching();

        /**
         * For each trace, get the events and for each event, call the
         * MatchEvent method
         *
         * FIXME This would use a lot of memory if the traces are big, because
         * all involved events from first trace will have to be kept before a
         * first match is possible with second trace.
         *
         * <pre>
         * Other possible matching strategy:
         * Incremental:
         * Sliding window:
         * Other strategy: start with the shortest trace, take a few events
         * at the beginning and at the end
         * Experiment strategy: have the experiment do the request, then events will
         * come from both traces chronologically, but then instead of ITmfTrace[], it
         * would be preferable to have experiment
         * </pre>
         */
        for (ITmfTrace trace : fTraces) {
            EventMatchingBuildRequest request = new EventMatchingBuildRequest(this, trace);

            /*
             * Send the request to the trace here, since there is probably no
             * experiment.
             */
            trace.sendRequest(request);
            try {
                request.waitForCompletion();
            } catch (InterruptedException e) {
                Activator.logInfo(e.getMessage());
            }
        }

        finalizeMatching();

        return true;
    }

