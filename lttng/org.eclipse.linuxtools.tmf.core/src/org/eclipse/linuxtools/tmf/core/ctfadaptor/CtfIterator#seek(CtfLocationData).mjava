    /**
     * Seek this iterator to a given location.
     *
     * @param ctfLocationData
     *            The LocationData representing the position to seek to
     * @return boolean
     * @since 2.0
     */
    public boolean seek(final CtfLocationData ctfLocationData) {
        boolean ret = false;

        /* Adjust the timestamp depending on the trace's offset */
        long currTimestamp = ctfLocationData.getTimestamp();
        final long offsetTimestamp = currTimestamp - this.getTrace().getOffset();
        if (offsetTimestamp < 0) {
            ret = super.seek(0L);
        } else {
            ret = super.seek(offsetTimestamp);
        }

        /*
         * Check if there is already one or more events for that timestamp, and
         * assign the location index correctly
         */
        currTimestamp = this.getCurrentEvent().getTimestampValue();
        long index = 0;
        for (long i = 0; i < ctfLocationData.getIndex(); i++) {
            if (currTimestamp == this.getCurrentEvent().getTimestampValue()) {
                index++;
            } else {
                index = 0;
            }
            this.advance();
        }

        /* Seek the current location accordingly */
        if (ret) {
            curLocation.setLocation(new CtfLocationData(getCurrentEvent().getTimestampValue(), index));
        } else {
            curLocation = NULL_LOCATION;
        }
        return ret;
    }

