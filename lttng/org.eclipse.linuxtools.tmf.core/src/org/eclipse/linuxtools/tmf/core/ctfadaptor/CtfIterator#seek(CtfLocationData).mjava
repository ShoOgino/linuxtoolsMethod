    /**
     * Seek this iterator to a given location.
     *
     * @param ctfLocationData
     *            The LocationData representing the position to seek to
     * @return boolean
     * @since 2.0
     */
    public boolean seek(final CtfLocationData ctfLocationData) {
        boolean ret = false;

        /* Adjust the timestamp depending on the trace's offset */
        long currTimestamp = ctfLocationData.getTimestamp();
        final long offsetTimestamp = this.getCtfTmfTrace().getCTFTrace().timestampNanoToCycles(currTimestamp);
        if (offsetTimestamp < 0) {
            ret = super.seek(0L);
        } else {
            ret = super.seek(offsetTimestamp);
        }

        /*
         * Check if there is already one or more events for that timestamp, and
         * assign the location index correctly
         */
        long index = 0;
        if (this.getCurrentEvent() != null) {
            currTimestamp = this.getCurrentEvent().getTimestamp().getValue();

            for (long i = 0; i < ctfLocationData.getIndex(); i++) {
                if (currTimestamp == this.getCurrentEvent().getTimestamp().getValue()) {
                    index++;
                } else {
                    index = 0;
                }
                this.advance();
            }
        } else {
            ret= false;
        }
        /* Seek the current location accordingly */
        if (ret) {
            curLocation = new CtfLocation(new CtfLocationData(getCurrentEvent().getTimestamp().getValue(), index));
        } else {
            curLocation = NULL_LOCATION;
        }
        return ret;
    }

