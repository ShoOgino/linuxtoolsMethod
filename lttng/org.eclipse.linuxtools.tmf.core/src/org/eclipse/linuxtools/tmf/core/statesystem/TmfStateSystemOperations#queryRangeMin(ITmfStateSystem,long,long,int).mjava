    /**
     * Return the minimum value of an attribute over a time range
     *
     * @param ss
     *            The state system to query
     * @param t1
     *            The start time of the range
     * @param t2
     *            The end time of the range
     * @param quark
     *            The quark of the attribute
     * @return The minimum value of the attribute in this range
     * @throws TimeRangeException
     *             If an invalid time range is specified
     * @throws AttributeNotFoundException
     *             If the specified quark doesn't match an attribute
     * @throws StateValueTypeException
     *             If the state value type of the attribute does not support the
     *             "Min" operation
     */
    public static ITmfStateValue queryRangeMin(ITmfStateSystem ss,
            long t1, long t2, int quark)
            throws AttributeNotFoundException, TimeRangeException, StateValueTypeException {
        ITmfStateValue min = TmfStateValue.nullValue();

        List<ITmfStateInterval> intervals = queryAttributeRange(ss, t1, t2, quark, AbstractTmfMipmapStateProvider.MIN_STRING);
        if (intervals.size() == 0) {
            return TmfStateValue.nullValue();
        }
        for (ITmfStateInterval si : intervals) {
            ITmfStateValue value = si.getStateValue();

            switch (value.getType()) {
            case DOUBLE:
                if (min.isNull() || si.getStateValue().unboxDouble() < min.unboxDouble()) {
                    min = si.getStateValue();
                }
                break;

            case INTEGER:
            case LONG:
                if (min.isNull() || si.getStateValue().unboxLong() < min.unboxLong()) {
                    min = si.getStateValue();
                }
                break;

            case NULL:
            case STRING:
            default:
                throw new StateValueTypeException();
            }
        }
        return min;
    }

