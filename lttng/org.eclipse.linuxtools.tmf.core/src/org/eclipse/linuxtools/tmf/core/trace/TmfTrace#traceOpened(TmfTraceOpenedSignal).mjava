    /**
     * Handler for the Trace Opened signal
     *
     * @param signal
     *            The incoming signal
     * @since 2.0
     */
    @TmfSignalHandler
    public void traceOpened(TmfTraceOpenedSignal signal) {
        ITmfTrace trace = null;
        /* The signal's trace should already be the active one in the manager */
        TmfTraceManager tm = TmfTraceManager.getInstance();
        for (ITmfTrace expTrace : tm.getActiveTraceSet()) {
            if (expTrace == this) {
                trace = expTrace;
                break;
            }
        }

        if (trace == null) {
            /* This signal is not for us */
            return;
        }

        /*
         * The signal is for this trace, or for an experiment containing
         * this trace.
         */
        try {
            buildStatistics();
            buildStateSystem();
        } catch (TmfTraceException e) {
            e.printStackTrace();
        }

        /* Refresh the project, so it can pick up new files that got created. */
        try {
            if (fResource != null) {
                fResource.getProject().refreshLocal(IResource.DEPTH_INFINITE, null);
            }
        } catch (CoreException e) {
            e.printStackTrace();
        }

        if (signal.getTrace() == this) {
            /* Additionally, the signal is directly for this trace or experiment. */
            if (getNbEvents() == 0) {
                return;
            }

            final TmfTimeRange timeRange = new TmfTimeRange(getStartTime(), TmfTimestamp.BIG_CRUNCH);
            final TmfTraceRangeUpdatedSignal rangeUpdatedsignal = new TmfTraceRangeUpdatedSignal(this, this, timeRange);

            // Broadcast in separate thread to prevent deadlock
            new Thread() {
                @Override
                public void run() {
                    broadcast(rangeUpdatedsignal);
                }
            }.start();
            return;
        }
    }

