    @Override
    public long getEventsInRange(ITmfTimestamp start, ITmfTimestamp end) {
        // FIXME Instead of waiting until the end, we could check the current
        // end time, and answer as soon as possible...
        stats.waitUntilBuilt();

        int countAtStart = 0, countAtEnd = 0;
        long startTime = checkStartTime(start);
        long endTime = checkEndTime(end);

        try {
            final int quark = stats.getQuarkAbsolute(Attributes.TOTAL);
            if (startTime == stats.getStartTime()) {
                countAtStart = 0;
            } else {
                /* State system works that way... */
                countAtStart = stats.querySingleState(startTime - 1, quark).getStateValue().unboxInt();
            }
            countAtEnd = stats.querySingleState(endTime, quark).getStateValue().unboxInt();

        } catch (TimeRangeException e) {
            /* Assume there is no events for that range */
            return 0;
        } catch (AttributeNotFoundException e) {
            e.printStackTrace();
        } catch (StateValueTypeException e) {
            e.printStackTrace();
        } catch (StateSystemDisposedException e) {
            e.printStackTrace();
        }

        long total = countAtEnd - countAtStart;
        return total;
    }

