    /**
     * Parse a string according to the format pattern
     *
     * @param source the source string
     * @param ref the reference (base) time (in ns)
     * @return the parsed value (in ns)
     * @throws ParseException if the string has an invalid format
     */
    public synchronized long parseValue(final String source, final long ref) throws ParseException {

        // Trivial case
        if (source == null || source.length() == 0) {
            return 0;
        }

        long seconds  = 0;
        boolean isNegative = source.charAt(0) == '-';
        boolean isDateTimeFormat = true;

        int index = indexOfSourceDecimalSeparator(source);

        // Check for seconds in epoch pattern
        for (String pattern : fSupplPatterns) {
            if (pattern.charAt(0) == 'T') {
                isDateTimeFormat = false;
                // Remove everything up to the first "." and compute the
                // number of seconds since the epoch. If there is no period,
                // assume an integer value and return immediately
                if (index == 0 || (isNegative && index <= 1)) {
                    seconds = 0;
                } else if (index == source.length()) {
                    return new DecimalFormat("0").parse(source).longValue() * 1000000000; //$NON-NLS-1$
                } else {
                    seconds = new DecimalFormat("0").parse(source.substring(0, index)).longValue(); //$NON-NLS-1$
                }
                break;
            }
        }

        // If there was no "T" (thus not an interval), parse as a date
        if (isDateTimeFormat && super.toPattern().length() > 0) {
            Date baseDate = super.parse(source.substring(0, index));
            getCalendar();

            if (ref != Long.MIN_VALUE) {
                Calendar baseTime = Calendar.getInstance(getTimeZone(), fLocale);
                baseTime.setTimeInMillis(baseDate.getTime());
                Calendar newTime = Calendar.getInstance(getTimeZone(), fLocale);
                newTime.setTimeInMillis(ref / 1000000);
                boolean setRemainingFields = false;
                if (dateTimePatternContains("yY")) { //$NON-NLS-1$
                    newTime.set(Calendar.YEAR, baseTime.get(Calendar.YEAR));
                    setRemainingFields = true;
                }
                if (setRemainingFields || dateTimePatternContains("M")) { //$NON-NLS-1$
                    newTime.set(Calendar.MONTH, baseTime.get(Calendar.MONTH));
                    setRemainingFields = true;
                }
                if (setRemainingFields || dateTimePatternContains("d")) { //$NON-NLS-1$
                    newTime.set(Calendar.DATE, baseTime.get(Calendar.DATE));
                    setRemainingFields = true;
                } else if (dateTimePatternContains("D")) { //$NON-NLS-1$
                    newTime.set(Calendar.DAY_OF_YEAR, baseTime.get(Calendar.DAY_OF_YEAR));
                    setRemainingFields = true;
                } else if (dateTimePatternContains("w")) { //$NON-NLS-1$
                    newTime.set(Calendar.WEEK_OF_YEAR, baseTime.get(Calendar.WEEK_OF_YEAR));
                    setRemainingFields = true;
                }
                if (dateTimePatternContains("F")) { //$NON-NLS-1$
                    newTime.set(Calendar.DAY_OF_WEEK_IN_MONTH, baseTime.get(Calendar.DAY_OF_WEEK_IN_MONTH));
                    setRemainingFields = true;
                }
                if (dateTimePatternContains("Eu")) { //$NON-NLS-1$
                    newTime.set(Calendar.DAY_OF_WEEK, baseTime.get(Calendar.DAY_OF_WEEK));
                    setRemainingFields = true;
                }
                if (setRemainingFields || dateTimePatternContains("aHkKh")) { //$NON-NLS-1$
                    newTime.set(Calendar.HOUR_OF_DAY, baseTime.get(Calendar.HOUR_OF_DAY));
                    setRemainingFields = true;
                }
                if (setRemainingFields || dateTimePatternContains("m")) { //$NON-NLS-1$
                    newTime.set(Calendar.MINUTE, baseTime.get(Calendar.MINUTE));
                    setRemainingFields = true;
                }
                if (setRemainingFields || dateTimePatternContains("s")) { //$NON-NLS-1$
                    newTime.set(Calendar.SECOND, baseTime.get(Calendar.SECOND));
                }
                newTime.set(Calendar.MILLISECOND, 0);
                seconds = newTime.getTimeInMillis() / 1000;
            } else {
                seconds = baseDate.getTime() / 1000;
            }
        } else if (isDateTimeFormat && ref != Long.MIN_VALUE) {
            // If the date and time pattern is empty, adjust for reference
            seconds = ref / 1000000000;
        }

        long nanos = parseSubSeconds(source.substring(index));
        if (isNegative && !isDateTimeFormat) {
            nanos = -nanos;
        }
        // Compute the value in ns
        return seconds * 1000000000 + nanos;
    }

