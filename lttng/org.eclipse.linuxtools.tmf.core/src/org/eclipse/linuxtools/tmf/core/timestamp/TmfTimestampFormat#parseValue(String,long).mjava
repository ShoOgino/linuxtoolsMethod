    /**
     * Parse a string according to the format pattern
     *
     * @param string the source string
     * @param ref the reference (base) time (in ns)
     * @return the parsed value (in ns)
     * @throws ParseException if the string has an invalid format
     */
    public synchronized long parseValue(final String string, final long ref) throws ParseException {

        // Trivial case
        if (string == null || string.length() == 0) {
            return 0;
        }

        // The timestamp sub-components
        long seconds  = -1;
        long millisec =  0;
        long microsec =  0;
        long nanosec  =  0;

        int dot = string.indexOf('.');
        if (dot == -1) {
            dot = string.length();
        }

        // Fill in our extensions
        for (String pattern : fSupplPatterns) {
            Matcher matcher;

            // Extract the substring corresponding to the extra pattern letters
            switch (pattern.charAt(0)) {
                case 'T':
                    // Remove everything up to the first "." and  compute the
                    // number of seconds since the epoch. If there is no period,
                    // assume an integer value and return immediately
                    if (dot < 0) {
                        return new DecimalFormat("0").parse(string).longValue() * 1000000000; //$NON-NLS-1$
                    } else if (dot == 0) {
                        seconds = 0;
                    } else {
                        seconds = new DecimalFormat("0").parse(string.substring(0, dot)).longValue(); //$NON-NLS-1$
                    }
                    break;
                case 'S':
                    matcher = MILLISEC_PAT.matcher(string.substring(dot));
                    if (matcher.find()) {
                        millisec = new Long(matcher.group(1));
                        for (int l = matcher.group(1).length(); l < 3; l++) {
                            millisec *= 10;
                        }
                    }
                    break;
                case 'C':
                    matcher = MICROSEC_PAT.matcher(string.substring(dot));
                    if (matcher.find()) {
                        microsec = new Long(matcher.group(2));
                        for (int l = matcher.group(2).length(); l < 3; l++) {
                            microsec *= 10;
                        }
                    }
                    break;
                case 'N':
                    matcher = NANOSEC_PAT.matcher(string.substring(dot));
                    if (matcher.find()) {
                        nanosec = new Long(matcher.group(3));
                        for (int l = matcher.group(3).length(); l < 3; l++) {
                            nanosec *= 10;
                        }
                    }
                    break;
                default:
                    break;
            }
        }

        // If there was no "T" (thus not an interval), parse as a date
        if (seconds == -1) {
            Date baseDate = super.parse(string.substring(0, dot));

            Calendar refTime = Calendar.getInstance(getTimeZone());
            refTime.setTimeInMillis(ref / 1000000);
            Calendar newTime = Calendar.getInstance(getTimeZone());
            newTime.setTimeInMillis(baseDate.getTime());

            int[] fields = new int[] { Calendar.YEAR, Calendar.MONTH, Calendar.DATE, Calendar.HOUR_OF_DAY, Calendar.MINUTE, Calendar.SECOND };
            for (int field : fields) {
                int value = newTime.get(field);
                // Do some adjustments...
                if (field == Calendar.YEAR) {
                    value -= 1970;
                } else if (field == Calendar.DATE) {
                    value -= 1;
                }
                // ... and fill-in the empty fields
                if (value == 0) {
                    newTime.set(field, refTime.get(field));
                } else {
                    break; // Get out as soon as we have a significant value
                }
            }
            seconds = newTime.getTimeInMillis() / 1000;
        }

        // Compute the value in ns
        return seconds * 1000000000 +  millisec * 1000000 +  microsec * 1000 +  nanosec;
    }

