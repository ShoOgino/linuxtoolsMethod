    @Override
    public Map<String, Long> getEventTypesInRange(ITmfTimestamp start, ITmfTimestamp end) {
        Map<String, Long> map = new HashMap<String, Long>();

        /* Make sure the start/end times are within the state history, so we
         * don't get TimeRange exceptions.
         */
        long startTimestamp = checkStartTime(start.getValue());
        long endTimestamp = checkEndTime(end.getValue());

        try {
            /* Get the list of quarks, one for each even type in the database */
            int quark = stats.getQuarkAbsolute(Attributes.EVENT_TYPES);
            List<Integer> quarks = stats.getSubAttributes(quark, false);

            /*
             * Get the complete states (in our case, event counts) at the start
             * time and end time of the requested time range.
             */
            List<ITmfStateInterval> startState = stats.queryFullState(startTimestamp);
            List<ITmfStateInterval> endState = stats.queryFullState(endTimestamp);

            /* Save the relevant information in the map we will be returning */
            String curEventName;
            long countAtStart, countAtEnd, eventCount;
            for (int typeQuark : quarks) {
                curEventName = stats.getAttributeName(typeQuark);
                countAtStart = startState.get(typeQuark).getStateValue().unboxInt();
                countAtEnd = endState.get(typeQuark).getStateValue().unboxInt();

                /*
                 * The default value for the statistics is 0, rather than the
                 * value -1 used by the state system for non-initialized state.
                 */
                if (startTimestamp == stats.getStartTime() || countAtStart == -1) {
                    countAtStart = 0;
                }

                /*
                 * Workaround a bug in the state system where requests for the
                 * very last state change will give -1. Send the request 1ns
                 * before the end of the trace and add the last event to the
                 * count.
                 */
                if (countAtEnd < 0) {
                    ITmfStateInterval realInterval = stats.querySingleState(endTimestamp - 1, typeQuark);
                    countAtEnd = realInterval.getStateValue().unboxInt() + 1;
                }

                /*
                 * If after this it is still at -1, it's because no event of
                 * this type happened during the requested time range.
                 */
                if (countAtEnd < 0) {
                    countAtEnd = 0;
                }

                eventCount = countAtEnd - countAtStart;
                map.put(curEventName, eventCount);
            }
        } catch (TimeRangeException e) {
            /*
             * If a request is made for an invalid time range, we will ignore it
             * silently and not add any information to the map.
             */
        } catch (AttributeNotFoundException e) {
            /*
             * These other exceptions would show a logic problem however, so
             * they should not happen.
             */
            e.printStackTrace();
        } catch (StateValueTypeException e) {
            e.printStackTrace();
        }
        return map;
    }

