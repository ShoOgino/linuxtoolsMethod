    /**
     * Reader constructor. Builds the interval using an already-allocated
     * ByteBuffer, which normally comes from a NIO FileChannel.
     *
     * @param buffer
     *            The ByteBuffer from which to read the information
     * @throws IOException
     */
    final static HTInterval readFrom(ByteBuffer buffer) throws IOException {
        HTInterval interval;
        long intervalStart, intervalEnd;
        int attribute;
        TmfStateValue value;
        int valueOrOffset, valueSize, res;
        byte valueType;
        byte array[];

        /* Read the Data Section entry */
        intervalStart = buffer.getLong();
        intervalEnd = buffer.getLong();
        attribute = buffer.getInt();

        /* Read the 'type' of the value, then react accordingly */
        valueType = buffer.get();
        valueOrOffset = buffer.getInt();
        switch (valueType) {

        case TYPE_NULL:
            value = TmfStateValue.nullValue();
            valueSize = NO_ENTRY_SIZE;
            break;

        case TYPE_INTEGER:
            /* "ValueOrOffset" is the straight value */
            value = TmfStateValue.newValueInt(valueOrOffset);
            valueSize = NO_ENTRY_SIZE;
            break;

        case TYPE_STRING:
            /* Go read the matching entry in the Strings section of the block */
            buffer.mark();
            buffer.position(valueOrOffset);

            /* the first byte = the size to read */
            valueSize = buffer.get();

            /*
             * Careful though, 'valueSize' is the total size of the entry,
             * including the 'size' byte at the start and end (0'ed) byte at the
             * end. Here we want 'array' to only contain the real payload of the
             * value.
             */
            array = new byte[valueSize - 2];
            buffer.get(array);
            value = TmfStateValue.newValueString(new String(array));

            /* Confirm the 0'ed byte at the end */
            res = buffer.get();
            if (res != 0) {
                throw new IOException(errMsg);
            }

            /*
             * Restore the file pointer's position (so we can read the next
             * interval)
             */
            buffer.reset();
            break;

        case TYPE_LONG:
            /* Go read the matching entry in the Strings section of the block */
            buffer.mark();
            buffer.position(valueOrOffset);
            value = TmfStateValue.newValueLong(buffer.getLong());
            valueSize = LONG_ENTRY_SIZE;

            /*
             * Restore the file pointer's position (so we can read the next
             * interval)
             */
            buffer.reset();
            break;
        default:
            /* Unknown data, better to not make anything up... */
            throw new IOException(errMsg);
        }

        try {
            interval = new HTInterval(intervalStart, intervalEnd, attribute, value, valueSize);
        } catch (TimeRangeException e) {
            throw new IOException(errMsg);
        }
        return interval;
    }

