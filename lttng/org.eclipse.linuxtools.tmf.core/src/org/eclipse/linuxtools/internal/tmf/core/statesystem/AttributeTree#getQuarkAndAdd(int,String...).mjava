    // FIXME synchronized here is probably quite costly... maybe only locking
    // the "for" would be enough?
    synchronized int getQuarkAndAdd(int startingNodeQuark, String... subPath) {
        assert (subPath != null && subPath.length > 0);
        assert (startingNodeQuark >= -1);

        Attribute nextNode = null;
        Attribute prevNode;

        /* Get the "starting node" */
        if (startingNodeQuark == -1) {
            prevNode = attributeTreeRoot;
        } else {
            prevNode = attributeList.get(startingNodeQuark);
        }

        int knownQuark = prevNode.getSubAttributeQuark(subPath);
        if (knownQuark == -1) {
            /*
             * The attribute was not in the table previously, and we want to add
             * it
             */
            for (String curDirectory : subPath) {
                nextNode = prevNode.getSubAttributeNode(curDirectory);
                if (nextNode == null) {
                    /* This is where we need to start adding */
                    nextNode = new AlphaNumAttribute(prevNode, curDirectory,
                            attributeList.size());
                    prevNode.addSubAttribute(nextNode);
                    attributeList.add(nextNode);
                    ss.addEmptyAttribute();
                }
                prevNode = nextNode;
            }
            /*
             * Insert an initial null value for this attribute in the state
             * system (in case the state provider doesn't set one).
             */
            final int newAttrib = attributeList.size() - 1;
            try {
                ss.modifyAttribute(ss.getStartTime(), TmfStateValue.nullValue(), newAttrib);
            } catch (TimeRangeException e) {
                /* Should not happen, we're inserting at ss's start time */
                throw new RuntimeException();
            } catch (AttributeNotFoundException e) {
                /* Should not happen, we just created this attribute! */
                throw new RuntimeException();
            } catch (StateValueTypeException e) {
                /* Should not happen, there is no existing state value, and the
                 * one we insert is a null value anyway. */
                throw new RuntimeException();
            }

            return newAttrib;
        }
        /*
         * The attribute was already existing, return the quark of that
         * attribute
         */
        return knownQuark;
    }

