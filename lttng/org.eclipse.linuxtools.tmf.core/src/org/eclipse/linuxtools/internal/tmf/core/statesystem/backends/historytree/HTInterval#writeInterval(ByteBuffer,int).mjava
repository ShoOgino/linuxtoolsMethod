    /**
     * Antagonist of the previous constructor, write the Data entry
     * corresponding to this interval in a ByteBuffer (mapped to a block in the
     * history-file, hopefully)
     *
     * @param buffer
     *            The already-allocated ByteBuffer corresponding to a SHT Node
     * @param endPosOfStringEntry
     *            The initial (before calling this function for this interval)
     *            position of the Strings Entry for this node. This will change
     *            from one call to the other if we're writing String
     *            StateValues.
     * @return The size of the Strings Entry that was written, if any.
     */
    int writeInterval(ByteBuffer buffer, int endPosOfStringEntry) {
        buffer.putLong(start);
        buffer.putLong(end);
        buffer.putInt(attribute);
        buffer.put(getByteFromType(sv.getType()));

        switch (getByteFromType(sv.getType())) {

        case TYPE_NULL:
        case TYPE_INTEGER:
            /* We write the 'valueOffset' field as a straight value. */
            try {
                buffer.putInt(sv.unboxInt());
            } catch (StateValueTypeException e) {
                /*
                 * This should not happen, since the value told us it was of
                 * type Null or Integer (corrupted value?)
                 */
                e.printStackTrace();
            }
            break;

        case TYPE_STRING:
            byte[] byteArrayToWrite;
            try {
                byteArrayToWrite = sv.unboxStr().getBytes();
            } catch (StateValueTypeException e1) {
                /* Should not happen, we're in a switch/case for string type */
                throw new RuntimeException();
            }

            /* we use the valueOffset as an offset. */
            buffer.putInt(endPosOfStringEntry - stringsEntrySize);
            buffer.mark();
            buffer.position(endPosOfStringEntry - stringsEntrySize);

            /*
             * write the Strings entry (1st byte = size, then the bytes, then the 0)
             */
            buffer.put((byte) stringsEntrySize);
            buffer.put(byteArrayToWrite);
            buffer.put((byte) 0);
            assert (buffer.position() == endPosOfStringEntry);
            buffer.reset();
            break;

        case TYPE_LONG:
            /* we use the valueOffset as an offset. */
            buffer.putInt(endPosOfStringEntry - stringsEntrySize);
            buffer.mark();
            buffer.position(endPosOfStringEntry - stringsEntrySize);

            /*
             * write the Long in the Strings section
             */
            try {
                buffer.putLong(sv.unboxLong());
            } catch (StateValueTypeException e) {
                /*
                 * This should not happen, since the value told us it was of
                 * type Long (corrupted value?)
                 */
                e.printStackTrace();
            }
            assert (buffer.position() == endPosOfStringEntry);
            buffer.reset();
            break;

        case TYPE_DOUBLE:
            /* we use the valueOffset as an offset. */
            buffer.putInt(endPosOfStringEntry - stringsEntrySize);
            buffer.mark();
            buffer.position(endPosOfStringEntry - stringsEntrySize);

            /* Write the Double in the Strings section */
            try {
                buffer.putDouble(sv.unboxDouble());
            } catch (StateValueTypeException e) {
                /*
                 * This should not happen, since the value told us it was of
                 * type Double (corrupted value?)
                 */
                e.printStackTrace();
            }
            if (buffer.position() != endPosOfStringEntry) {
                throw new IllegalStateException();
            }
            buffer.reset();
            break;

        default:
            break;
        }
        return stringsEntrySize;
    }

