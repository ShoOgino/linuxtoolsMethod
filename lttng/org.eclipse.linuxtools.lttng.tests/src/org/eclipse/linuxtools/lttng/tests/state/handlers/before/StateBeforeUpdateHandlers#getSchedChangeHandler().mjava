	/**
	 * <p>
	 * Handles: LTT_EVENT_SCHED_SCHEDULE
	 * </p>
	 * <p>
	 * Fields: LTT_FIELD_PREV_PID, LTT_FIELD_NEXT_PID, LTT_FIELD_PREV_STATE
	 * </p>
	 * 
	 * @return
	 */
	final IEventProcessing getSchedChangeHandler() {
		AbsStateUpdate handler = new AbsStateUpdate() {

			private Events eventType = Events.LTT_EVENT_SCHED_SCHEDULE;

			// @Override
			public boolean process(LttngEvent trcEvent, LttngTraceState traceSt) {
				//
				// Long cpu = trcEvent.getCpuId();
				// TmfTimestamp eventTime = trcEvent.getTimestamp();
				//
				// LttngProcessState process = traceSt.getRunning_process().get(
				// cpu);
				//
				// Long pid_out = getAFieldLong(trcEvent, traceSt,
				// Fields.LTT_FIELD_PREV_PID);
				// Long pid_in = getAFieldLong(trcEvent, traceSt,
				// Fields.LTT_FIELD_NEXT_PID);
				// Long state_out = getAFieldLong(trcEvent, traceSt,
				// Fields.LTT_FIELD_PREV_STATE);
				//
				// if (process != null) {
				//
				// /*
				// * We could not know but it was not the idle process
				// * executing. This should only happen at the beginning,
				// * before the first schedule event, and when the initial
				// * information (current process for each CPU) is missing. It
				// * is not obvious how we could, after the fact, compensate
				// * the wrongly attributed statistics.
				// */
				//
				// // This test only makes sense once the state is known and if
				// // there
				// // is no
				// // missing events. We need to silently ignore schedchange
				// // coming
				// // after a
				// // process_free, or it causes glitches. (FIXME)
				// // if(unlikely(process->pid != pid_out)) {
				// // g_assert(process->pid == 0);
				// // }
				// if (process.getPid() == 0
				// && process.getState().getExec_mode() ==
				// ExecutionMode.LTTV_STATE_MODE_UNKNOWN) {
				// if (pid_out == 0) {
				// /*
				// * Scheduling out of pid 0 at beginning of the trace
				// * : we know for sure it is in syscall mode at this
				// * point.
				// */
				// int stackSize = process.getExecution_stack().size();
				// if (stackSize != 1) {
				// TraceDebug
				// .debug("unpexpected process execution stack size, expected 1, received: ");
				// }
				//
				// process.getState().setExec_mode(
				// ExecutionMode.LTTV_STATE_SYSCALL);
				// process.getState().setProc_status(
				// ProcessStatus.LTTV_STATE_WAIT);
				// process.getState().setChage_Time(
				// trcEvent.getTimestamp());
				// process.getState().setEntry_Time(
				// trcEvent.getTimestamp());
				// }
				// } else {
				// if (process.getState().getProc_status() ==
				// ProcessStatus.LTTV_STATE_EXIT) {
				// process.getState().setProc_status(
				// ProcessStatus.LTTV_STATE_ZOMBIE);
				// process.getState().setChage_Time(
				// trcEvent.getTimestamp());
				// } else {
				// if (state_out == 0L) {
				// process.getState().setProc_status(
				// ProcessStatus.LTTV_STATE_WAIT_CPU);
				// } else {
				// process.getState().setProc_status(
				// ProcessStatus.LTTV_STATE_WAIT);
				// }
				//
				// process.getState().setChage_Time(
				// trcEvent.getTimestamp());
				// }
				//
				// if (state_out == 32L || state_out == 64L) { /*
				// * EXIT_DEAD
				// * ||
				// * TASK_DEAD
				// */
				// /* see sched.h for states */
				// if (!exit_process(traceSt, process)) {
				// process.getState().setProc_status(
				// ProcessStatus.LTTV_STATE_DEAD);
				// process.getState().setChage_Time(
				// trcEvent.getTimestamp());
				// }
				// }
				// }
				// }
				// process = lttv_state_find_process_or_create(traceSt, cpu,
				// pid_in, eventTime);
				//
				// traceSt.getRunning_process().put(cpu, process);
				//
				// process.getState().setProc_status(ProcessStatus.LTTV_STATE_RUN);
				// process.getState().setChage_Time(eventTime);
				// process.setCpu(cpu);
				// // process->state->s = LTTV_STATE_RUN;
				// // if(process->usertrace)
				// // process->usertrace->cpu = cpu;
				// // process->last_cpu_index =
				// // ltt_tracefile_num(((LttvTracefileContext*)s)->tf);
				//
				// // process->state->change = s->parent.timestamp;
				//
				// LTTngCPUState cpu_state = traceSt.getCpu_states().get(cpu);
				// /* update cpu status */
				// if (pid_in == 0) {
				//
				// /* going to idle task */
				// cpu_set_base_mode(cpu_state, CpuMode.LTTV_CPU_IDLE);
				// } else {
				// /*
				// * scheduling a real task. we must be careful here: if we
				// * just schedule()'ed to a process that is in a trap, we
				// * must put the cpu in trap mode
				// */
				// cpu_set_base_mode(cpu_state, CpuMode.LTTV_CPU_BUSY);
				// if (process.getState().getExec_mode() ==
				// ExecutionMode.LTTV_STATE_TRAP) {
				// cpu_push_mode(cpu_state, CpuMode.LTTV_CPU_TRAP);
				// }
				// }
				return false;

			}

			// @Override
			public Events getEventHandleType() {
				return eventType;
			}
		};
		return handler;
	}

