	/**
	 * @param <T>
	 * @param k
	 * @param startIdx
	 *            , > 0 and between 0 - 31
	 * @param endIdx
	 *            , > startIdx and between 0 - 31
	 * @param printFirst20
	 *            , print the first expected events vs actual events
	 * @return
	 */
	protected <T extends LttngEvent> TmfEventRequest<T> prepareEventRequest(
			Class<T> k, final int startIdx, int endIdx, final boolean printFirst20) {
		// verify bounds
		if (!(endIdx > startIdx && startIdx >= 0 && endIdx <= 31)) {
			TraceDebug.debug("Event request indexes out of bounds");
			return null;
		}

		int DEFAULT_CHUNK = 1;
	
		// time range
		TmfTimeRange trange = new TmfTimeRange(new LttngTimestamp(
				requestIntervals_T1[startIdx]), new LttngTimestamp(
				requestIntervals_T1[endIdx]));
	
		// request
		validSequence = true;
		TmfEventRequest<T> request = new TmfEventRequest<T>(k, trange, TmfDataRequest.ALL_DATA, DEFAULT_CHUNK) {
	
			@Override
			public void handleData(T event) {
				if (event == null) {
					System.out
							.println("Syntheric Event Received is null, after event: "
									+ feventCount);
					return;
				}
	
				// Listen to only one variant of synthetic event to keep
				// track of
				if (event instanceof LttngSyntheticEvent) {
					if (((LttngSyntheticEvent) event).getSynType() != SequenceInd.BEFORE) {
						return;
					}
				}
	
				// Validating the orders of the first 20 events
				if (printFirst20 && feventCount < 20) {
					long timevalue = event.getTimestamp().getValue();
					if (timevalue != expectedEvents_T1[feventCount]) {
						validSequence = false;
						System.out.println("Expected Event: "
								+ expectedEvents_T1[feventCount] + " actual: "
								+ event.getTimestamp().getValue());
					} else {
						System.out.println("Synthetic Event: " + feventCount
								+ " matched expected time");
					}
				}
	
				// increment count
				incrementCount();
			}

			/**
			 * possibly increased by multiple request threads
			 */
			private synchronized void incrementCount() {
				feventCount++;
			}

			@Override
			public void handleCompleted() {
				// if (isCancelled() || isFailed()) {
				// // No notification to end request handlers
				// } else {
				// // notify the associated end request handlers
				// requestCompleted();
				// }
	
				System.out.println("handleCompleted(request:" + startIdx + ") Number of events processed: " + feventCount);
			}
	
		};
		return request;
	}

