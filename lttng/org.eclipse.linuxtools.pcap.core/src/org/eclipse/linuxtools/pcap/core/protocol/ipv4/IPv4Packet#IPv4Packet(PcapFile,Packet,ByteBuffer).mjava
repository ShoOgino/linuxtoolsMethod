    /**
     * Constructor of the IPv4 Packet class.
     *
     * @param file
     *            The file that contains this packet.
     * @param parent
     *            The parent packet of this packet (the encapsulating packet).
     * @param packet
     *            The entire packet (header and payload).
     * @throws BadPacketException
     *             Thrown when the packet is erroneous.
     */
    public IPv4Packet(PcapFile file, @Nullable Packet parent, ByteBuffer packet) throws BadPacketException {
        super(file, parent, Protocol.IPV4);

        // The endpoints are lazy loaded. They are defined in the get*Endpoint()
        // methods.
        fSourceEndpoint = null;
        fDestinationEndpoint = null;

        fFields = null;

        packet.order(ByteOrder.BIG_ENDIAN);
        packet.position(0);

        byte storage = packet.get();
        fVersion = ((storage & 0xF0) >> 4) & 0x000000FF;
        fInternetHeaderLength = storage & 0x0F;

        storage = packet.get();
        fDSCP = ((storage & 0b11111100) >> 2) & 0x000000FF;
        fExplicitCongestionNotification = storage & 0b00000011;

        fTotalLength = ConversionHelper.unsignedShortToInt(packet.getShort());
        fIdentification = ConversionHelper.unsignedShortToInt(packet.getShort());

        storage = packet.get();
        fReservedFlag = isBitSet(storage, 7);
        fDontFragmentFlag = isBitSet(storage, 6);
        fMoreFragmentFlag = isBitSet(storage, 5);
        int msb = ((storage & 0b00011111) << 8);
        int lsb = ConversionHelper.unsignedByteToInt(packet.get());
        fFragmentOffset = msb + lsb;

        fTimeToLive = ConversionHelper.unsignedByteToInt(packet.get());
        fIpDatagramProtocol = ConversionHelper.unsignedByteToInt(packet.get());
        fHeaderChecksum = ConversionHelper.unsignedShortToInt(packet.getShort());

        byte[] source = new byte[IPv4Values.IP_ADDRESS_SIZE];
        byte[] destination = new byte[IPv4Values.IP_ADDRESS_SIZE];
        packet.get(source);
        packet.get(destination);

        try {
            @SuppressWarnings("null")
            @NonNull Inet4Address sourceIP = (Inet4Address) InetAddress.getByAddress(source);
            @SuppressWarnings("null")
            @NonNull Inet4Address destinationIP = (Inet4Address) InetAddress.getByAddress(destination);
            fSourceIpAddress = sourceIP;
            fDestinationIpAddress = destinationIP;
        } catch (UnknownHostException e) {
            throw new BadPacketException("The IP Address size is not valid!"); //$NON-NLS-1$
        }

        // Get options if there are any
        if (fInternetHeaderLength > IPv4Values.DEFAULT_HEADER_LENGTH) {
            fOptions = new byte[(fInternetHeaderLength - IPv4Values.DEFAULT_HEADER_LENGTH) * IPv4Values.BLOCK_SIZE];
            packet.get(fOptions);
        } else {
            fOptions = null;
        }

        // Get payload if any.
        if (packet.array().length - packet.position() > 0) {
            byte[] array = new byte[packet.array().length - packet.position()];
            packet.get(array);
            ByteBuffer payload = ByteBuffer.wrap(array);
            payload.order(ByteOrder.BIG_ENDIAN);
            payload.position(0);
            fPayload = payload;
        } else {
            fPayload = null;
        }

        // Find child
        fChildPacket = findChildPacket();

    }

