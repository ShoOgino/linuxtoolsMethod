    /**
     * Add a packet to the stream.
     *
     * @param packet
     *            The packet that must be added.
     */
    synchronized void add(PcapPacket packet) {

        Packet newPacket = packet.getPacket(fProtocol);
        if (newPacket == null) {
            return;
        }

        // Update packet and byte number
        if (fEndpointPair.getFirstEndpoint().equals(newPacket.getSourceEndpoint()) &&
                fEndpointPair.getSecondEndpoint().equals(newPacket.getDestinationEndpoint())) {
            fNbPacketsAtoB++;
            fNbBytesAtoB += packet.getOriginalLength();
        } else if (fEndpointPair.getFirstEndpoint().equals(newPacket.getDestinationEndpoint()) &&
                fEndpointPair.getSecondEndpoint().equals(newPacket.getSourceEndpoint())) {
            fNbPacketsBtoA++;
            fNbBytesBtoA += packet.getOriginalLength();
        } else {
            throw new IllegalStateException();
        }

        // Update start and stop time
        // Stream timestamp is ALWAYS in nanoseconds.
        long timestamp;
        switch (packet.getTimestampScale()) {
        case MICROSECOND:
            timestamp = packet.getTimestamp() * 1000;
            break;
        case NANOSECOND:
            timestamp = packet.getTimestamp();
            break;
        default:
            throw new IllegalArgumentException("The timestamp precision is not valid!"); //$NON-NLS-1$
        }
        fStartTime = Math.min(fStartTime, timestamp);
        fEndTime = Math.max(fEndTime, timestamp);
    }

