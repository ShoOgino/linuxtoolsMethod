    /**
     * This method uses DSF-GDB to read the currently selected GDB tracepoint
     * data frame.   An object of type GdbTraceEvent is build based on the
     * information contained in the data frame and returned to the caller.
     * <p>
     * NOTE : A frame must be selected before calling this method!
     *
     * @param rank  for internal purposes - does <b>not</b> control which
     * frame will be read!
     * @return parsed tp frame, in the form of a GdbTraceEvent
     */
    private GdbTraceEvent getTraceFrameData(final long rank) {

        if (DsfSession.getSession(fSessionId) == null) {
            return null;
        }

        final DsfExecutor executor = DsfSession.getSession(fSessionId).getExecutor();
        final DsfServicesTracker tracker = new DsfServicesTracker(GdbTraceCorePlugin.getBundleContext(), fSessionId);

        Query<ITraceRecordDMData> getFrameDataQuery = new Query<ITraceRecordDMData>() {
            @Override
            public void execute(final DataRequestMonitor<ITraceRecordDMData> rm) {
                final IGDBTraceControl traceControl = tracker.getService(IGDBTraceControl.class);

                final ICommandControlService commandControl = tracker.getService(ICommandControlService.class);
                final ITraceTargetDMContext dmc = (ITraceTargetDMContext) commandControl.getContext();

                if (traceControl != null) {
                    traceControl.getCurrentTraceRecordContext(dmc,
                            new DataRequestMonitor<ITraceRecordDMContext>(executor, rm) {
                        @Override
                        protected void handleSuccess() {
                            traceControl.getTraceRecordData(getData(), rm);
                        }
                    });
                } else {
                    rm.done();
                }
            }
        };
        try {
            // Execute the above query
            executor.execute(getFrameDataQuery);
            ITraceRecordDMData data = getFrameDataQuery.get(); // blocking call

            if (data == null) {
                return null;
            }

            String ts = data.getTimestamp();
            if (ts == null) {
                ts = "0"; //$NON-NLS-1$
            }

            // get corresponding TP data
            String tmfEventRef;
            MIBreakpointDMData bp =  fTpInfo.get(Integer.valueOf(data.getTracepointNumber()));
            if (bp != null) {
                tmfEventRef = bp.getFileName() + ":" + bp.getLineNumber() + " :: " + bp.getFunctionName(); //$NON-NLS-1$ //$NON-NLS-2$
            }
            else {
                tmfEventRef = tracedExecutable;
            }

            GdbTraceEventContent evContent = new GdbTraceEventContent(
                    data.getContent(),
                    Integer.parseInt(data.getTracepointNumber()),
                    Integer.parseInt(data.getRecordId()));

            GdbTraceEvent ev = new GdbTraceEvent(fGdbTrace,
                    new TmfTimestamp(Integer.parseInt(data.getRecordId())),
                    "Tracepoint: " + data.getTracepointNumber() + ", Frame: " + data.getRecordId(),  //$NON-NLS-1$ //$NON-NLS-2$
                    tmfEventType,
                    evContent,
                    tmfEventRef);

            return ev;

        } catch (InterruptedException e) {
            return createExceptionEvent(rank, "Interruption exception"); //$NON-NLS-1$
        } catch (java.util.concurrent.ExecutionException e) {
            return createExceptionEvent(rank, "GDB exception"); //$NON-NLS-1$
        } catch (RejectedExecutionException e) {
            return createExceptionEvent(rank, "Request rejected exception"); //$NON-NLS-1$
        } catch (Exception e) {
            return createExceptionEvent(rank, "General exception"); //$NON-NLS-1$
        }

        finally {
            tracker.dispose();
        }
    }

