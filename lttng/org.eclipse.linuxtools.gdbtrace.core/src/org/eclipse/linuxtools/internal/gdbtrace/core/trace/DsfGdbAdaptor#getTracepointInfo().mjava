    /**
     * This class implements a best-effort look-up of the detailed tracepoint
     * information (source code filename, line number, etc...).
     */
    private void getTracepointInfo() {

        // Get the latest executor/service tracker
        final DsfExecutor executor = DsfSession.getSession(fSessionId).getExecutor();
        final DsfServicesTracker tracker = new DsfServicesTracker(GdbTraceCorePlugin.getBundleContext(), fSessionId);

        Query<Object> selectRecordQuery = new Query<Object>() {
            @Override
            public void execute(final DataRequestMonitor<Object> drm) {

                // A breakpoint is no longer GDB-global but tied to a specific process
                // So we need to find our process and the ask for its breakpoints
                IMIProcesses procService = tracker.getService(IMIProcesses.class);
                final ICommandControlService cmdControl = tracker.getService(ICommandControlService.class);
                if (procService == null || cmdControl == null) {
                    drm.setStatus(new Status(IStatus.ERROR, GdbPlugin.PLUGIN_ID, IDsfStatusConstants.INTERNAL_ERROR, "Could not find necessary services", null)); //$NON-NLS-1$
                    drm.done();
                    return;
                }

                ITraceTargetDMContext context = (ITraceTargetDMContext) cmdControl.getContext();
                ICommandControlDMContext cmdControlDMC = DMContexts.getAncestorOfType(context, ICommandControlDMContext.class);

                procService.getProcessesBeingDebugged(
                        cmdControlDMC,
                        new DataRequestMonitor<IDMContext[]>(executor, drm) {
                            @Override
                            protected void handleSuccess() {
                                assert getData() != null;
                                assert getData().length == 1;
                                if (getData() == null || getData().length < 1) {
                                    drm.done();
                                    return;
                                }

                                // Choose the first process for now, until gdb can tell
                                // us which process the trace record is associated with.
                                IContainerDMContext containerDMC = (IContainerDMContext)(getData()[0]);
                                IBreakpointsTargetDMContext bpTargetDMC = DMContexts.getAncestorOfType(containerDMC , IBreakpointsTargetDMContext.class);

                                CommandFactory cmdFactory = tracker.getService(IMICommandControl.class).getCommandFactory();
                                IBreakpoints bpService = tracker.getService(MIBreakpoints.class);
                                if (cmdFactory == null || bpService == null) {
                                    drm.setStatus(new Status(IStatus.ERROR, GdbPlugin.PLUGIN_ID, IDsfStatusConstants.INTERNAL_ERROR, "Could not find necessary services", null)); //$NON-NLS-1$
                                    drm.done();
                                    return;
                                }

                                // Execute the command
                                cmdControl.queueCommand(cmdFactory.createMIBreakList(bpTargetDMC),
                                        new DataRequestMonitor<MIBreakListInfo>(executor, drm) {
                                    @Override
                                    protected void handleSuccess() {
                                        MIBreakpoint[] breakpoints = getData().getMIBreakpoints();
                                        for (int i = 0; i < breakpoints.length; i++) {
                                            MIBreakpointDMData breakpoint = new MIBreakpointDMData(breakpoints[i]);
                                            String type = breakpoint.getBreakpointType();
                                            // Only save info if the current breakpoint is of type tracepoint
                                            if(type.compareTo(MIBreakpoints.TRACEPOINT) == 0 ) {
                                                fTpInfo.put(new Integer(breakpoint.getReference()), breakpoint);
                                            }
                                        }
                                        drm.done();
                                    }
                                });
                            }
                        });
            }
        };
        try {
            executor.execute(selectRecordQuery);
            selectRecordQuery.get(); // blocks
        } catch (RejectedExecutionException e) {

        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (ExecutionException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } finally {
            tracker.dispose();
        }
    }

