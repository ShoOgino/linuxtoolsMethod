		/* (non-Javadoc)
		 * @see org.eclipse.core.runtime.jobs.Job#run(org.eclipse.core.runtime.IProgressMonitor)
		 */
		@Override
		protected IStatus run(IProgressMonitor monitor) {

			Vector<TmfTraceContext[]> indices = new Vector<TmfTraceContext[]>();
			
			// Minimal check
			if (fTraces.size() == 0) {
	            fIndexing = false;
				return Status.OK_STATUS;
			}

			monitor.beginTask("Indexing " + fExperimentId, IProgressMonitor.UNKNOWN);

    		ITmfTrace[] traces = new ITmfTrace[0];
    		TmfTraceContext[] contexts;
    		TmfEvent[] events;
    		int nbTraces = fTraces.size();

    		// Initialize the traces and contexts arrays
    		traces = fTraces.toArray(traces);
    		contexts = new TmfTraceContext[nbTraces];
    		events = new TmfEvent[nbTraces];
    		TmfTraceContext[] savedContexts = new TmfTraceContext[nbTraces];
    		for (int i = 0; i < nbTraces; i++) {
    			// Context of the first event of the trace
    			contexts[i] = traces[i].seekLocation(null);
    			savedContexts[i] = new TmfTraceContext(contexts[i].getLocation(), null, 0);
    			// Set the peeked event
    			events[i] = traces[i].getNextEvent(new TmfTraceContext(contexts[i]));
    			// We don't know the event timestamp before we parse it, at which time
    			// the trace points to the beginning of the *next* event...
    			// So, once the event is read, we can retrofit the timestamp of the context 
    			savedContexts[i].setTimestamp((events[i] != null) ? events[i].getTimestamp() : null);
    		}
			indices.add(savedContexts);

    		// Get the ordered events and populate the indices
    		int nbEvents = 0;
    		while ((getNextEvent(traces, contexts, events)) != null)
    		{
//    			if (nbEvents % fIndexPageSize == 0) {
//	    			// Udpate the contexts timestamp
//    				// Special case: if the total number of events is a multiple of the
//    				// DEFAULT_PAGE_SIZE then all the pending events are null. In that
//    				// case, we don't store an additional entry in the index array.
//    				int nullTimestamps = 0;
//    	    		for (int i = 0; i < nbTraces; i++) {
//    	    			savedContexts[i].setTimestamp((events[i] != null) ? events[i].getTimestamp() : null);
//    	    			if (events[i] == null)
//    	    				nullTimestamps++;
//    	    		}
//    	    		if (nullTimestamps < nbTraces) {
//    	    			indices.add(savedContexts);
//    	    		}
//    			}
//
//                // Prepare the saved contexts for the upcoming save (next iteration)
//    			// The timestamp will then be set
//    			if (++nbEvents % fIndexPageSize == 0) {
//    				savedContexts = new TmfTraceContext[nbTraces];
//    				for (int i = 0; i < nbTraces; i++) {
//    					savedContexts[i] = new TmfTraceContext(contexts[i].getLocation(), null, nbEvents);
//    				}
//    			}

    			// TODO: LTTng specific (to be generalized)
    			if (++nbEvents % fIndexPageSize == 0) {
	    			// Udpate the contexts timestamp
    				// Special case: if the total number of events is a multiple of the
    				// DEFAULT_PAGE_SIZE then all the pending events are null. In that
    				// case, we don't store an additional entry in the index array.
    				int nullTimestamps = 0;
    				savedContexts = new TmfTraceContext[nbTraces];
    	    		for (int i = 0; i < nbTraces; i++) {
    	    			savedContexts[i] = new TmfTraceContext(contexts[i].getLocation(), (TmfTimestamp) contexts[i].getLocation(), nbEvents);
    	    			if (events[i] == null)
    	    				nullTimestamps++;
    	    		}
    	    		if (nullTimestamps < nbTraces) {
    	    			indices.add(savedContexts);
    	    		}
    			}

    			monitor.worked(1);
                if (monitor.isCanceled()) {
                    monitor.done();
                	return Status.CANCEL_STATUS;
                }
    		}

            monitor.done();
            fExperimentIndex = indices;

//            dumpIndex();

            fIndexing = false;
            return Status.OK_STATUS;
		}

