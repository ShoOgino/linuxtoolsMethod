		/* (non-Javadoc)
		 * @see org.eclipse.core.runtime.jobs.Job#run(org.eclipse.core.runtime.IProgressMonitor)
		 */
		@Override
		protected IStatus run(IProgressMonitor monitor) {

            int nbEvents = 0;
            TmfTimestamp startTime = new TmfTimestamp();
            TmfTimestamp lastTime  = new TmfTimestamp();

            monitor.beginTask("Indexing " + fName, IProgressMonitor.UNKNOWN);

            try {
            	// Position the trace at the beginning
                TmfTraceContext context = seekLocation(null);
                if (context.getTimestamp() == null) {
                	return Status.OK_STATUS;
                }
                // FIXME: LTTng hack - start
//               	fCheckpoints.add(new TmfTraceCheckpoint(context.getTimestamp(), context.getLocation()));	// TMF
                // FIXME: LTTng hack - end

               	TmfEvent event;
               	startTime = context.getTimestamp();
               	lastTime  = context.getTimestamp();
                while ((event = getNextEvent(context)) != null) {
                	TmfTimestamp timestamp = context.getTimestamp();
            		if (timestamp != null) {
            			lastTime = timestamp;
            		}
                    // FIXME: LTTng hack - start
//                    if (((++nbEvents % fCacheSize) == 0) && (timestamp != null)) {	// TMF
                    if (((nbEvents++ % fCacheSize) == 0) && (timestamp != null)) {	// LTTng
                        // FIXME: LTTng hack - end
                   		fCheckpoints.add(new TmfTraceCheckpoint(timestamp, context.getLocation()));
                   		fNbEvents = nbEvents - 1;
                   		lastTime = context.getTimestamp();
                   		fTimeRange = new TmfTimeRange(startTime, lastTime);
                   		notifyListeners(new TmfTimeRange(startTime, lastTime));

                        monitor.worked(1);

                        // Check monitor *after* fCheckpoints has been updated
                        if (monitor.isCanceled()) {
                            monitor.done();
                        	return Status.CANCEL_STATUS;
                        }
                    }

                    // Do whatever
                    processEvent(event);
                }
            }
            finally {
                synchronized(this) {
                	fNbEvents = nbEvents;
                	fTimeRange = new TmfTimeRange(startTime, lastTime);
            		fIndexing = false;
                }
                notifyListeners(new TmfTimeRange(startTime, lastTime));
                monitor.done();

            }

//            createOffsetsFile();
//            dumpCheckpoints();
            
            return Status.OK_STATUS;
		}

