		/* (non-Javadoc)
		 * @see org.eclipse.core.runtime.jobs.Job#run(org.eclipse.core.runtime.IProgressMonitor)
		 */
		@Override
		protected IStatus run(IProgressMonitor monitor) {

            int nbEvents = 0;
            TmfTimestamp startTime = new TmfTimestamp();
            TmfTimestamp lastTime  = new TmfTimestamp();
            TmfTimestamp rangeStartTime = new TmfTimestamp();

            monitor.beginTask("Indexing " + fName, IProgressMonitor.UNKNOWN);

			try {
                TmfTraceContext nextEventContext = null;
               	nextEventContext = seekLocation(null);
                TmfTraceContext currentEventContext = new TmfTraceContext(nextEventContext);

                TmfEvent event = getNextEvent(nextEventContext);
                if (event == null) {
                	return Status.OK_STATUS;
                }

               	startTime = event.getTimestamp();
               	lastTime  = event.getTimestamp();
               	fCheckpoints.add(new TmfTraceCheckpoint(lastTime, currentEventContext.getLocation()));
                currentEventContext.setLocation(nextEventContext.getLocation());

                rangeStartTime = startTime;
                while ((event = getNextEvent(nextEventContext)) != null) {
                    lastTime = event.getTimestamp();
                    if ((++nbEvents % fCacheSize) == 0) {
//                       	fCheckpoints.add(new TmfTraceCheckpoint(lastTime, currentEventContext.getLocation()));
                    	// TODO: LTTng specific (to be generalized)
                       	fCheckpoints.add(new TmfTraceCheckpoint(lastTime, nextEventContext.getLocation()));
                       	fNbEvents = nbEvents - 1;
                        fTimeRange = new TmfTimeRange(startTime, lastTime);
                        notifyListeners(new TmfTimeRange(rangeStartTime, lastTime));

                        monitor.worked(1);

                        // Check monitor *after* fCheckpoints has been updated
                        if (monitor.isCanceled()) {
                            monitor.done();
                        	return Status.CANCEL_STATUS;
                        }
                    }

                    // Do whatever
                    processEvent(event);
                    currentEventContext.setLocation(nextEventContext.getLocation());
                }
            }
            finally {
                synchronized(this) {
                	fNbEvents = ++nbEvents;
                	fTimeRange = new TmfTimeRange(startTime, lastTime);
            		fIndexing = false;
                }
                notifyListeners(new TmfTimeRange(rangeStartTime, lastTime));
                monitor.done();
            }

            return Status.OK_STATUS;
		}

