	/**
	 * Given an experiment event index, position the set of traces so a call
	 * to getNextEvent() will retrieve the corresponding event.
	 * 
	 * @param index
	 * @param traces
	 * @param contexts
	 * @param nextEvents
	 */
	private synchronized void positionTraces(long index, ITmfTrace[] traces, TmfTraceContext[] contexts, TmfEvent[] nextEvents) {

		// Compute the index page and corresponding index
		int page = (int) index / fIndexPageSize;
		int current = page * fIndexPageSize;

		// Retrieve the checkpoint and set the contexts (make copies)
		TmfTraceContext[] saveContexts = new TmfTraceContext[contexts.length];
		if (page < fExperimentIndex.size()) {
			saveContexts = fExperimentIndex.elementAt(page);
			for (int i = 0; i < contexts.length; i++) {
				contexts[i] = new TmfTraceContext(saveContexts[i]);
			}
		} else {
			// If the page entry doesn't exist (e.g. indexing not completed),
			// set contexts at the the last entry (if it exists)
			page = fExperimentIndex.size() - 1;
			if (page >= 0) {
				saveContexts = fExperimentIndex.elementAt(page);
				for (int i = 0; i < contexts.length; i++) {
					contexts[i] = new TmfTraceContext(saveContexts[i]);
				}
				current = page * fIndexPageSize;
			}
			// Index is empty... position traces at their beginning
			else {
				for (int i = 0; i < contexts.length; i++) {
					contexts[i] = new TmfTraceContext(traces[i].seekLocation(null));
				}
				current = 0;
			}
		}

		// Set the next events
		for (int i = 0; i < contexts.length; i++) {
			nextEvents[i] = traces[i].getNextEvent(contexts[i]);
		}

		// Position the traces at the requested index
		while (current++ < index) {
			getNextEvent(traces, contexts, nextEvents);
		}
	}

