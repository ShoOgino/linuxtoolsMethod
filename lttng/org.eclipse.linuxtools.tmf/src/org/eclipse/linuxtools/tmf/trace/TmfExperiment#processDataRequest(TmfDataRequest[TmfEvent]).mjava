	/**
	 * Process a data request
	 * 
	 * @param request
	 */
	private void processDataRequest(final TmfDataRequest<TmfEvent> request) {

		// General request parameters
		final TmfTimestamp endTime;
		final long index;

		// Initialize request params depending on request type
		if (request.getRange() != null) {
			index = getIndex(request.getRange().getStartTime());
			endTime = request.getRange().getEndTime();
    	} else {
    		index = request.getIndex();
    		endTime = TmfTimestamp.BigCrunch;
    	}

		// Process the request
		Thread thread = new Thread() {

			@Override
			public void run() {

				// Key variables
				ITmfTrace[] traces = new ITmfTrace[0];	// The set of traces
				TmfTraceContext[] contexts;				// The set of trace contexts

				// Extract the general request information
				int blockSize = request.getBlockize();
				int nbRequestedEvents = request.getNbRequestedItems();
				if (nbRequestedEvents == -1) {
					nbRequestedEvents = Integer.MAX_VALUE;
				}

				// Create the result buffer
				Vector<TmfEvent> events = new Vector<TmfEvent>();
				int nbEvents = 0;

				// Initialize the traces array and position the traces
				// at the first requested event
				traces = fTraces.toArray(traces);
				contexts = new TmfTraceContext[traces.length];
				positionTraces(index, traces, contexts);

				// Get the ordered events
				TmfEvent event = getNextEvent(traces, contexts);
				while (!request.isCancelled() && nbEvents < nbRequestedEvents && event != null
						&& event.getTimestamp().compareTo(endTime, false) < 0)
				{
					events.add(event);
					if (++nbEvents % blockSize == 0) {
						pushData(request, events);
					}
					// Avoid an unnecessary read passed the last event requested
					if (nbEvents < nbRequestedEvents)
						event = getNextEvent(traces, contexts);
				}
				pushData(request, events);
				request.done();
			}
		};
		thread.start();
	}

