    /**
     * Compare with another timestamp
     * 
     * @param other the other timestamp
     * @param withinPrecision indicates if precision is to be take into consideration
     * @return -1: this timestamp is lower (i.e. anterior)
     *          0: timestamps are equal (within precision if requested)
     *          1: this timestamp is higher (i.e. posterior)
     */
    public int compareTo(final TmfTimestamp other, boolean withinPrecision) {

    	// If values have the same time scale, perform the comparison
        if (fScale == other.fScale) {
            if (withinPrecision) {
                if ((fValue + fPrecision) < (other.fValue - other.fPrecision))
                    return -1;
                if ((fValue - fPrecision) > (other.fValue + other.fPrecision))
                    return 1;
                return 0;
            }
            return (fValue == other.fValue) ? 0 : (fValue < other.fValue) ? -1 : 1;
        }

        // If values have different time scales, adjust to the finest one and
        // then compare. If the scaling difference is too large, revert to
        // some heuristics. Hopefully, nobody will try to compare galactic and
        // quantic clock events...
        if (Math.abs(fScale - other.fScale) > MAX_SCALING) {
            return simpleCompare(other);
        }

        byte newScale = (fScale < other.fScale) ? fScale : other.fScale;
        try {
            TmfTimestamp ts1 = this.synchronize(0, newScale);
            TmfTimestamp ts2 = other.synchronize(0, newScale);
            return ts1.compareTo(ts2, withinPrecision);
        } catch (ArithmeticException e) {
            return simpleCompare(other);
        }
    }

