	/**
	 * Scan the next events from all traces and return the next one
	 * in chronological order.
	 * 
	 * @param context
	 * @return
	 */
	public synchronized TmfEvent getNextEvent(TmfContext context) {

		// Validate the context
		if (!(context instanceof TmfExperimentContext)) {
			return null;	// Throw an exception?
		}

		TmfExperimentContext expContext = (TmfExperimentContext) context;

		// If an event was consumed previously, get the next one from that trace
		int lastTrace = expContext.getLastTrace();
		if (lastTrace != TmfExperimentContext.NO_TRACE) {
		    TmfContext traceContext = expContext.getContexts()[lastTrace];
			expContext.getEvents()[lastTrace] = expContext.getTraces()[lastTrace].getNextEvent(traceContext);
		}

		// Scan the candidate events and identify the "next" trace to read from 
		int trace = TmfExperimentContext.NO_TRACE;
		TmfTimestamp timestamp = TmfTimestamp.BigCrunch;
		for (int i = 0; i < expContext.getTraces().length; i++) {
			TmfEvent event = expContext.getEvents()[i];
			if (event != null && event.getTimestamp() != null) {
				TmfTimestamp otherTS = event.getTimestamp();
				if (otherTS.compareTo(timestamp, true) < 0) {
					trace = i;
					timestamp = otherTS;
				}
			}
		}

		// Update the experiment context and set the "next" event
		TmfEvent event = null;
		if (trace >= 0) {
			long savedRank = expContext.getRank();
			updateIndex(expContext, savedRank, timestamp);
			expContext.setLastTrace(trace);
			expContext.updateRank(1);
			TmfExperimentLocation expLocation = (TmfExperimentLocation) expContext.getLocation();
            TmfContext traceContext = expContext.getContexts()[trace];
			expLocation.getLocation()[trace] = traceContext.getLocation().clone();
			expLocation.getRanks()[trace] = traceContext.getRank();
			event = expContext.getEvents()[trace];
//			updateIndex(expContext, savedRank, timestamp);
		}

		return event;
	}

