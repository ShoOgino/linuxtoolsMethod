	@SuppressWarnings("unchecked")
	public void indexExperiment() {

		final TmfExperiment<?> experiment = getCurrentExperiment();
		fCheckpoints.clear();

		ITmfEventRequest<TmfEvent> request = new TmfEventRequest<TmfEvent>(TmfEvent.class, TmfTimeRange.Eternity, TmfDataRequest.ALL_DATA, 1, ITmfDataRequest.ExecutionType.LONG) {

			// long indexingStart = System.nanoTime();
			
			TmfTimestamp startTime =  null;
			TmfTimestamp lastTime  =  null;
			int nbEvents = 0;

			@Override
			public void handleData() {
				TmfEvent[] events = getData();
				if (events.length > 0) {
					nbEvents++;
					TmfTimestamp ts = events[0].getTimestamp();
					if (startTime == null)
						startTime = new TmfTimestamp(ts);
					lastTime = new TmfTimestamp(ts);

					if ((nbEvents % DEFAULT_INDEX_PAGE_SIZE) == 0) {
						updateExperiment();
					}
				}
			}

			@Override
			public void handleSuccess() {
				// long indexingEnd = System.nanoTime();

				updateExperiment();
//					experiment.fCheckpoints = new Vector<TmfCheckpoint>();
//	            	for (int i = 0; i < fCheckpoints.size(); i++) {
//	            		TmfCheckpoint checkpoint = fCheckpoints.get(i).clone();
//	            		experiment.fCheckpoints.add(checkpoint);
//	            		System.out.println("fCheckpoints[" + i + "] " + checkpoint.getTimestamp() + ", " + checkpoint.getLocation().toString());
//	            	}

//	            	clone.dispose();
//	            	if (Tracer.INTERNALS) Tracer.trace(getName() + ": nbEvents=" + nbEvents + " (" + ((indexingEnd-indexingStart)/nbEvents)+ " ns/evt), start=" + startTime + ", end=" + lastTime);

				// System.out.println(getName() + ": start=" + startTime +
				// ", end=" + lastTime + ", elapsed=" + (indexingEnd*1.0 -
				// indexingStart) / 1000000000);
				// System.out.println(getName() + ": nbEvents=" + fNbEvents +
				// " (" + ((indexingEnd-indexingStart)/nbEvents)+ " ns/evt)");
//            	for (int i = 0; i < experiment.fCheckpoints.size(); i++) {
//            		TmfCheckpoint checkpoint = experiment.fCheckpoints.get(i);
//            		System.out.println("fCheckpoints[" + i + "] " + checkpoint.getTimestamp() + ", " + checkpoint.getLocation().toString());
//            	}
			}

			private void updateExperiment() {
				if (experiment == fCurrentExperiment)
					experiment.fTimeRange   = new TmfTimeRange(startTime, new TmfTimestamp(lastTime));
					experiment.fNbEvents    = nbEvents;
					experiment.fCheckpoints = ((TmfExperiment<T>) fClone).fCheckpoints;
					notifyListeners();
			}
		};

		sendRequest((ITmfDataRequest<T>) request);
	}

