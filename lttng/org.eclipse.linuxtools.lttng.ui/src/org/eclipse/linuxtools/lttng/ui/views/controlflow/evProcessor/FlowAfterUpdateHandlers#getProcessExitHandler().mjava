	/**
	 * <p>
	 * Handles: LTT_EVENT_PROCESS_EXIT
	 * </p>
	 * Replace C function "after_process_exit_hook" in eventhooks.c
	 * 
	 * @return
	 */
	final ILttngEventProcessor getProcessExitHandler() {
	    AbsFlowTRangeUpdate handler = new AbsFlowTRangeUpdate() {

			// @Override
			@Override
			public boolean process(LttngEvent trcEvent, LttngTraceState traceSt) {
			    
			    LttngProcessState process = traceSt.getRunning_process().get(trcEvent.getCpuId());

			    if ( process != null ) {
			        
					// *** TODO: ***
					// We shall look into a way to find the current process
					// faster, see the c library
					// (current_hash) in order to speed up the find. see c-code
			        //   if(likely(process_list->current_hash_data[trace_num][cpu] != NULL) ){
		            //        hashed_process_data = process_list->current_hash_data[trace_num][cpu];
		            //   }
			        TimeRangeEventProcess localProcess = procContainer.findProcess(process.getPid(), process.getCpu(), traceSt.getTraceId(),  process.getCreation_time());
			        
			        if ( localProcess == null ) {
			            if ( (process.getPid() == 0) || (process.getPid() != process.getPpid()) ) {			                
			                TmfTimeRange timeRange = traceSt.getContext().getTraceTimeWindow();
		                    localProcess = addLocalProcess(process, timeRange.getStartTime().getValue(), timeRange.getEndTime().getValue(), traceSt.getTraceId());
			            }
			            else {
			                TraceDebug.debug("process pid is not 0 or pid equals ppid! (getProcessExitHandler)");
			            }
					}
			    }
			    else {
			        TraceDebug.debug("process is null! (getProcessExitHandler)");
			    }			    
			    
				return false;
			}
		};
		return handler;
	}

