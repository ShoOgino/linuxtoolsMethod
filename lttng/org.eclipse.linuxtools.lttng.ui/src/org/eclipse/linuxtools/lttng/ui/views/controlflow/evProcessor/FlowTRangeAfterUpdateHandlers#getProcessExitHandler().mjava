	/**
	 * <p>
	 * Handles: LTT_EVENT_PROCESS_EXIT
	 * </p>
	 * Replace C function "after_process_exit_hook" in eventhooks.c
	 * 
	 * @return
	 */
	final IEventProcessing getProcessExitHandler() {
	    AbsFlowTRangeUpdate handler = new AbsFlowTRangeUpdate() {

			private Events eventType = Events.LTT_EVENT_PROCESS_EXIT;

			// @Override
			public boolean process(LttngEvent trcEvent, LttngTraceState traceSt) {
			    
			    LttngProcessState process = traceSt.getRunning_process().get(trcEvent.getCpuId());

			    if ( process != null ) {
			        
					// *** TODO: ***
					// We shall look into a way to find the current process
					// (current_hash) in order to speed up the find. see c-code
			        //   if(likely(process_list->current_hash_data[trace_num][cpu] != NULL) ){
		            //        hashed_process_data = process_list->current_hash_data[trace_num][cpu];
		            //   }
			        TimeRangeEventProcess localProcess = procContainer.findProcess(process.getPid(), process.getCreation_time().getValue(), traceSt.getTraceId());
			        
			        if ( localProcess == null ) {
			            if ( (process.getPid() == 0) || (process.getPid() != process.getPpid()) ) {			                
			                TmfTimeRange timeRange = traceSt.getInputDataRef().getTraceTimeWindow();
		                    localProcess = addLocalProcess(process, timeRange.getStartTime().getValue(), timeRange.getEndTime().getValue(), traceSt.getTraceId());
			            }
			            else {
			                TraceDebug.debug("process pid is not 0 or pid equals ppid! (getProcessExitHandler)");
			            }
			        }
			        else {
			            // *** FIXME ***
                        // I feel like we are missing something here... what are we suppose to do with that?
                        //   process_list->current_hash_data[trace_num][process->cpu] = hashed_process_data;
			        }
                        
			    }
			    else {
			        TraceDebug.debug("process is null! (getProcessExitHandler)");
			    }			    
			    
			    // *** VERIFY ***
                // We don't need any of those, do we?
                //
                //if(likely(ltt_time_compare(hashed_process_data_child->next_good_time,evtime) <= 0))
                //  {
                //    TimeWindow time_window = lttvwindow_get_time_window(control_flow_data->tab);
                //
                //    #ifdef EXTRA_CHECK
                //    if(ltt_time_compare(evtime, time_window.start_time) == -1 || ltt_time_compare(evtime, time_window.end_time) == 1)
                //       return FALSE;
                //    #endif //EXTRA_CHECK
                //    
                //    Drawing_t *drawing = control_flow_data->drawing;
                //    guint width = drawing->width;
                //    guint new_x;
                //    convert_time_to_pixels(time_window,evtime,width,&new_x);
                //
                //    if(likely(hashed_process_data_child->x.over != new_x)) {
                //      hashed_process_data_child->x.over = new_x;
                //      hashed_process_data_child->x.over_used = FALSE;
                //      hashed_process_data_child->x.over_marked = FALSE;
                //    }
                //    if(likely(hashed_process_data_child->x.middle != new_x)) {
                //      hashed_process_data_child->x.middle = new_x;
                //      hashed_process_data_child->x.middle_used = FALSE;
                //      hashed_process_data_child->x.middle_marked = FALSE;
                //    }
                //    if(likely(hashed_process_data_child->x.under != new_x)) {
                //      hashed_process_data_child->x.under = new_x;
                //      hashed_process_data_child->x.under_used = FALSE;
                //      hashed_process_data_child->x.under_marked = FALSE;
                //    }
			    
				return false;
			}

			// @Override
			public Events getEventHandleType() {
				return eventType;
			}
		};
		return handler;
	}

