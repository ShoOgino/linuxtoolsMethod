    /**
     * Parses the domain information.
     * 
     * @param output - a command output array
     * @param currentIndex - current index in command output array
     * @param channels - list for returning channel information
     * @return the new current index in command output array 
     * @throws PatternSyntaxException
     */
    private int parseDomain(String[] output, int currentIndex, List<IChannelInfo> channels) throws PatternSyntaxException {
        int index = currentIndex;

//      Channels:
//      -------------
//      - channnel1: [enabled]
//
//          Attributes:
//            overwrite mode: 0
//            subbufers size: 262144
//            number of subbufers: 4
//            switch timer interval: 0
//            read timer interval: 200
//            output: splice()
       
        while (index < output.length) {
            String line = output[index];
            if (line.matches(CHANNELS_SECTION_PATTERN)) {
                IChannelInfo channelInfo = null;
                while (index < output.length) {
                    String subLine = output[index];
                    if (subLine.matches(CHANNEL_PATTERN)) {
                        
                        Pattern pattern = Pattern.compile(CHANNEL_PATTERN);
                        Matcher matcher = pattern.matcher(subLine);
                        channelInfo = new ChannelInfo(""); //$NON-NLS-1$
                        if (matcher.matches()) {
                            // get channel name
                            channelInfo.setName(matcher.group(1));
                            
                            // get channel enablement
                            channelInfo.setState(matcher.group(2));

                            // add channel
                            channels.add(channelInfo);
                        }
                    } else if (subLine.matches(OVERWRITE_MODE_ATTRIBUTE)) {
                        String value = getAttributeValue(subLine);
                        channelInfo.setOverwriteMode(!OVERWRITE_MODE_ATTRIBUTE_FALSE.equals(value));
                    } else if (subLine.matches(SUBBUFFER_SIZE_ATTRIBUTE)) {
                        channelInfo.setSubBufferSize(Long.valueOf(getAttributeValue(subLine)));
                        
                    } else if (subLine.matches(NUM_SUBBUFFERS_ATTRIBUTE)) {
                        channelInfo.setNumberOfSubBuffers(Integer.valueOf(getAttributeValue(subLine)));
                        
                    } else if (subLine.matches(SWITCH_TIMER_ATTRIBUTE)) {
                        channelInfo.setSwitchTimer(Long.valueOf(getAttributeValue(subLine)));
                        
                    } else if (subLine.matches(READ_TIMER_ATTRIBUTE)) {
                        channelInfo.setReadTimer(Long.valueOf(getAttributeValue(subLine)));
                        
                    } else if (subLine.matches(OUTPUT_ATTRIBUTE)) {
                        channelInfo.setOutputType(getAttributeValue(subLine));
                        
                    } else if (subLine.matches(EVENT_SECTION_PATTERN)) {
                        List<IEventInfo> events = new ArrayList<IEventInfo>(); 
                        index = parseEvents(output, index, events);
                        channelInfo.setEvents(events);
                        // we want to stay at the current index to be able to exit the domain
                        continue;
                    }
                    else if (subLine.matches(DOMAIN_KERNEL_PATTERN)) {
                        return index;

                    } else if (subLine.contains(DOMAIN_UST_GLOBAL_PATTERN)) {
                        return index;
                    }
                    index++;
                }
            }
            index++;
        }
        return index;
    }

