	// *** FIXME ***
	// "stateMode" should NOT be a string, it is very confusing to use (can we
	// use any string? what kind of string? can it be null??)
	// It should be a "ProcessStatus" or "ExecutionMode". However this mean
	// refactoring this part.
	protected boolean makeDraw(LttngTraceState traceSt, long startTime,
			long endTime, TimeRangeEventResource localResource,
			ParamsUpdater params, String stateMode) {

		// Check if the time range is consistent.
		if (endTime < startTime) {
			params.incrementEventsDiscardedWrongOrder();
			return false;
		}

		// Determine start and end times to establish duration
		long stime = startTime;
		long windowEndTime = params.getEndTime();
		long etime = endTime < windowEndTime ? endTime : windowEndTime;

		if (etime < stime || !withinViewRange(stime, etime)) {
			// No use to process the event since it's outside
			// the visible time range of the window
			params.incrementEventsDiscarded();
			return false;
		}

		// Determine if the time range event will fit it the current
		// pixel map
		double duration = etime - stime;
		double k = getPixelsPerNs(traceSt, params);
		double pixels = duration * k;

		// ***VERIFY***
		// Is all this equivalent to this call in C??
		// if(ltt_time_compare(hashed_process_data->next_good_time,evtime) > 0)
		// ***
		// Visibility check
		// Display a "more information" indication by allowing non visible event
		// as long as its previous event is visible.
		boolean visible = true;
		if (pixels < 1) {
			boolean prevEventVisibility = true;
			// Get the visibility indication on previous event for
			// this process
			Vector<TimeRangeComponent> inMemEvents = localResource
					.getTraceEvents();
			if (inMemEvents.size() != 0) {
				TimeRangeComponent prevEvent = inMemEvents.get(inMemEvents
						.size() - 1);
				prevEventVisibility = prevEvent.isVisible();

				// ***VERIFY***
				// This replace all C Call like this one ?
				// #ifdef EXTRA_CHECK if(ltt_time_compare(evtime,
				// time_window.start_time) == -1 || ltt_time_compare(evtime,
				// time_window.end_time) == 1)

				// if previous event visibility is false and the time span
				// between events less than two pixels, there is no need to
				// load it in memory i.e. not visible and a more indicator is
				// within two pixels.
				// return i.e. event discarded to free up memory
				Long eventSpan = stime - prevEvent.getStartTime();
				if (prevEventVisibility == false
						&& ((double) eventSpan * k) < 2) {
					params.incrementEventsDiscarded();
					return false;
				}
			}

			// if previous event is visible, set this one to not
			// visible and continue
			visible = false;
		}

		Type eventType = getEventType(localResource);
		if (eventType != null) {
			// Create the time-range event
			// *** VERIFY ***
			// This should replace this C call, right?
			// TimeWindow time_window =
			// lttvwindow_get_time_window(control_flow_data->tab);
			TimeRangeEvent time_window = new TimeRangeEvent(stime, etime,
					localResource, eventType, stateMode);

			// *** VERIFY ***
			// This is added to replace the multiple draw and gtk/glib command
			// but
			// I'm not sure about it
			time_window.setVisible(visible);
			localResource.addChildren(time_window);
			// Store the next good time to start drawing the event.
			localResource.setNext_good_time(etime);
			// *** VERIFY ***
			// Missing checks like this one?
			// #ifdef EXTRA_CHECK if(ltt_time_compare(evtime,
			// time_window.start_time) == -1 || ltt_time_compare(evtime,
			// time_window.end_time) == 1)
		}

		return false;
	}

