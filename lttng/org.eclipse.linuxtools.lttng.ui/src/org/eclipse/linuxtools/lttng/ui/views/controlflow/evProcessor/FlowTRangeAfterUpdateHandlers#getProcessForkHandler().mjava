	/**
	 * <p>
	 * Handles: LTT_EVENT_PROCESS_FORK
	 * </p>
	 * Replace C function "after_process_fork_hook" in eventhooks.c
	 * <p>
	 * Fields: LTT_FIELD_CHILD_PID
	 * </p>
	 * 
	 * @return
	 */
	final IEventProcessing getProcessForkHandler() {
	    AbsFlowTRangeUpdate handler = new AbsFlowTRangeUpdate() {

			private Events eventType = Events.LTT_EVENT_PROCESS_FORK;

			// @Override
			public boolean process(LttngEvent trcEvent, LttngTraceState traceSt) {  
			    
                Long child_pid = getAFieldLong(trcEvent, traceSt, Fields.LTT_FIELD_CHILD_PID);
                LttngProcessState process_child = lttv_state_find_process(traceSt, trcEvent.getCpuId(), child_pid );
			    
			    if ( process_child != null ) {
			        TimeRangeEventProcess localProcess = procContainer.findProcess(process_child.getPid(), process_child.getCreation_time().getValue(), traceSt.getTraceId() );
			        
			        if ( localProcess == null ) {
			            if ( (child_pid == 0) || (child_pid != process_child.getPpid()) ) {            
			                // *** VERIFY ***
			                // What am I supposed to do with that?
			                //   Drawing_t *drawing = control_flow_data->drawing;
			                //   ProcessInfo *process_info;
			                //   gtk_widget_set_size_request(drawing->drawing_area, -1, pl_height);
			                //   gtk_widget_queue_draw(drawing->drawing_area);
			                TmfTimeRange timeRange = traceSt.getInputDataRef().getTraceTimeWindow();
                            localProcess = addLocalProcess(process_child, timeRange.getStartTime().getValue(), timeRange.getEndTime().getValue(), traceSt.getTraceId());
			            }
			            else {
			                TraceDebug.debug("localProcess is null with child_pid not 0 or child_pid equals PPID (getProcessForkHandler)");
			            }
			        }
			        else {
			            // If we found the process, the Ppid and the Tgid might be missing, let's add them
			            localProcess.setPpid(process_child.getPpid());
			            localProcess.setTgid(process_child.getTgid());
			            
			        }
			    }
			    else {
			        TraceDebug.debug("process_child is null! (getProcessForkHandler)");
			    }
                
			    // *** VERIFY ***
			    // We don't need any of those, do we?
			    //
			    //if(likely(ltt_time_compare(hashed_process_data_child->next_good_time,evtime) <= 0))
	            //  {
	            //    TimeWindow time_window = lttvwindow_get_time_window(control_flow_data->tab);
			    //
	            //    #ifdef EXTRA_CHECK
	            //    if(ltt_time_compare(evtime, time_window.start_time) == -1 || ltt_time_compare(evtime, time_window.end_time) == 1)
	            //       return FALSE;
	            //    #endif //EXTRA_CHECK
	            //    
	            //    Drawing_t *drawing = control_flow_data->drawing;
	            //    guint width = drawing->width;
	            //    guint new_x;
	            //    convert_time_to_pixels(time_window,evtime,width,&new_x);
			    //
	            //    if(likely(hashed_process_data_child->x.over != new_x)) {
	            //      hashed_process_data_child->x.over = new_x;
	            //      hashed_process_data_child->x.over_used = FALSE;
	            //      hashed_process_data_child->x.over_marked = FALSE;
	            //    }
	            //    if(likely(hashed_process_data_child->x.middle != new_x)) {
	            //      hashed_process_data_child->x.middle = new_x;
	            //      hashed_process_data_child->x.middle_used = FALSE;
	            //      hashed_process_data_child->x.middle_marked = FALSE;
	            //    }
	            //    if(likely(hashed_process_data_child->x.under != new_x)) {
	            //      hashed_process_data_child->x.under = new_x;
	            //      hashed_process_data_child->x.under_used = FALSE;
	            //      hashed_process_data_child->x.under_marked = FALSE;
	            //    }
	              
				return false;
			}

			// @Override
			public Events getEventHandleType() {
				return eventType;
			}
		};
		return handler;
	}

