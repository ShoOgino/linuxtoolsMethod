	// *** VERIFY ***
	// Is it good to put this synchronized?
	//
	/**
	 * Draw the histogram bars in the canvas.<p>
	 * This drawing function expect the content to be the power of 2 higher than the canvas size.
	 * The bars size will be slightly dynamic to fill the gap between the power and the canvas size.<p>
	 * 
	 * Note : This draw function is somewhat heavier than the default one.
	 * 
	 * @param event The generated paint event when redraw is called.
	 */
	@Override
	public synchronized void drawHistogram(PaintEvent event) {
		HistogramContent tmpContent = parentCanvas.getHistogramContent();
		int tmpBarWidth = tmpContent.getBarsWidth();
		int canvasSize = event.width;
		
		event.gc.setBackground(event.display.getSystemColor(HistogramConstant.HISTOGRAM_BARS_COLOR));
		
		// Calculate the closest power of 2 just smaller than the canvas size
		int closestPowerToCanvas = (int)Math.pow(2, Math.floor( Math.log( canvasSize ) / Math.log(2.0) ));
		
		// Calculate the factor of difference between canvas and the power
		double factor = (double)canvasSize / (double)closestPowerToCanvas;
		// Calculate how many interval will need to be concatenated into one pixel
		int intervalDifference = (tmpContent.getNbElement() / closestPowerToCanvas)*tmpBarWidth;
		
		// This keep a link between the position in "power" and the pixel we draw 
		// I.e. correlation between position in the power ("fake" pixels) and the position in the canvas ("real" pixels)
		// So if pos == 30 and factor == 1.5, we know that the pixel that draw this pos is (30 * 1.5) == 45
		int posInPower = 0;
		int widthFilled = 0;
		
		// Read from 0 up to the currently ready position
		// We advance by "intervalDifference" as the bars migth not represent 1 interval only
		for( int contentPos=0; contentPos < tmpContent.getReadyUpToPosition(); contentPos += intervalDifference ) {
			// Width of the current item. 
			// Vary because of the difference between the power of 2 and the canvas size
			// Ex: if power == 1024 and canvas == 1500, a bars every (1024/1500) will have a size of 2 instead of 1.
			int itemWidth = (int)( Math.ceil((double)(posInPower+1)*factor) - Math.ceil((double)posInPower*factor) );
			itemWidth = itemWidth*tmpBarWidth;
			
			// Concatenate all the element in the interval
			// Ex : if power == 1024 and content == 2048, every (2048/1024)*bars_width will be concatenated 
	    	int thisElementHeight = 0;
	    	for ( int concatPos=0; concatPos<intervalDifference; concatPos++) {
	    		int updatedPos = contentPos + concatPos;
	    		// Make sure we don't cross the last element available.
	    		if ( updatedPos < tmpContent.getReadyUpToPosition() ) {
	    			thisElementHeight += tmpContent.getElementByIndex(contentPos + concatPos).intervalHeight;
	    		}
	    	}
	    	
	    	// *** NOTE *** 
			// Y Position in a canvas is REVERSED, so "0" is on top of the screen and "MAX" is on bottom.
			// Not very instinctive, isn't it?
	    	
	    	// Draw our rectangle 
    		Rectangle rect = new Rectangle(widthFilled, event.height - thisElementHeight, itemWidth, thisElementHeight);
    		event.gc.fillRectangle(rect);
    		
    		// Keep in a variable how much width we filld so far
    		widthFilled += itemWidth;
    		// Keep a correlation between fake_pixel -> real_pixel, 
    		//	this is used to calculate the width of each element 
    		posInPower++;
	    }
	    
		// Clear the remaining space in the canvas (there should not be any) so it appears clean.
	    event.gc.setBackground(event.display.getSystemColor(HistogramConstant.EMPTY_BACKGROUND_COLOR));
	    Rectangle rect = new Rectangle(widthFilled, 0, event.width, event.height);
	    event.gc.fillRectangle(rect);
	}

