	// *** VERIFY ***
	// Is it good to put this synchronized?
	//
	/**
	 * Draw the histogram bars in the canvas.<p>
	 * This drawing function expect the content to be the power of 2 higher than the canvas size.
	 * The bars size will be slightly dynamic to fill the gap between the power and the canvas size.<p>
	 * 
	 * Note : This draw function is somewhat heavier than the default one.
	 * 
	 * @param event The generated paint event when redraw is called.
	 */
	@Override
	public synchronized void drawHistogram(GC imageGC, Image image) {
		final HistogramContent tmpContent = parentCanvas.getHistogramContent();
		final int tmpBarWidth = tmpContent.getBarsWidth();
		
		// Calculate the closest power of 2 just smaller than the canvas size
		final int closestPowerToCanvas = (int)Math.pow(2, Math.floor( Math.log( image.getBounds().width ) / Math.log(2.0) ));

		// First clear the whole canvas to have a clean section where to draw
		clearDrawingSection(imageGC, image, parentCanvas);
		
		// Make sure the canvas didn't change size, it which case we need to recalculate our heights
		recalculateHeightIfCanvasSizeChanged();
		
		// Calculate the factor of difference between canvas and the power
		final double factor = (double)image.getBounds().width / (double)closestPowerToCanvas;
		// Calculate how many interval will need to be concatenated into one pixel
		final int intervalDifference = (tmpContent.getNbElement() / closestPowerToCanvas)*tmpBarWidth;
		
		// This keep a link between the position in "power" and the pixel we draw 
		// I.e. correlation between position in the power ("fake" pixels) and the position in the canvas ("real" pixels)
		// So if pos == 30 and factor == 1.5, we know that the pixel that draw this pos is (30 * 1.5) == 45
		int posInPower = 0;
		int widthFilled = 0;
		
		// This will be the color for all the bars that wil be draw below.
		imageGC.setBackground( new Color( imageGC.getDevice(), 74, 112, 139) );

		// Read from 0 up to the currently ready position
		// We advance by "intervalDifference" as the bars migth not represent 1 interval only
		int itemWidth = 0;
		int thisElementHeight = 0;
		for( int contentPos=0; contentPos < tmpContent.getReadyUpToPosition(); contentPos += intervalDifference ) {
			// Width of the current item. 
			// Vary because of the difference between the power of 2 and the canvas size
			// Ex: if power == 1024 and canvas == 1500, a bars every (1024/1500) will have a size of 2 instead of 1.
			itemWidth = (int)( Math.ceil((double)(posInPower+1)*factor) - Math.ceil((double)posInPower*factor) );
			itemWidth = itemWidth * tmpBarWidth;
			
			// Concatenate all the element in the interval
			// Ex : if power == 1024 and content == 2048, every (2048/1024)*bars_width will be concatenated 
	    	thisElementHeight = 0;
	    	for ( int concatPos=0; concatPos<intervalDifference; concatPos++) {
	    		// Make sure we don't cross the last element available.
	    		if ( contentPos + concatPos < tmpContent.getReadyUpToPosition() ) {
	    			thisElementHeight += tmpContent.getElementByIndex(contentPos + concatPos).intervalHeight;
	    		}
	    	}
	    	
	    	// *** NOTE *** 
			// Y Position in a canvas is REVERSED, so "0" is on top of the screen and "MAX" is on bottom.
			// Not very instinctive, isn't it?
			// Draw our rectangle
    		imageGC.fillRectangle(
    				widthFilled,
    				(thisElementHeight > image.getBounds().height ? 0 : image.getBounds().height - thisElementHeight),
    				itemWidth,
    				thisElementHeight
    				);
    		
    		// Keep in a variable how much width we filld so far
    		widthFilled += itemWidth;
    		// Keep a correlation between fake_pixel -> real_pixel, 
    		//	this is used to calculate the width of each element 
    		posInPower++;
	    }
	}

