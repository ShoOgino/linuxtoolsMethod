	/**
	 * <p>
	 * Handles: LTT_EVENT_STATEDUMP_END
	 * </p>
	 * Replace C function named "before_statedump_end" in eventhooks.c
	 * 
	 * @return
	 */
	final IEventProcessing getStateDumpEndHandler() {
		AbsFlowTRangeUpdate handler = new AbsFlowTRangeUpdate() {

			private Events eventType = Events.LTT_EVENT_STATEDUMP_END;

			// @Override
			public boolean process(LttngEvent trcEvent, LttngTraceState traceSt) {

				// What's below should replace the following call in C :
				// ClosureData closure_data;
				// closure_data.events_request = events_request;
				// closure_data.tss = tss;
				// closure_data.end_time = evtime;
				// convert_time_to_pixels(time_window,evtime,width,&closure_data.x_end);
				// g_hash_table_foreach(process_list->process_hash,
				// draw_closure,(void*)&closure_data);
				//
				// And the draw is always the same then...

				LttngProcessState process = null;
				for (int proc_id = 0; proc_id < traceSt.getProcesses().size(); proc_id++) {
					process = lttv_state_find_process(traceSt, traceSt
							.getProcesses().get(proc_id).getCpu(), traceSt
							.getProcesses().get(proc_id).getPid());

					if (process != null) {
						// Replace the C call :
						// hashed_process_data =
						// processlist_get_process_data(process_list,pid,process->cpu,&birth,trace_num);
						TimeRangeEventProcess localProcess = procContainer
								.findProcess(process.getPid(), process
										.getCreation_time().getValue(), traceSt
										.getTraceId());
						if (localProcess != null) {
							// Call the function that will does the actual
							// drawing
							makeDraw(traceSt, trcEvent.getTimestamp(), process,
									localProcess, params);
						} else {
							TraceDebug
									.debug("localProcess is null! (getStateDumpEndHandler)");
						}
					} else {
						TraceDebug
								.debug("Process is null! (getStateDumpEndHandler)");
					}
				}

				return false;

			}

			// @Override
			public Events getEventHandleType() {
				return eventType;
			}
		};

		return handler;
	}

