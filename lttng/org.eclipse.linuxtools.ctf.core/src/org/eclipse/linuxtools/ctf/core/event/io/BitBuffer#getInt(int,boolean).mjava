    /**
     * Relative <i>get</i> method for reading integer of <i>length</i> bits.
     *
     * Reads <i>length</i> bits starting at the current position. The result is
     * signed extended if <i>signed</i> is true. The current position is
     * increased of <i>length</i> bits.
     *
     * @param length
     *            The length in bits of this integer
     * @param signed
     *            The sign extended flag
     * @return The int value read from the buffer
     * @throws CTFReaderException
     *             An error occurred reading the data. When the buffer is read
     *             beyond its end, this exception will be raised.
     */
    private int getInt(int length, boolean signed) throws CTFReaderException {

        /* Nothing to read. */
        if (length == 0) {
            return 0;
        }

        /* Validate that the buffer has enough bits. */
        if (!canRead(length)) {
            throw new CTFReaderException("Cannot read the integer, " + //$NON-NLS-1$
                    "the buffer does not have enough remaining space. " + //$NON-NLS-1$
                    "Requested:" + length); //$NON-NLS-1$
        }

        /* Get the value from the byte buffer. */
        int val = 0;
        boolean gotIt = false;

        /*
         * Try a fast read when the position is byte-aligned by using
         * java.nio.ByteBuffer's native methods
         */
        /*
         * A faster alignment detection as the compiler cannot guaranty that pos
         * is always positive.
         */
        if ((fPosition & (BitBuffer.BIT_CHAR - 1)) == 0) {
            switch (length) {
            case BitBuffer.BIT_CHAR:
                // Byte
                val = fBuffer.get((int) (fPosition / 8));
                if (!signed) {
                    val = val & 0xff;
                }
                gotIt = true;
                break;

            case BitBuffer.BIT_SHORT:
                // Word
                val = fBuffer.getShort((int) (fPosition / 8));
                if (!signed) {
                    val = val & 0xffff;
                }
                gotIt = true;
                break;

            case BitBuffer.BIT_INT:
                // Double word
                val = fBuffer.getInt((int) (fPosition / 8));
                gotIt = true;
                break;

            default:
                break;
            }
        }

        /* When not byte-aligned, fall-back to a general decoder. */
        if (!gotIt) {
            // Nothing read yet: use longer methods
            if (fByteOrder == ByteOrder.LITTLE_ENDIAN) {
                val = getIntLE(fPosition, length, signed);
            } else {
                val = getIntBE(fPosition, length, signed);
            }
        }
        fPosition += length;

        return val;
    }

