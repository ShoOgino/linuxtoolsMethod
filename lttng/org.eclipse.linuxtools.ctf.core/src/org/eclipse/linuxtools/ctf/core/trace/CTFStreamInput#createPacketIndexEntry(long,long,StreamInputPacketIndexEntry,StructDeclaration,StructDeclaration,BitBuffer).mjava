    private long createPacketIndexEntry(long fileSizeBytes,
            long packetOffsetBytes, StreamInputPacketIndexEntry packetIndex,
            StructDeclaration tracePacketHeaderDecl,
            StructDeclaration streamPacketContextDecl, @NonNull BitBuffer bitBuffer)
            throws CTFReaderException {

        /*
         * Ignoring the return value, but this call is needed to initialize the
         * input
         */
        createPacketBitBuffer(fileSizeBytes, packetOffsetBytes, packetIndex, bitBuffer);

        /*
         * Read the trace packet header if it exists.
         */
        if (tracePacketHeaderDecl != null) {
            parseTracePacketHeader(tracePacketHeaderDecl, bitBuffer);
        }

        /*
         * Read the stream packet context if it exists.
         */
        if (streamPacketContextDecl != null) {
            parsePacketContext(fileSizeBytes, streamPacketContextDecl,
                    bitBuffer, packetIndex);
        } else {
            setPacketContextNull(fileSizeBytes, packetIndex);
        }

        /* Basic validation */
        if (packetIndex.getContentSizeBits() > packetIndex.getPacketSizeBits()) {
            throw new CTFReaderException("Content size > packet size"); //$NON-NLS-1$
        }

        if (packetIndex.getPacketSizeBits() > ((fileSizeBytes - packetIndex
                .getOffsetBytes()) * 8)) {
            throw new CTFReaderException("Not enough data remaining in the file for the size of this packet"); //$NON-NLS-1$
        }

        /*
         * Offset in the file, in bits
         */
        packetIndex.setDataOffsetBits(bitBuffer.position());

        /*
         * Update the counting packet offset
         */
        return computeNextOffset(packetIndex);
    }

