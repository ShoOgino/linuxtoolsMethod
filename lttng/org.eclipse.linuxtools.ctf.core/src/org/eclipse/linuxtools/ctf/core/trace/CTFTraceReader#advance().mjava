    /**
     * Go to the next event.
     *
     * @return True if an event was read.
     */
    public boolean advance() {
        /*
         * Index the
         */
        /*
         * Remove the reader from the top of the priority queue.
         */
        StreamInputReader top = this.prio.poll();

        /*
         * If the queue was empty.
         */
        if (top == null) {
            return false;
        }
        /*
         * index if needed
         */
        if (hasMoreEvents()) {
            StreamInputPacketReader packetReader = top.getPacketReader();
            boolean packetHasMoreEvents = packetReader.hasMoreEvents();
            StreamInputPacketIndexEntry currentPacket = packetReader
                    .getCurrentPacket();
            if (!packetHasMoreEvents) {
                int n = this.streamInputReaders.indexOf(top);

                if(!startIndex.containsKey(n)){
                    startIndex.put(n, 0L);
                }
                currentPacket.setIndexBegin(startIndex.get(n));
                currentPacket.setIndexEnd(index);
                startIndex.put(n, index + 1);
            }
        }
        /*
         * Read the next event of this reader.
         */
        if (top.readNextEvent()) {
            /*
             * Add it back in the queue.
             */
            this.prio.add(top);
            final long topEnd = top.getCurrentEvent().timestamp;
            this.endTime = Math.max(topEnd, this.endTime);
            this.eventCountPerTraceFile[top.getName()]++;
            /*
             * increment the index
             */
            fIndex++;
        }
        boolean hasMoreEvents = hasMoreEvents();

        /*
         * If there is no reader in the queue, it means the trace reader reached
         * the end of the trace.
         */
        return hasMoreEvents;
    }

