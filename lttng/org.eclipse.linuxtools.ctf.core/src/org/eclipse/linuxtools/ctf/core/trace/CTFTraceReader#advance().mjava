    /**
     * Go to the next event.
     *
     * @return True if an event was read.
     * @throws CTFReaderException
     *             if an error occurs
     */
    public boolean advance() throws CTFReaderException {
        /*
         * Remove the reader from the top of the priority queue.
         */
        CTFStreamInputReader top = fPrio.poll();

        /*
         * If the queue was empty.
         */
        if (top == null) {
            return false;
        }
        /*
         * Read the next event of this reader.
         */
        switch (top.readNextEvent()) {
        case OK: {
            /*
             * Add it back in the queue.
             */
            fPrio.add(top);
            final long topEnd = fTrace.timestampCyclesToNanos(top.getCurrentEvent().getTimestamp());
            setEndTime(Math.max(topEnd, getEndTime()));
            fEventCountPerTraceFile[top.getName()]++;

            if (top.getCurrentEvent() != null) {
                fEndTime = Math.max(top.getCurrentEvent().getTimestamp(),
                        fEndTime);
            }
            break;
        }
        case WAIT: {
            fPrio.add(top);
            break;
        }
        case FINISH:
            break;
        case ERROR:
        default:
            // something bad happend
        }
        /*
         * If there is no reader in the queue, it means the trace reader reached
         * the end of the trace.
         */
        return hasMoreEvents();
    }

