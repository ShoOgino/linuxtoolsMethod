    /**
     * Given a rank, this methods returns the first PacketIndexEntry that
     * could include the rank, that is the last packet with a begin
     * rank smaller than the given rank.
     *
     * @param index
     *            The rank to look for.
     * @return The StreamInputPacketEntry that corresponds to the packet that
     *         includes the given timestamp.
     */
    public ListIterator<StreamInputPacketIndexEntry> searchIndex(final long index) {
        /*
         * Start with min and max covering all the elements.
         */
        int max = this.entries.size() - 1;
        int min = 0;

        int guessI;
        StreamInputPacketIndexEntry guessEntry = null;

        if (index < 0) {
            throw new IllegalArgumentException("rank is negative"); //$NON-NLS-1$
        }

        for (;;) {
            /*
             * Guess in the middle of min and max. The +1 is so that in case
             * (min + 1 == max), we choose the packet at the subscript "max"
             * instead of the one at "min". Otherwise, it would give an infinite
             * loop.
             */
            guessI = (max + min + 1) / 2;
            guessEntry = this.entries.get(guessI);

            /*
             * If we reached the point where we focus on a single packet, our
             * search is done.
             */
            if (min == max) {
                break;
            }

            if (index < guessEntry.indexBegin) {
                /*
                 * If the timestamp if before the begin timestamp, we know that
                 * the packet to return is before the guess.
                 */
                max = guessI - 1;
            } else if (index >= guessEntry.indexBegin) {
                /*
                 * If the timestamp is after the begin timestamp, we know that
                 * the packet to return is after the guess or is the guess.
                 */
                min = guessI;
            }
        }

        return this.entries.listIterator(guessI);
    }

