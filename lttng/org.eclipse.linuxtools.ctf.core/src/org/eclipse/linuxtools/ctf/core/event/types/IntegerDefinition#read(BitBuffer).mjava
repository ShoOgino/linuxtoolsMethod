    @Override
    public void read(BitBuffer input) {
        final long longNegBit = 0x0000000080000000L;
        int align = (int) declaration.getAlignment();
        int pos = input.position() + ((align-(input.position() % align))%align);
        input.position(pos);
        boolean signed = declaration.isSigned();
        int length = declaration.getLength();
        long bits = 0;

        // TODO: use the eventual getLong from BitBuffer

        if (length == 64) {
            long low = input.getInt(32, false);
            low = low & 0x00000000FFFFFFFFL;
            long high = input.getInt(32, false);
            high = high & 0x00000000FFFFFFFFL;

            bits = (high << 32) | low;
        } else {
            bits = input.getInt(length, signed);
            bits = bits & 0x00000000FFFFFFFFL;
            /*
             * The previous line loses sign information but is necessary, this fixes the sign
             * for 32 bit numbers. Sorry, in java all 64 bit ints are signed.
             */
            if( (longNegBit == (bits & longNegBit)) && signed) {
                bits |= 0xffffffff00000000L;
            }
        }

        value = bits;
    }

