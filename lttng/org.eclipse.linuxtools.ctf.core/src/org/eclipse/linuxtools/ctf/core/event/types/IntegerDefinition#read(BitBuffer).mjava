    @Override
    public void read(BitBuffer input) throws CTFReaderException {
        final long longNegBit = 0x0000000080000000L;
        /* Offset the buffer position wrt the current alignment */
        alignRead(input, this.declaration);

        boolean signed = declaration.isSigned();
        int length = declaration.getLength();
        long bits = 0;

        /*
         * Is the endianness of this field the same as the endianness of the
         * input buffer? If not, then temporarily set the buffer's endianness to
         * this field's just to read the data
         */
        ByteOrder byteOrder = input.getByteOrder();
        if ((this.declaration.getByteOrder() != null) &&
                (this.declaration.getByteOrder() != input.getByteOrder())) {
            input.setByteOrder(this.declaration.getByteOrder());
        }

        // TODO: use the eventual getLong from BitBuffer
        if (length == 64) {
            long low = input.getInt(32, false);
            low = low & 0x00000000FFFFFFFFL;
            long high = input.getInt(32, false);
            high = high & 0x00000000FFFFFFFFL;
            if (this.declaration.getByteOrder() != ByteOrder.BIG_ENDIAN) {
                bits = (high << 32) | low;
            } else {
                bits = (low << 32) | high;
            }
        } else {
            bits = input.getInt(length, signed);
            bits = bits & 0x00000000FFFFFFFFL;
            /*
             * The previous line loses sign information but is necessary, this
             * fixes the sign for 32 bit numbers. Sorry, in java all 64 bit ints
             * are signed.
             */
            if ((longNegBit == (bits & longNegBit)) && signed) {
                bits |= 0xffffffff00000000L;
            }
        }
        /*
         * Put the input buffer's endianness back to original if it was changed
         */
        if (byteOrder != input.getByteOrder()) {
            input.setByteOrder(byteOrder);
        }

        value = bits;
    }

