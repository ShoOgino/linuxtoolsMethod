    private long readPacketHeader(long fileSizeBytes,
            long packetOffsetBytes, StreamInputPacketIndexEntry packetIndex) throws CTFReaderException {
        long position = -1;
        /*
         * Initial size, it should map at least the packet header + context
         * size.
         *
         * TODO: use a less arbitrary size.
         */
        long mapSize = 4096;
        /*
         * If there is less data remaining than what we want to map, reduce the
         * map size.
         */
        if ((fileSizeBytes - packetIndex.getOffsetBytes()) < mapSize) {
            mapSize = fileSizeBytes - packetIndex.getOffsetBytes();
        }

        /*
         * Map the packet.
         */
        try (FileChannel fc = FileChannel.open(fFile.toPath(), StandardOpenOption.READ)) {
            ByteBuffer map = SafeMappedByteBuffer.map(fc, MapMode.READ_ONLY, packetOffsetBytes, mapSize);
            if (map == null) {
                throw new CTFReaderException("Failed to allocate mapped byte buffer"); //$NON-NLS-1$
            }
            /*
             * create a packet bit buffer to read the packet header
             */
            BitBuffer bitBuffer = new BitBuffer(map);
            bitBuffer.setByteOrder(getStream().getTrace().getByteOrder());
            /*
             * Read the trace packet header if it exists.
             */
            if (fTracePacketHeaderDecl != null) {
                parseTracePacketHeader(fTracePacketHeaderDecl, bitBuffer);
            }

            /*
             * Read the stream packet context if it exists.
             */
            if (fStreamPacketContextDecl != null) {
                parsePacketContext(fileSizeBytes, fStreamPacketContextDecl,
                        bitBuffer, packetIndex);
            } else {
                setPacketContextNull(fileSizeBytes, packetIndex);
            }

            position = bitBuffer.position();
        } catch (IOException e) {
            throw new CTFReaderException(e);
        }
        return position;
    }

