    /**
     * Create the index for this trace file.
     *
     * @throws CTFReaderException
     */
    public void createIndex() throws CTFReaderException {
        /*
         * The size of the file in bytes
         */
        long fileSizeBytes = 0;
        try {
            fileSizeBytes = fileChannel.size();
        } catch (IOException e) {
            throw new CTFReaderException(e);
        }

        /*
         * Offset of the current packet in bytes
         */
        long packetOffsetBytes = 0;

        /*
         * Initial size, it should map at least the packet header + context
         * size.
         *
         * TODO: use a less arbitrary size.
         */
        long mapSize = 4096;

        /*
         * Definition of trace packet header
         */
        StructDefinition tracePacketHeaderDef = null;

        /*
         * Definition of trace stream packet context
         */
        StructDefinition streamPacketContextDef = null;

        /*
         * The BitBuffer to extract data from the StreamInput
         */
        BitBuffer bitBuffer = new BitBuffer();
        bitBuffer.order(this.getStream().getTrace().getByteOrder());

        /*
         * Create the definitions we need to read the packet headers + contexts
         */
        if (getStream().getTrace().getPacketHeader() != null) {
            tracePacketHeaderDef = getStream().getTrace().getPacketHeader().createDefinition(
                    this, "trace.packet.header"); //$NON-NLS-1$
        }

        if (getStream().getPacketContextDecl() != null) {
            streamPacketContextDef = getStream().getPacketContextDecl().createDefinition(
                    this, "stream.packet.context"); //$NON-NLS-1$
        }

        /*
         * Scan through the packets of the file.
         */
        while (packetOffsetBytes < fileSizeBytes) {
            /*
             * If there is less data remaining than what we want to map, reduce
             * the map size.
             */
            if ((fileSizeBytes - packetOffsetBytes) < mapSize) {
                mapSize = fileSizeBytes - packetOffsetBytes;
            }

            /*
             * Map the packet.
             */
            MappedByteBuffer bb;
            try {
                bb = fileChannel.map(MapMode.READ_ONLY, packetOffsetBytes,
                        mapSize);
            } catch (IOException e) {
                throw new CTFReaderException(e);
            }
            bitBuffer.setByteBuffer(bb);

            /*
             * Create the index entry
             */
            StreamInputPacketIndexEntry packetIndex = new StreamInputPacketIndexEntry(
                    packetOffsetBytes);

            /*
             * Read the trace packet header if it exists.
             */
            if (tracePacketHeaderDef != null) {
                tracePacketHeaderDef.read(bitBuffer);

                /*
                 * Check the CTF magic number
                 */
                IntegerDefinition magicDef = (IntegerDefinition) tracePacketHeaderDef.lookupDefinition("magic"); //$NON-NLS-1$
                if (magicDef != null) {
                    int magic = (int) magicDef.getValue();
                    if (magic != Utils.CTF_MAGIC) {
                        throw new CTFReaderException(
                                "CTF magic mismatch " + Integer.toHexString(magic) + " vs " + Integer.toHexString(Utils.CTF_MAGIC)); //$NON-NLS-1$//$NON-NLS-2$
                    }

                }

                /*
                 * Check the trace UUID
                 */
                ArrayDefinition uuidDef = (ArrayDefinition) tracePacketHeaderDef.lookupDefinition("uuid"); //$NON-NLS-1$
                if (uuidDef != null) {
                    byte[] uuidArray = new byte[16];

                    for (int i = 0; i < 16; i++) {
                        IntegerDefinition uuidByteDef = (IntegerDefinition) uuidDef.getElem(i);
                        uuidArray[i] = (byte) uuidByteDef.getValue();
                    }

                    UUID uuid = Utils.makeUUID(uuidArray);

                    if (!getStream().getTrace().getUUID().equals(uuid)) {
                        throw new CTFReaderException("UUID mismatch"); //$NON-NLS-1$
                    }
                }

                /*
                 * Check that the stream id did not change
                 */
                IntegerDefinition streamIDDef = (IntegerDefinition) tracePacketHeaderDef.lookupDefinition("stream_id"); //$NON-NLS-1$
                if (streamIDDef != null) {
                    long streamID = streamIDDef.getValue();

                    if (streamID != getStream().getId()) {
                        throw new CTFReaderException(
                                "Stream ID changing within a StreamInput"); //$NON-NLS-1$
                    }
                }
            }

            /*
             * Read the stream packet context if it exists.
             */
            if (streamPacketContextDef != null) {
                streamPacketContextDef.read(bitBuffer);

                /*
                 * Read the content size in bits
                 */
                IntegerDefinition contentSizeDef = (IntegerDefinition) streamPacketContextDef.lookupDefinition("content_size"); //$NON-NLS-1$
                if (contentSizeDef != null) {
                    packetIndex.contentSizeBits = (int) contentSizeDef.getValue();
                } else {
                    packetIndex.contentSizeBits = (int) (fileSizeBytes * 8);
                }

                /*
                 * Read the packet size in bits
                 */
                IntegerDefinition packetSizeDef = (IntegerDefinition) streamPacketContextDef.lookupDefinition("packet_size"); //$NON-NLS-1$
                if (packetSizeDef != null) {
                    packetIndex.packetSizeBits = (int) packetSizeDef.getValue();
                } else {
                    if (packetIndex.contentSizeBits != 0) {
                        packetIndex.packetSizeBits = packetIndex.contentSizeBits;
                    } else {
                        packetIndex.packetSizeBits = (int) (fileSizeBytes * 8);
                    }
                }

                /*
                 * Read the begin timestamp
                 */
                IntegerDefinition timestampBeginDef = (IntegerDefinition) streamPacketContextDef.lookupDefinition("timestamp_begin"); //$NON-NLS-1$
                if (timestampBeginDef != null) {
                    packetIndex.timestampBegin = timestampBeginDef.getValue();
                }

                /*
                 * Read the end timestamp
                 */
                IntegerDefinition timestampEndDef = (IntegerDefinition) streamPacketContextDef.lookupDefinition("timestamp_end"); //$NON-NLS-1$
                if (timestampEndDef != null) {
                    setTimestampEnd(packetIndex.timestampEnd = timestampEndDef.getValue());
                }
            } else {
                /*
                 * If there is no packet context, infer the content and packet
                 * size from the file size (assume that there is only one packet
                 * and no padding)
                 */
                packetIndex.contentSizeBits = (int) (fileSizeBytes * 8);
                packetIndex.packetSizeBits = (int) (fileSizeBytes * 8);
            }

            /* Basic validation */
            if (packetIndex.contentSizeBits > packetIndex.packetSizeBits) {
                throw new CTFReaderException("Content size > packet size"); //$NON-NLS-1$
            }

            if (packetIndex.packetSizeBits > ((fileSizeBytes - packetIndex.offsetBytes) * 8)) {
                throw new CTFReaderException(
                        "Not enough data remaining in the file for the size of this packet"); //$NON-NLS-1$
            }

            /*
             * Offset in the file, in bits
             */
            packetIndex.dataOffsetBits = bitBuffer.position();

            /*
             * Add the packet index entry to the index
             */
            index.addEntry(packetIndex);

            /*
             * Update the counting packet offset
             */
            packetOffsetBytes += (packetIndex.packetSizeBits + 7) / 8;

        }
    }

