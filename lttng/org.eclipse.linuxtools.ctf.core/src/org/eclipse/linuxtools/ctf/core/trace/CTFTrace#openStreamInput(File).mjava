    /**
     * Tries to open the given file, reads the first packet header of the file
     * and check its validity. This will add a file to a stream as a streaminput
     *
     * @param streamFile
     *            A trace file in the trace directory.
     * @param index
     *            Which index in the class' streamFileChannel array this file
     *            must use
     * @throws CTFReaderException
     *             if there is a file error
     */
    private CTFStream openStreamInput(File streamFile) throws CTFReaderException {
        ByteBuffer byteBuffer;
        BitBuffer streamBitBuffer;
        CTFStream stream;

        if (!streamFile.canRead()) {
            throw new CTFReaderException("Unreadable file : " //$NON-NLS-1$
                    + streamFile.getPath());
        }

        try (FileChannel fc = FileChannel.open(streamFile.toPath(), StandardOpenOption.READ)) {
            /* Map one memory page of 4 kiB */
            byteBuffer = SafeMappedByteBuffer.map(fc, MapMode.READ_ONLY, 0, (int) Math.min(fc.size(), 4096L));
            if (byteBuffer == null) {
                throw new IllegalStateException("Failed to allocate memory"); //$NON-NLS-1$
            }
            /* Create a BitBuffer with this mapping and the trace byte order */
            streamBitBuffer = new BitBuffer(byteBuffer, this.getByteOrder());

            if (fPacketHeaderDecl != null) {
                /* Read the packet header */
                fPacketHeaderDef = fPacketHeaderDecl.createDefinition(this, LexicalScope.PACKET_HEADER, streamBitBuffer);
            }
        } catch (IOException e) {
            /* Shouldn't happen at this stage if every other check passed */
            throw new CTFReaderException(e);
        }
        if (fPacketHeaderDef != null) {
            validateMagicNumber(fPacketHeaderDef);

            validateUUID(fPacketHeaderDef);

            /* Read the stream ID */
            IDefinition streamIDDef = fPacketHeaderDef.lookupDefinition("stream_id"); //$NON-NLS-1$

            if (streamIDDef instanceof IntegerDefinition) {
                /* This doubles as a null check */
                long streamID = ((IntegerDefinition) streamIDDef).getValue();
                stream = fStreams.get(streamID);
            } else {
                /* No stream_id in the packet header */
                stream = fStreams.get(null);
            }

        } else {
            /* No packet header, we suppose there is only one stream */
            stream = fStreams.get(null);
        }

        if (stream == null) {
            throw new CTFReaderException("Unexpected end of stream"); //$NON-NLS-1$
        }

        /*
         * Create the stream input and add a reference to the streamInput in the
         * stream.
         */
        stream.addInput(new CTFStreamInput(stream, streamFile));
        return stream;
    }

