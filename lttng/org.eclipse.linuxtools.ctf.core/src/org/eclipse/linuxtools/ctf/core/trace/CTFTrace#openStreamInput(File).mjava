    /**
     * Tries to open the given file, reads the first packet header of the file
     * and check its validity. This will add a file to a stream as a streaminput
     *
     * @param streamFile
     *            A trace file in the trace directory.
     * @param index
     *            Which index in the class' streamFileChannel array this file
     *            must use
     * @throws CTFReaderException
     *             if there is a file error
     */
    private CTFStream openStreamInput(File streamFile) throws CTFReaderException {
        ByteBuffer byteBuffer;
        BitBuffer streamBitBuffer;
        CTFStream stream;

        if (!streamFile.canRead()) {
            throw new CTFReaderException("Unreadable file : " //$NON-NLS-1$
                    + streamFile.getPath());
        }

        try (FileInputStream fis = new FileInputStream(streamFile);
                FileChannel fc = fis.getChannel()) {
            /* Map one memory page of 4 kiB */
            byteBuffer = SafeMappedByteBuffer.map(fc, MapMode.READ_ONLY, 0, (int) Math.min(fc.size(), 4096L));
            if (byteBuffer == null) {
                throw new IllegalStateException("Failed to allocate memory"); //$NON-NLS-1$
            }
        } catch (IOException e) {
            /* Shouldn't happen at this stage if every other check passed */
            throw new CTFReaderException(e);
        }

        /* Create a BitBuffer with this mapping and the trace byte order */
        streamBitBuffer = new BitBuffer(byteBuffer, this.getByteOrder());

        if (fPacketHeaderDecl != null) {
            /* Read the packet header */
            fPacketHeaderDef = fPacketHeaderDecl.createDefinition(this, LexicalScope.PACKET_HEADER, streamBitBuffer);

            /* Check the magic number */
            IntegerDefinition magicDef = (IntegerDefinition) fPacketHeaderDef.lookupDefinition("magic"); //$NON-NLS-1$
            int magic = (int) magicDef.getValue();
            if (magic != Utils.CTF_MAGIC) {
                throw new CTFReaderException("CTF magic mismatch"); //$NON-NLS-1$
            }

            /* Check UUID */
            IDefinition lookupDefinition = fPacketHeaderDef.lookupDefinition("uuid"); //$NON-NLS-1$
            ArrayDefinition uuidDef = (ArrayDefinition) lookupDefinition;
            if (uuidDef != null) {
                UUID otheruuid = Utils.getUUIDfromDefinition(uuidDef);

                if (!fUuid.equals(otheruuid)) {
                    throw new CTFReaderException("UUID mismatch"); //$NON-NLS-1$
                }
            }

            /* Read the stream ID */
            IDefinition streamIDDef = fPacketHeaderDef.lookupDefinition("stream_id"); //$NON-NLS-1$

            if (streamIDDef instanceof IntegerDefinition) { // this doubles as a
                                                            // null check
                long streamID = ((IntegerDefinition) streamIDDef).getValue();
                stream = fStreams.get(streamID);
            } else {
                /* No stream_id in the packet header */
                stream = fStreams.get(null);
            }

        } else {
            /* No packet header, we suppose there is only one stream */
            stream = fStreams.get(null);
        }

        if (stream == null) {
            throw new CTFReaderException("Unexpected end of stream"); //$NON-NLS-1$
        }

        /*
         * Create the stream input and add a reference to the streamInput in the
         * stream
         */
        stream.addInput(new CTFStreamInput(stream, streamFile));

        return stream;
    }

