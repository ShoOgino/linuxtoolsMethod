    private void parseClock(CommonTree clock) {
        List<CommonTree> children = clock.getChildren();
        CTFClock ctfClock = new CTFClock();
        for (CommonTree child : children) {
            final String key = child.getChild(0).getChild(0).getChild(0)
                    .getText();
            final CommonTree value = (CommonTree) child.getChild(1).getChild(0).getChild(0);
            final int type = value.getType();
            switch (type) {
            case CTFParser.INTEGER:
            case CTFParser.DECIMAL_LITERAL:
                /*
                 * Not a pretty hack, this is to make sure that there is no number
                 * overflow due to 63 bit integers. The offset should only really
                 * be an issue in the year 2262. the tracer in C/ASM can write an offset in
                 * an unsigned 64 bit long. In java, the last bit, being set to 1 will
                 * be read as a negative number, but since it is too big a positive it will
                 * throw an exception. this will happen in 2^63 ns from 1970.
                 * Therefore 293 years from 1970
                 */
                Long numValue;
                try{
                    numValue = Long.parseLong(value.getText());
                }
                catch( Exception e)
                {
                    numValue = 1330938566783103277L;
                }
                ctfClock.addAttribute(key, numValue);
                break;
            default:
                ctfClock.addAttribute(key, value.getText());
            }

        }
        String NameValue = ctfClock.getName();
        trace.addClock(NameValue, ctfClock);
    }

