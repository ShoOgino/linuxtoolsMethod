    /**
     * Parses a typedef node. This creates and registers a new declaration for
     * each declarator found in the typedef.
     *
     * @param typedef
     *            A TYPEDEF node.
     * @throws ParseException
     *             If there is an error creating the declaration.
     */
    private void parseTypedef(CommonTree typedef) throws ParseException {
        assert (typedef.getType() == CTFParser.TYPEDEF);

        CommonTree typeDeclaratorListNode = (CommonTree) typedef.getFirstChildWithType(CTFParser.TYPE_DECLARATOR_LIST);
        assert (typeDeclaratorListNode != null);

        CommonTree typeSpecifierListNode = (CommonTree) typedef.getFirstChildWithType(CTFParser.TYPE_SPECIFIER_LIST);
        assert (typeSpecifierListNode != null);

        List<CommonTree> typeDeclaratorList = typeDeclaratorListNode.getChildren();
        assert (typeDeclaratorList != null);

        for (CommonTree typeDeclaratorNode : typeDeclaratorList) {
            StringBuilder identifierSB = new StringBuilder();

            IDeclaration type_declaration = parseTypeDeclarator(
                    typeDeclaratorNode, typeSpecifierListNode, identifierSB);

            if (type_declaration instanceof VariantDeclaration) {
                if (((VariantDeclaration) type_declaration).isTagged()) {
                    throw new ParseException(
                            "Typealias of untagged variant is not permitted"); //$NON-NLS-1$
                }
            }

            getCurrentScope().registerType(identifierSB.toString(),
                    type_declaration);
        }
    }

