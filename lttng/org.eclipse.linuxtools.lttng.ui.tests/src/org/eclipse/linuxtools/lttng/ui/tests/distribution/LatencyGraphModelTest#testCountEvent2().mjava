    public void testCountEvent2() {

        final int nbBuckets = 2000;
        final int nbEvents = 10 * nbBuckets + 256;
        final long offset = 100;
        final int height = 100;
        final int width = 100;
        final int barWidth = 1;
        
        int[][] expectedResults = new int[width/barWidth][height/barWidth];
        
        int total = 0;
        
        // Horizontally and vertically the same data is used
        
        // for nbBuckets=2000 and nbEvents=20256 (means 20256 ns + offset) -> model.bucketDuration = 16
        // nbBars = width / barWidth = 100
        // bucketsPerBar = lastBucket/nbBars + 1 = 13
        // scaled bucket duration = bucketsPerBar * model.bucketDuration =  13 * 16
        boolean isFinished = false;
        for (int i = 0; i < width/barWidth; i++) {
            if (isFinished) {
                break;
            }
            for (int j = 0; j < height/barWidth; j++) {
                if (i == j) {
                    int value = 13 * 16;
                    if (total + value > nbEvents) {
                        expectedResults[i][j] = nbEvents - total;
                        isFinished = true;
                        break;
                    }
                    else {
                        expectedResults[i][j] = value;
                        total += value;
                    }
                }
            }
        }
       
        LatencyGraphModel model = new LatencyGraphModel(nbBuckets);
        
        for (int i = 0; i < nbEvents; i++) {
            model.countEvent(i+1, offset + i, offset + i);
        }

        GraphScaledData scaledData = model.scaleTo(height, width, barWidth);

        for (int i = 0; i < scaledData.getHorLastBucket(); i++) {
            for (int j = 0; j < scaledData.getVerLastBucket(); j++) {
                assertEquals(expectedResults[i][j], scaledData.getEventCount(i, j));
            }
        }
    }

