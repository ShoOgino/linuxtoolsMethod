	/**
	 * Parses the spec file.
	 * @throws CoreException if parsing fails
	 */
    public void parse() throws CoreException {
        /* The following logic determines where in the spec file the "Patchx:" and
         * %patchx -p1" lines will need to be added to accomodate the patch we
         * are fixing to generate.  If this is the first patch to ever be added to this
         * source RPM then the "Patchx: statement will have to be added after the
         * last "Sourcex:" statement and the "%patch -p1" statement will need to be
         * added after the "%setup" statement.  If this is not the first patch for this
         * source rpm, the "Patchx:" statement will be added after the last "Patchx:"
         * statement and the "%patchx -p1" will be added after the last "%patch -p1"
         * statement.  So, we keep track of where the line numbers for all of these
         * eventualities are so when we mod the file we will know where to insert
         * the necessary new lines.
         */
        ArrayList patchlist = new ArrayList();
        boolean found_source_line = false;
        boolean found_patch = false;
        boolean found_define = false;
        boolean found_define_name = false;
        boolean found_version = false;
        boolean found_release = false;
        int define_ctr = 0;
        int define_line_ctr = 0;
        int lines = 1;

        try {
            FileReader sp_file = new FileReader(specFile.getLocation().toOSString());
            StreamTokenizer st = new StreamTokenizer(sp_file);

            // Make sure numbers, colons and percent signs are considered valid
            st.wordChars('a','z');
            st.wordChars('A','Z');
            st.wordChars(':', ':');
            st.wordChars('0', '9');
            st.wordChars('%', '%');
            st.wordChars('{', '}');
            st.wordChars('-', '-');
            st.wordChars('/', '/');
            st.wordChars('=','=');
            st.wordChars('.','.');
            st.wordChars('_','_');
            st.eolIsSignificant(true);
            
            String new_word;
            boolean check_ifs = false;
            int if_ctr = 0;
            int token = st.nextToken();
            while (token != StreamTokenizer.TT_EOF) {
                token = st.nextToken();

                switch (token) {
                case StreamTokenizer.TT_EOL:
                  lines++;
                  break;
                case StreamTokenizer.TT_WORD:
                    new_word = st.sval;
                    
/* The following commented out logic addresses bugzilla 110452 where the version and
 * release numbers for spec files are stored in "%define" variables at the top of the file.  It
 * has been decided to put this change on hold until it can be determined how pervasive
 * the use of this practice is.  The code is incomplete for the time being and may be deleted
 * entirely in future releases.
 */                   
/*                  if (found_version) {
                        found_version = false;
                        if (new_word.startsWith("%{")) {  //$NON-NLS-1$
                            version_param = true;
                            define_info.add(0,new_word.substring(2,new_word.length()-1));
                        }
                        break;
                    }
                    
                    if (found_release) {
                        found_release = false;
                        if (new_word.startsWith("%{")) {  //$NON-NLS-1$
//                          release_param = true;
                            define_info.add(1,new_word.substring(2,new_word.length()-1));
                        }
                        break;
                    }  */
                    
                    // See if we have found the Version: line
                    if (new_word.equals("Version:")) {  //$NON-NLS-1$
                        found_version = true;
                        break;
                    }
                    
                    // See if we have found the Release: line
                    if (new_word.equals("Release:")) {  //$NON-NLS-1$
                        found_release = true;
                        break;
                    }

                        // Record where the last line of the form "Sourcex:" is
                        if (new_word.startsWith("Source") &  //$NON-NLS-1$
                             new_word.endsWith(":")) { //$NON-NLS-1$
                            lastSourceLine = lines;
                            found_source_line = true;
                            break;
                        }

                        /* Record where the last line of the form "Patchx:" is and count how many there were.
                         * Also, record the statement so when we generate our new "Patchx:" statement
                         * we don't duplicate a "Patch" statement.  This has to be done because a lot of
                         * spec files have "Patchx:" statements that are non-sequential
                         */
                        if (new_word.startsWith("Patch") &  //$NON-NLS-1$
                               new_word.endsWith(":")) { //$NON-NLS-1$
                            lastPatchLine = lines;
                            numPatches++;
                            patchlist.add(new_word);

                            break;
                        }

                        // Record where the "%setup line is
                        if (new_word.equals("%setup")) { //$NON-NLS-1$

                            // set the "check for if" constructs switch
                            check_ifs = true;
                            setupLine = lines;

                            break;
                        }

                        if (new_word.equals("%build")) { //$NON-NLS-1$
                            check_ifs = false;
                            
                            break;
                        }

                        // Record where the last (if any) "%patchx" line is
                        if (new_word.startsWith("%patch")) { //$NON-NLS-1$
                            lastPatchMacroLine = lines;
                            found_patch = true;

                            break;
                        }
                        
                        // See if we have found a %define statement, if so save it as some
                        // source RPMs use %define statements to "define" version/release #'s
/* See the comment several lines above regarding bugzilla 110452 as it also pertains to this code */
/*                      if (new_word.equals("%define")) {  //$NON-NLS-1$
                            found_define = true;
                            define_line_ptr[define_line_ctr] = lines;
                            define_line_ctr++;
                            
                            break;
                        }  */
                        
                    if (found_define) {
                        found_define = false;
//                      define_info.add(define_ctr,new_word);
                        define_ctr++;
                        found_define_name = true;
                        break;
                    }
                    
                    if (found_define_name) {
                        found_define_name = false;
//                      define_info.add(define_ctr,new_word);
                        define_ctr++;
                        break;
                    }

                        // Set the found %if/%ifarch/%ifnarch/%ifos/%ifnos switch
                        if (check_ifs) {
                            if (new_word.startsWith("%if")) { //$NON-NLS-1$
                                if_ctr++;

                                break;
                            }

                            // Reset the found %if/%ifarch switch
                            if (new_word.equals("%endif")) { //$NON-NLS-1$

                                if ((if_ctr > 0) & found_patch) {
                                    if_ctr--;
                                    lastPatchMacroLine = lines;
                                    found_patch = false;

                                    break;
                                }
                            }

                            break;
                        }
                        
                        break;

                default:
                    break;
                }
            }

            sp_file.close();
        } catch (IOException e) {
            e.printStackTrace();
            String throw_message = Messages.getString(
                    "RPMCore.Error_parsing_the_spec_file_in_the_project_--_157") + //$NON-NLS-1$
                    specFile.getLocation().toOSString();
            IStatus error = new Status(IStatus.ERROR, IRPMConstants.ERROR, 1, throw_message,
                    null);
            throw new CoreException(error);
        }

        if (numPatches > 1) {
            int patch_num = getUniquePatchId(patchlist, numPatches);
            numPatches = patch_num;
        }
        setConfigureArgs(parseConfigureArgs());
        parseNameVerRel();
    }

