    /**
     * Method parseNameVerRel interrogates a spec file for the name, version and release
     * of the RPM
     * @param path_to_specfile contains a string pointing to the specfile to interrogate
     * @return if successful, throw Exception if not
     */

    private void parseNameVerRel() throws CoreException {
        String path_to_specfile = specFile.getLocation().toOSString();
        ArrayList rpm_info = new ArrayList();
        ArrayList define_info = new ArrayList();

        // initialize version/release numbers to 0 in case none are found in the spec file
        rpm_info.add(0, "0"); //$NON-NLS-1$
        rpm_info.add(1, "0"); //$NON-NLS-1$
        rpm_info.add(2, " "); //$NON-NLS-1$

        boolean found_version = false;
        boolean found_release = false;
        boolean found_name = false;
        boolean found_ver_token = false;
        boolean found_rel_token = false;
        boolean found_name_token = false;
        boolean found_define = false;
        boolean found_define_name = false;
        int define_ctr = 0;
        
        File f = new File(path_to_specfile);

        if (!f.exists()) {
            String throw_message = "" + //$NON-NLS-1$
                path_to_specfile;
            IStatus error = new Status(IStatus.ERROR, Messages.getString("RPMCore.Error_1"), 1, //$NON-NLS-1$
                    throw_message, null);
            throw new CoreException(error);
        }

        try {
            FileReader sp_file = new FileReader(path_to_specfile);
            StreamTokenizer st = new StreamTokenizer(sp_file);

            // Make sure numbers, colons and periods are considered valid characters
            st.resetSyntax();
            st.wordChars(':', ':');
            st.wordChars('0', '9');
            st.wordChars('.', '.');
            st.wordChars('A', 'z');
            st.wordChars('%','%');
            st.wordChars('{','{');
            st.wordChars('}','}');

            int token = 0;
            String new_word;
outer: 
            while (token != StreamTokenizer.TT_EOF) {
                token = st.nextToken();

                switch (token) {
                case StreamTokenizer.TT_WORD:
                    new_word = st.sval;
                    
                    if (found_define) {
                        found_define = false;
                        define_info.add(define_ctr,new_word);
                        define_ctr++;
                        found_define_name = true;
                        break;
                    }
                    
                    if (found_define_name) {
                        found_define_name = false;
                        define_info.add(define_ctr,new_word);
                        define_ctr++;
                        break;
                    }
                    
                    if (found_version & !found_ver_token) {
                        found_ver_token = true;
                        if (new_word.startsWith("%")) { //$NON-NLS-1$
                            try {
                                rpm_info.set(0,parseDefine(new_word, define_info));
                            } catch (Exception e) {
                                String throw_message = Messages.getString("RPMCore.Error_using_parseDefine_to_get_the_version_no._41") + //$NON-NLS-1$
                                  Messages.getString("RPMCore._from_the_spec_file_at___42") + path_to_specfile; //$NON-NLS-1$
                                IStatus error = new Status(IStatus.ERROR, Messages.getString("RPMCore.Error_1"), 1, //$NON-NLS-1$
                                                    throw_message, null);
                                throw new CoreException(error);
                            }
                        } else {
                             rpm_info.set(0, new_word);
                        }

                        // System.out.println("Found version = " + new_word);
                        if (found_name_token & found_ver_token &
                                found_rel_token) {
                            break outer;
                        }

                        break;
                    }

                    if (found_release & !found_rel_token) {
                        found_rel_token = true;
                        if (new_word.startsWith("%")) {  //$NON-NLS-1$
                            try {
                                rpm_info.set(1,parseDefine(new_word, define_info));
                            } catch (Exception e) {
                            String throw_message = Messages.getString("RPMCore.Error_using_parseDefine_to_get_the_release_no._44") + //$NON-NLS-1$
                              Messages.getString("RPMCore._from_the_spec_file_at___45") + path_to_specfile; //$NON-NLS-1$
                            IStatus error = new Status(IStatus.ERROR, Messages.getString("RPMCore.Error_1"), 1, //$NON-NLS-1$
                                                throw_message, null);
                            throw new CoreException(error);
                        }
                            break;
                        } else {
                             rpm_info.set(1, new_word);
                          }

                        // System.out.println("Found release = " + new_word);
                        if (found_name_token & found_ver_token &
                                found_rel_token) {
                            break outer;
                        }

                        break;
                    }

                    if (found_name & !found_name_token) {
                        found_name_token = true;
                        rpm_info.set(2, new_word);

                        // System.out.println("Found name = " + new_word);
                        if (found_name_token & found_ver_token &
                                found_rel_token) {
                            break outer;
                        }

                        break;
                    }

                    // See if this is a "Version:" tag
                    if (new_word.equals("Version:")) { //$NON-NLS-1$
                        found_version = true;
                        break;
                    }

                    // See if this is a "Release:" tag
                    if (new_word.equals("Release:")) { //$NON-NLS-1$
                        found_release = true;
                        break;
                    }

                    // See if this is a "Name:" tag
                    if (new_word.equals("Name:")) { //$NON-NLS-1$
                        found_name = true;
                        break;
                    }
                    
                    // See if this a "%define" statement
                    // the version and release can sometimes be in a define stmt
                    if (new_word.equals("%define")) {  //$NON-NLS-1$
                        found_define = true;
                        break;
                    }

                default:
                    break;
                }
            }
        } catch (IOException e) {
            String throw_message = Messages.getString(
                    "RPMCore.Error_parsing_the_spec_file_at") + //$NON-NLS-1$
                path_to_specfile;
            IStatus error = new Status(IStatus.ERROR, Messages.getString("RPMCore.Error_1"), 1, //$NON-NLS-1$
                    throw_message, null);
            throw new CoreException(error);
        }

        /* Ugly: In rpm_info ArrayList:
         * [0] = Version
         * [1] = Release
         * [2] = Name
         */
        setVersion((String) rpm_info.get(0));
        setRelease((String) rpm_info.get(1));
        setName((String) rpm_info.get(2));
    }

