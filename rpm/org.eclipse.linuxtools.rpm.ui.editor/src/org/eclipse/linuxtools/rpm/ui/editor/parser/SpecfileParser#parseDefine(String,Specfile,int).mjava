	private SpecfileDefine parseDefine(String lineText, Specfile specfile, int lineNumber) {
		List<String> tokens = Arrays.asList(lineText.split("\\s+")); //$NON-NLS-1$
		SpecfileDefine toReturn = null;
		for (Iterator<String> iter = tokens.iterator(); iter.hasNext();) {
			// Eat the actual "%define" token
			iter.next();
			while (iter.hasNext()) {
				String defineName = iter.next();
				// FIXME: is this true?  investigate in rpmbuild source
				// Definitions must being with a letter
				if (!Character.isLetter(defineName.charAt(0)) && (defineName.charAt(0) != '_')) {
					errorHandler
					.handleError(new SpecfileParseException(
							"Definition lvalue must begin with a letter or an underscore.",
							lineNumber, 0, lineText.length(),
							IMarker.SEVERITY_ERROR));
					return null;
				} else {
					if (!iter.hasNext()) {
						// FIXME: Should this be an error?
						errorHandler
						.handleError(new SpecfileParseException(
								"No value name after define.",
								lineNumber, 0, lineText
								.length(),
								IMarker.SEVERITY_WARNING));
					} else {
						String defineStringValue = iter.next();
						// Defines that are more than one token
						if (iter.hasNext()) {
							defineStringValue = lineText.substring(lineText
									.indexOf(defineStringValue));
							// Eat up the rest of the tokens
							while (iter.hasNext())
								iter.next();
						}
						int defineIntValue = -1;
						try {
							defineIntValue = Integer
							.parseInt(defineStringValue);
						} catch (NumberFormatException e) {
							toReturn = new SpecfileDefine(defineName,
									defineStringValue, specfile);
						}
						if (toReturn == null)
							toReturn = new SpecfileDefine(defineName,
								defineIntValue, specfile);
					}
				}
			}
		}
		return toReturn;
	}

